16-Mar-23
-----------
A language is a communication media.

Any language contains two important things

1) Syntax (Rules)
2) Semantics (Structure OR Meaning)

English langugae translation :
--------------------------------
Subject + verb + Object (Syntax)

He is a boy. (Valid)

He is a box. (Invalid)

Example of Progamming Language :
----------------------------------------
int a = 10;
int b = 0;
int c = a/b;   //Exception

Note :- 
Syntax of the programming language is taken care by compiler.
compiler generates errors if a user does not follow the syntax of the programming language.

Semantics is taken care by our runtime Environment. It generates Exception if a user does not follow the semantics.

Statically(Strongly) typed language :-
---------------------------------------
The languages where data type is compulsory before initialization of a variable are called statically typed language.
In these languages we can hold same kind of value during the execution of the program.

Ex:- C,C++,Core Java, C#

Dynamically(Loosly) typed language :-
-------------------------------------------
The languages where data type is not compulsory and it is optional before initialization of a variable then it is called dynamically typed language.

In these languages we can hold different kind of value during the execution of the program.
Ex:- Visual Basic, Javascript, Python
------------------------------------------------------------------------------------------------
17-Mar-23
------------

Flavors Of JAVA language :
------------------------------
1) JSE (Java Standard Edition) ->J2SE -> Core Java

2) JEE (Java Enterprise Edition) -> J2EE -> Advanced Java

3) JME (Java Micro Edition) -> J2ME -> Android Application


What is the difference between stand alone programs and web related
------------------------------------------------------------------------------
program?
-----------
Standalone Application
--------------------------
If the creation(development), compilation and execution of the program, everthing is done in a single system then it is called stand-alone program.
Eg:- C, C++, Java, C# and so on.

Stand alone programs are also known as Software OR Desktop application.

As a developer we should always suggest stand alone application to our client, if the client data is private or if we want to upload the data in the website then we need to provide a separate username and password to each and every client.


Web - related Application :-
--------------------------------
If creation of the program, compilation of the program and execution of the program, Everything is done on different places then it is called web related program.
Eg:- Advanced Java, PHP, ASP.NET, Python

Web related programs are also known as websites or web application.

As a developer we should suggest website to our client if the client information is public.
------------------------------------------------------------------------------------------------
18-Mar-23
-----------

What is a function :-
-----------------------
A function is a self defined block for any general purpose, calculation or printing some data.

The major benefits with function are :-
-------------------------------------------
1) Modularity :- Dividing the bigger modules into number of smaller modules where each module will perform its independent task.

2) Easy understanding :- Once we divide the bigger task into number of smaller tasks then it is easy to understand the entire code.

3) Reusability :- We can reuse a particular module so many number of times so It enhances the reusability nature.

Note :- In java we always reuse our classes.

4) Easy Debugging :- Debugging means finding the errors, With function It is easy to find out the errors because each module is independent with another module. 

Why we pass parameter to a function :-
--------------------------------------------
We pass parameter to a function for providing more information regrading the function.

Eg:-

userdefined function                  predefined function
public void start(int a)               start(3); // The fan is running in mode 3
{
  //start the fan
}

--------------------------------------------------------------------------------------
Why functions are called method in java?
----------------------------------------------
In C++ there is a facility to write a function inside the class as well as outside of the class by using :: (Scope resolution Operator), But in java all the functions must be declared inside the class only.

That is the reason member functions are called method in java.

Variable -->  Field
function ---> Method
---------------------------------------------------------------------------------------------------------20-Mar-23
------------
History of java :
----------------
First Name of Java : OAK (In the year 1991 which is a tree name)

Project Name :- Green Project 

Inventor of Java : - James Gosling and his friends

Official Symbol :- Coffee CUP

Java :- Island (Indonesia)

Why java become so popular in the IT Industry ?
-----------------------------------------------------
The role of compiler :
-------------------------
a) Compiler are used to check the syntax.
b) It also check the compatibility issues(LHS = RHS)
c) It converts the source code into machine code.

Java code :
-------------
a) Java programs must be saved having extension .java

b) java compiler(javac) is used to compile our code.

c) After successful compilation we are getting .class file (bytecode)

d) This .class file we submit to JVM for execution prupose (for executing my java code)

JVM :- It stands for Java Virtual Machine. It is a software in the form of interpreter  written in 'C' language.

Every browser contains JVM, Those browsers are known as JEB (Java Enabled Browsers) browsers.
-------------------------------------------------------------------------------------
Why java language is so popular in the It industry :-
--------------------------------------------------------
C and C++ programs are platform dependent programs that means the .exe file created on one machine will not be executed on the another machine if the system configuration is different.

That is the reason C and C++ programs are not suitable for website development.

Where as on the other hand java is a platform independent language. Whenever we write a java program, the extension of java program must be .java. Now this .java file we submit to java compiler (javac) for compilation process. After successful compilation the compiler will generate a very special machine code file i.e .class file (also known as bytecode). Now this .class file we submit to JVM for execution purpose.

The role of JVM is to load and execute the .class file. Here JVM plays a major role because It converts the .class file into appropriate machine code instruction (Operating System format) so java becomes platform independent language and it is highly suitable for website development.

Note :- We have different JVM for different Operating System that means JVM is platform dependent technology where as Java is platform Independent technology.
------------------------------------------------------------------------------------
What is the difference between the bit code and byte code.
------------------------------------------------------------------

Bit code is directly understood by Operating System but on the other hand byte code is understood by JVM, JVM is going to convert this byte code into machine understandable format.
--------------------------------------------------------------------------------------------------------
21-Mar-23
------------
Note :- Whenever we make some changes to .java file then to get fresh .class file we need to recompile our program.
------------------------------------------------------------------------------------------------------
Comments in JAVA :-
------------------------
Comments are used to increase the readability of the program. It is ignored by the compiler.
In java we have 3 types of comments 

1) Single line Comment (//)

2) Multiline Comment (/* ------------------------------- */)

3) Documentation Comment (/** -------------------------- */)

/**
Name of the Project : Online Shopping
Date created :- 12-12-2021
Last Modified - 16-01-2022
Author :- Ravishankar
Modules : -  10 Modules
*/
---------------------------------------------------------------------------------------
23-Mar-23
------------
WAP in java to display welcome message :
------------------------------------------------
At initial level we can write a java program with the help class and methods.

Syntax for a class 
--------------------
[Access Modifier]  class [Name of the class]
{
            
}

Syntax for a method :
-------------------------
[Access modifier] [return type] [Name of the method] ()
{


}
--------------------------------------------------------------------------------------
Note :- 
1) In java whenever we write a program we need at least a main method.

2) In java the execution of the program always starts and ends with main method.

--------------------------------------------------------------------------------------
Description of main() method :
-----------------------------------

public :-
--------
public is an access modifier in java. The main method must be declared as public otherwise JVM cannot execute our main method or in other words JVM can't enter inside the main method for execution of the program.

If main method is not declared as public then program will compile but it will not be executed by JVM.

Note :- From java compiler point of view there is no rule to declare our methods as public.
------------------------------------------------------------------------------------
static :-
--------
In java our main method is static so we need not to create an object to call the main method.

If a method is declared as a static then we need not to create an object to call that method. We can directly call the static methods with the help of class name.

If we don't declare the main method as static method then our program will compile but it will not be executed by JVM.
------------------------------------------------------------------------------------
void :-
-------
It is a keyword. It means no return type. Whenever we define any method in java and if we don't want to return any kind of value from that particular method then we should write void before the name of the method.

Eg:

public void input()                       public int accept()
{                                                 {
}                                                    return 15;
						   }

Note :- In the main method if we don't write void or any other kind of return type then it will generate a compilation error.

In java whenever we define a method then compulsory we should define return type of method.(Syntax rule)
------------------------------------------------------------------------------------
24-Mar-23
------------
main() :-
----------
It is a userdefined function/method because a user is responsible to define some logic inside the main method.

main() method is very important method because every program execution will start from main() method only, as well as the execution of the program ends with main() method only. 
------------------------------------------------------------------------------------
String [] args :-
------------------
Here String is a predefined class available in java.lang package(Header files in C and C++) and args is an array variable of type String.

Note :- args is an array variable, we can take square bracket before the variable as well as after the variable.
-------------------------------------------------------------------------------------
Command Line Argument :-
-------------------------------
Whenever we pass an argument/parameter to the main method then it is called Command Line Argument.

The argument inside the main method is String because String is a alpha-numeric collection of character so, It can accept numbers,decimals, characters, combination of number and character.

That is the reason java software people has provided String as a parameter inside the main method.(More Wider scope to accept the value)
---------------------------------------------------------------------------------------------
System.out.println() :-
-------------------------
It is an output statement in java, By using System.out.println() statement we can print anything on the console.

In System.out.println(), System is a predefined class available in java.lang package, out is a reference variable of PrintStream class and println() is a predfined method available in PrintStream class.

In System.out, .(dot) is a member access operator. It is called as period. It is used to access the member of the class.
---------------------------------------------------------------------------------------------
Naming convention in java language :
--------------------------------------------
1) How to write a class in java 
----------------------------------
While writing a class in java we should follow pascal naming conventation.

ThisIsExampleOfClass (Each word first letter is capital)
Example :
-----------
String 
System
Integer
BufferedReader
DataInputStream
ClassNotFoundException
ArithmeticException

2) How to write a method in java :
---------------------------------------
In order to write methods in java we need to follow camel case naming conventation.

thisIsExampleOfMethod()

Example:
----------
read()
readLine()
toUpperCase()
chatAt()


3) How to write variable(Fields) in java 
--------------------------------------------
In order to write variables in java we need to follow camel case naming convention.

rollNumber;
employeeName;
customerNumber;
customerBill;
--------------------------------------------------------------------------------------
25-Mar-23
------------
//WAP in java to add two numbers 
public class Addition 
{
	public static void main(String[] args) 
	{
	    int x = 15;
		int y = 20;
		int z = x + y;
		System.out.println(z);
	}
}
--------------------------------------------------------------------------------------
//Addition of two number with user-friendly message
public class Sum 
{
	public static void main(String[] args) 
	{
		int a = 100;
		int b = 200;
		int c = a+ b;
		System.out.println("Sum is :" + c);
	}
}
-------------------------------------------------------------------------------------
//Program to add two numbers without third variable
public class AddWithoutThirdVariable 
{
	public static void main(String[] args) 
	{
		int x = 100;
		int y = 200;
		System.out.println("Sum is :"+x + y); //Sum is 100200
		System.out.println(x+y);//300
		System.out.println(""+x+y); //100200
		System.out.println("Sum is :"+(x + y)); //Sum is 300
	}
}
--------------------------------------------------------------------------------------
How to configure javac and JVM in editplus :
---------------------------------------------------
JAVAC 
-------
Tools -> Configure User tools -> Add  tools -> Programs -> Type Some Name (Compiler) [Menu Text] -> From the browse button(...) select java compiler  [Program files]-> Argument -> File Name -> directory -> File Directory

JVM 
-----
Tools -> Configure User tools -> Add  tools -> Programs -> Type Some Name (JVM) [Menu Text] -> From the browse button(...) select java  -> Argument -> File Name without Extension -> Director -> File Directory
--------------------------------------------------------------------------------------
How to write our first program Eclipse IDE :
--------------------------------------------------
-> By using Eclipse IDE , In a single window we can develop, compile and execute our programs

-> Eclipse IDE provides an environment to execute our program with very less time. Once the time will be reduced then automatically the cost of the project will be reduced.


Command Line Argument :
------------------------------
Whenever we pass any argument to the main method then it is called Command Line Argument.

By using Command Line Argument we can pass some value at runtime.

The advantage of command line argument is "Single time compilation and number of times execution".
---------------------------------------------------------------------------------------
package com.tcs.ravi;

public class Command 
{
   public static void main(String[] x) 
   {
	System.out.println(x[0]);
   }
}

-------------------------------------------------------------------------------------

How to execute Command line program in Eclipse IDE :
-------------------------------------------------------------
Right click on the Program -> Run as -> Run configuration -> Arguments -> Program Argument (Pass some value accroding to your use ) -> Click on Run
---------------------------------------------------------------------------------------
27-Mar-23
-------------
public class Command 
{
   public static void main(String[] x) 
   {	
	   System.out.println(x[0]);
   }
}

Case 1 :
--------
java Command Virat [We are passing Virat as a Command Line Argument]

It will Print Virat


Case 2 :
---------
java Command Virat Kohli [We are passing Virat as a Command Line Argument]

It will Print Virat

Case 3 :
----------
java Command "Virat Kohli"

It will Virat Kohli
--------------------------------------------------------------------------------------
public class AddCommand {

	public static void main(String x[]) 
	{
		System.out.println(x[1]);

	}

}

Case 4 :
-----------
java AddCommand 100 

Note :- The value 100 in the 0th position , in the first position we are not passing any value so JVM will throw an Exception i.e
java.lang.ArrayIndexOutOfBoundsException
------------------------------------------------------------------------------------------
public class AddCommand 
{

	public static void main(String x[]) 
	{
		System.out.println(x[0] + x[1]);
		
	}

}

java AddCommand 100 200 //Here 100 and 200, both will be treated as String type so Here '+' operator will work as a String Concatenation Operator.

So the output is 100200

Note :- WE NEED NOT TO IMPORT java.lang package, by default it is available to all the classes so we never import java.lang package.
------------------------------------------------------------------------------------------
How to convert a String value to integer :
-----------------------------------------------
If we want to convert any String value into integer then java software people has provided a predefined class called Integer available in java.lang package , this class contains a predefined static method parseInt(String x) through which we can convert any String value into integer.

public class Integer
{
   public static int parseInt(String x)
   {
      //Logic to convert String into integer and returns integer

      return integer value;
   }
}
--------------------------------------------------------------------------------------
//WAP in java to add two numbers using Command Line Argument
package com.tcs.ravi;
public class AddCommand {

	public static void main(String x[]) 
	{
	     int i = Integer.parseInt(x[0]);
	     int j = Integer.parseInt(x[1]);
	     System.out.println(i+j);   
	 	
	  }
}
-------------------------------------------------------------------------------------------

Token :
--------
A token is the smallest unit of the program that is identified by the compiler.

Every Java statements and expressions are created using tokens.

A token can be divided into 5 types 

1) Keywords
2) Identifiers
3) Literals
4) Punctuators
5) Operators

Keyword :- 
----------
A keyword is a predefined word whose meaning is already defined by the compiler.

In java all the keywords must be in lowercase only.

A keyword we can't use as a name of the variable, name of the class or name of the method.

true, false and null look like keywords but actually they are literals.



Identifiers :
--------------
A name in java program  by default considered as identifiers.

Assigned to variable, method, classes to uniquely identify them.

We can't use keyword as an identifier.

Ex:-

class Fan 
{
   int coil ;

   void start()
   {
   }
}

Here Fan(Name of the class), coil (Name of the variable) and start(Name of the function) are identifiers.
------------------------------------------------------------------------------------
Rules for defining an identifier :
------------------------------------
1) Can consist of uppercase(A-Z), lowercase(a-z),  digits(0-9), $ sign, and 
    underscore (_)
2) Begins with letter, $, and _
3) It is case sensitive
4) Cannot be a keyword
5) No limitation of length 
------------------------------------------------------------------------------------
Literals :-
-----------
Assigning some constant value to variable is called Literal.

Java supports 5 types of Literals :

1) Integral Literal  Ex:-  int x = 15;

2) Floating Point Literal  Ex:- float x = 3.5f;

3) Character Literal Ex:- char ch = 'A';

4) Boolean Literal Ex:- boolean b = true;

5) String Literal Ex:- String x = "Naresh i Technology";

Note :- null is also a literal.
------------------------------------------------------------------------------------
28-Mar-23
-------------
Integral Literal :
------------------
If a Numeric literal does not contain any decimal or fraction then it is called Integral Literal.

Ex:- 15, 45, 890 

In integral Literal we have 4 data types 
a) byte (8 bits )
b) short (16 bits)
c) int (32 bits)
d) long (64 bits)


An integral literal we can specify or represent in different ways

a) Decimal literal (Base 10)
b) Octal literal (Base 8)
c) Hexadecimal literal (Base 16)
d) Binary Literal (Base 2) (Available from JDK 1.7 onwards)

Note :- As a developer we can represent an integral literal in different forms(decimal, octal, hexadecimal and binary) but JVM always produces the output in decimal form only

Decimal Literal :- 
-------------------
The base of decimal literal is 10. we can accept any digit from 0-9

Octal Literal :-
----------------
The base is 8. Here we can accept digits from 0-7 only. In java if any integral literal prefeix with '0' (Zero) then it becomes octal lietral.

Example:-

int x = 015; //Valid
int y = 018;//Invalid

Hexadecimal Literal :-
-------------------------
The base is 16. Here we can accept digits from 0-15 (0-9 and A-F). In java if any integral literal prefix with 0X or 0x (zero with capital X OR zero with small x) then it becomes hexadecimal literal.

Example :-

int x = 0X15; //Valid
int y = 0x14;//Valid
int z = 0Xadd; //Valid
int a = 0Xage; //Invalid ['g' is out of range]

Binary Literal :-
-----------------
It is introduced from jdk 1.7 onwards. The base or radix is 2. Here we can accept digits 0 and 1 only. In java if any integral Literal prefix with 0B or 0b (zero capital B or 0 small b) then it becomes binary literal.

Example :-

int x = 0B111; //Valid
int y = 0b101010; //Valid
int z = 0B12; //Invalid [digit 2 is out of range]

Note :-
------
Being a user we can represent integral literal in decimal, octal, hexadecimal and binary form but JVM always produces the result in decimal only.
-----------------------------------------------------------------------------------
//Octal literal
class Test1
{
	public static void main(String[] args) 
	{
		int one=01;  
		int six=06;
		int seven=07;
		int eight=010;
		int nine=011;
        System.out.println("Octal 01 = "+one);
        System.out.println("Octal 06 = "+six);
		System.out.println("Octal 07 = "+seven);
		System.out.println("Octal 010 = "+eight);
		System.out.println("Octal 011   = "+nine);
	}
}
-------------------------------------------------------------------------------------
//Hexadecimal
public class Test2
{
public static void main(String[] args)
	{
		int i = 0x10;//16
		int j = 0Xadd;   //2781
		System.out.println(i); 
		System.out.println(j); 
	}
}
-------------------------------------------------------------------------------------
//Binary Literal
public class Test3
{
public static void main(String[] args)
	{
		int i = 0b101;
		int j = 0B111;
		System.out.println(i); //5
		System.out.println(j); //7
	}
}
-------------------------------------------------------------------------------------
29-Mar-23
------------
By default every integral literal is of type int only but we can specify explicitly as long type by suffixing with l (small l) OR L (Capital L).

According to industry standard L is more preferable because l (small l) looks like 1(digit 1).

There is no direct way to specify byte and short literals explicitly. If we assign any integral literal to byte variable and if the value is within the range (-128 to 127) then it is automatically treated as byte literals.

If we assign integral literals to short and if the value is within the range (-32768 to 32767) then automatically it is treated as short literals.
-----------------------------------------------------------------------------------
/* By default every integral literal is of type int only*/
public class Test4
{
public static void main(String[] args)
 {
		byte b = 128;  
		System.out.println(b);

		short s = 32768; 
		System.out.println(s);      
		
 }
}

Note :- In the above program we will get error i.e incompatible type
------------------------------------------------------------------------------------
//Assigning smaller data type value to bigger data type
public class Test5
{
public static void main(String[] args)
	{
   	    byte b = 125;
		short s = b;    
		System.out.println(s);
	}
}
-------------------------------------------------------------------------------------
//Converting bigger type to smaller type
public class Test6
{
public static void main(String[] args)
	{
		short s = 127;
		byte b = (byte)s; //Converting short data type into byte
		System.out.println(b);
	}
}

-------------------------------------------------------------------------------------
public class Test7
 {
 public static void main(String[] args)
 {
		byte x = (byte)127L; 
		System.out.println("x value  = "+x);

		long l = 29L;
		System.out.println("l value  = "+l);

        int y = (int)18L; 
		System.out.println("y value  = "+y);
 
  }
 }   
 -------------------------------------------------------------------------------------
 To get the complete information of a class like methods name, variables name and so on we can use the following command in the command prompt

javap java.lang.Integer   (javap -> java profiler)
---------------------------------------------------------------------------------------
Is java pure Object-Oriented language ?
----------------------------------------------
No, Java is not a pure Object-Oriented language. In fact any language which accepts the primary data type like int, float, char is not a pure object oriented language hence java is also not a pure object oriented language.

If we remove all 8 primitive data types from java then Java will become pure object oriented language.

In java we have a concept called Wrapper classes through which we can convert the primary data types into corrosponding Wrapper Object.

Primary data types                    Corrosponding Wrapper Object
byte				-		Byte
short				-		Short
int				-		Integer
long				-		Long
float				-		Float
double			-		Double
char				-		Character
boolean			-		Boolean

All these wrapper classes are available in java.lang package.
-----------------------------------------------------------------------------------
//For adding two numbers
class Test8 
{
	public static void main(String[] args) 
	{
		Integer x = 24;  
		Integer y = 24;
		Integer z = x + y;
		System.out.println("The sum is :"+z);		
	}
}
--------------------------------------------------------------------------------------
How to know the minimum and maximum value as well as size of integral literal data types:
------------------------------------------------------------------------------------
Thses classes (Wrapper classe) are providing the static and final variables through which we can find out the minimum, maximum value as well as size of the data types

Ex:- I want to find out the range and size of Byte class

Byte.MIN_VALUE = -128

Byte.MAX_VALUE = 127

Byte.SIZE = 8 (in bits format)

Here MIN_VALUE, MAX_VALUE and SIZE these are static and final variables available in these classes(Byte, Short, Integer and Long).

-----------------------------------------------------------------------------------
 //Program to find out the range and size of Integeral Data type
 public class Test9 
{
	public static void main(String[] args) 
	{
		System.out.println("\n Byte range:");
		System.out.println(" min: " + Byte.MIN_VALUE);
		System.out.println(" max: " + Byte.MAX_VALUE);
		System.out.println(" size :"+Byte.SIZE);
 
		System.out.println("\n Short range:");
		System.out.println(" min: " + Short.MIN_VALUE);
		System.out.println(" max: " + Short.MAX_VALUE);
		System.out.println(" size :"+Short.SIZE);

		System.out.println("\n Integer range:");
		System.out.println(" min: " + Integer.MIN_VALUE);
		System.out.println(" max: " + Integer.MAX_VALUE);
		System.out.println(" size :"+Integer.SIZE);

		System.out.println("\n Long range:");
		System.out.println(" min: " + Long.MIN_VALUE);
		System.out.println(" max: " + Long.MAX_VALUE);
		System.out.println(" size :"+Long.SIZE);
		
	}
}
-------------------------------------------------------------------------------------
class Test10 
{
	public static void main(String[] args) 
	{
	    long mobile = 9812345678L;
	    System.out.print("Mobile NUmber is :"+mobile);
	}
}
--------------------------------------------------------------------------------------
class Test11 
{
	public static void main(String[] args) 
	{
		final int x = 15;
		byte b = x;
		System.out.println(b);
	}
}

------------------------------------------------------------------------------------------
public class Test12 
{
      public static void main(String[] argv) 
      {
           System.out.println(Integer.toBinaryString(65));
           System.out.println(Integer.toOctalString(15));
           System.out.println(Integer.toHexString(2781));
      }
}

Note :- In the above program toBinaryString(int x), toOctalString(int x) and toHexString(int x), will convert our decimal value to binary, octal and hexadecimal respectively.

All these methods return type String
-----------------------------------------------------------------------------------------
Floating point Literals :
---------------------------
1) The literals which contains decimal point or fraction are called Floating Point Literal.

Ex:- 23.89; //Floating Point Literal

2) In floating point literals we have 2 data types 
		a) float(32 bits)
		b) double (64 bites)

3) By default every floating point literal is of type double so the following expression will generate a compilation error.
   
      float f = 23.90; //error

      So now we can have 3 solutions 

      float f1 = 23.90f;

      float f2 = 23.90F;

      float f3 = (float) 23.90;

 
 4) As we know by default every floating point literal is of type double but still we have two flavors given by the java compiler to represent double value explicitly just to enhance the readibility of the code.

		a) double d1 = 1.1d;
		b) double d2 = 1.1D;


5) While working with Integral literal we had four flavors i.e decimal,  
    octal, hexadecimal and binary.
    But while working with floating point literal only decimal form is allowed.

6) Any integral literal we can assign on floating point literal but floating point literal we can't assign on integral literal. 


7) We can represent floating point literal in exponent form.
 
     Ex:-   double d1 = 15e2; (15 X 10 to the power 2)
    
-----------------------------------------------------------------------------------
public class Test 
{
	public static void main(String[] args) 
	{
		float f = 2.0; //error
		System.out.println(f);				
	}
}
-----------------------------------------------------------------------------------------
public class Test1 
{
	public static void main(String[] args) 
	{
		//float a = 1.0; 
		float b = 15.29F;
		float c = 15.25f;
		float d = (float) 15.25;
		System.out.println(b +" : "+c+" : " +d);
       
	}
}
-----------------------------------------------------------------------------------------
public class Test2 
{
	public static void main(String[] args) 
	{
		double d = 15.15;
		double e = 15.15d;
		double f = 15.15D;
		System.out.println(d+" : "+e+" : "+f);
	}
}
-----------------------------------------------------------------------------------------
class Test3 
{
	public static void main(String[] args) 
	{
		  double x = 0129.89;  

		 double y = 0167;

		 double z = 0187; //Error [digit 8 is out of range of octal]

		System.out.println(x+","+y+","+z);
	}
}
----------------------------------------------------------------------------------------
class Test4 
{
	public static void main(String[] args) 
	{
		double x = 0X29;  

		double y = 0X9.15; //error [FPL has only one form i.e decimal]
		
		System.out.println(x+","+y);
	}
}
-----------------------------------------------------------------------------------------
class Test5 
{
	public static void main(String[] args) 
	{
		double d1 = 15e-2;
		System.out.println("d1 value is :"+d1);		

		double d2 = 15e2;
		System.out.println("d2 value is :"+d2);		
	}
}
----------------------------------------------------------------------------------------
class Test6 
{
	public static void main(String[] args) 
	{
	
		double a = 0791; //error

		double b = 0791.0; 

		double c = 0777;  

		double d = 0Xdead;  
		
		double e = 0Xdead.0; //error
	}
}
----------------------------------------------------------------------------------------
class Test7 
{
	public static void main(String[] args) 
	{
	   double a = 1.5e3;
	   float b = 1.5e3; //error
	   float c = 1.5e3F; 	   
	   double d = 10; 	   
	   int e = 10.0; //error
	   long f = 10D; //error
	   int g = 10F; //error
	}
}
--------------------------------------------------------------------------------------
//Range and size of floating point literal 
class Test8 
{
	public static void main(String[] args)    
	{
		System.out.println("\n Float range:");
		System.out.println(" min: " + Float.MIN_VALUE);
		System.out.println(" max: " + Float.MAX_VALUE); 
		System.out.println(" size :"+Float.SIZE);

		System.out.println("\n Double range:");
		System.out.println(" min: " + Double.MIN_VALUE);
		System.out.println(" max: " + Double.MAX_VALUE);
		System.out.println(" size :"+Double.SIZE);
	}
} 
----------------------------------------------------------------------------------------
31-Mar-23
------------
Character Literal :
---------------------
Character Literal :
-------------------
1) It is also known as char literal.

2) In char literal we have one data type i.e char data type which accepts 
    2 bytes of memory.

3) There are multiple ways to represent char literal as shown below

    a) Single character enclosed with single quotes.

        Ex:- char c = 'a';
 
    b) We can assign integral literal to char data type to represent UNICODE values.
    The older languages like C and C++ support ASCII Value whose range is 0-255 only;
    The Java language supports UNICODE values where the range is 0- 65535.

    c) Char literals we can also assign to integral data types.


    d) Char literals we can also represent in UNICODE format where it must contain 4 digit hexadecimal number. 

    The format is '\uXXXX'   [\u0000  to  \uffff]  

    Note :- XXXX is hexadecimal number

     e) A charcter starts with \ (Back slash) is called as escape sequence. Every Escape sequence is also char literal. Java supports the following escape sequences.
     In java we have 8 escape sequences
		a) \n		-> Inserting a new line
		b) \t		-> For providing tab space
		c) \r		-> carriage return(move the cursor to the first line)
		d) \b		-> Inserting a Backspace
		e) \f		->(Form feed) Inserts a form feed (For moving to next page)
		f) \'		-> single quotes
		g) \"		-> Double quotes   
		h) \\		-> Back slace
-------------------------------------------------------------------------------------------
class Test1 
{
	public static void main(String[] args) 
	{
		char ch1 = 'a';
		System.out.println("ch1 value is :"+ch1); 

		char ch2 = 97;   
		System.out.println("ch2 value is :"+ch2); 

		
	}
}
-------------------------------------------------------------------------------------------
class Test2 
{
	public static void main(String[] args) 
	{
		int ch = 'A';
		System.out.println("ch value is :"+ch);
	}
}
------------------------------------------------------------------------------------------
//The UNICODE value for ? character is 63
class Test3 
{
	public static void main(String[] args) 
	{
		char ch = 63;  //?
		System.out.println("ch value is :"+ch); 
	}
}
----------------------------------------------------------------------------------------
class Test4 
{
	public static void main(String[] args) 
	{
		char ch1 = 65100;
        System.out.println("ch1 value is :"+ch1); 

		char ch2 = 0Xadd;  
		System.out.println("ch2 value is :"+ch2); 
	}
}
Note :- Here we will get the output as ? because the equivalent language translator for these particular characters are not available in my laptop.
-----------------------------------------------------------------------------------------
//Addition of two character in the form of Integer
class Test5
{
public static void main(String txt[ ])
  {
	int x = 'A'; 
    int y = 'B';
    System.out.println(x+y);
	System.out.println('A' + 'A'); //130
		
   } 
} 
------------------------------------------------------------------------------------------
//Range of UNICODE Value (65535)
class Test6 
{
	public static void main(String[] args) 
	{
		char ch1 = 65535; 
		System.out.println("ch value is :"+ch1);

		char ch2 = 65536; //error
		System.out.println("ch value is :"+ch2);
	}
}
-------------------------------------------------------------------------------------------
//WAP in java to describe unicode representation of char in hexadecimal format
class Test7 
{
	public static void main(String[] args) 
	{
		char ch1 = '\u0001'; 
		System.out.println(ch1);

		char ch2 = '\uffff';  
		System.out.println(ch2);

		char ch3 = '\u0041'; 
        System.out.println(ch3);  

		char ch4 = '\u0061';
		System.out.println(ch4); 
	}
}


Note :- '\ufffg' ; //Invalid g is out of Range
-------------------------------------------------------------------------------------------
class Test8 
{
	public static void main(String[] args) 
	{
		char c1 = 'A';
		char c2 = 65;
		char c3 = '\u0041';

		System.out.println("c1 = "+c1+", c2 ="+c2+", c3 ="+c3);
	}
}
------------------------------------------------------------------------------------------
class Test9 
{
	public static void main(String[] args) 
	{
		int x = 'A';
		int y = '\u0041';
		System.out.println("x = "+x+" y ="+y);
	}
}
-------------------------------------------------------------------------------------------
//Every escape sequence is char literal
class Test10 
{
	public static void main(String [] args) 
	{
		char ch ='\n';
		System.out.println(ch);
	}
}
-----------------------------------------------------------------------------------------
public class Test11  
{
	public static void main(String[] args) 
	{
		System.out.println(Character.MIN_VALUE); //white space
		System.out.println(Character.MAX_VALUE); //?
		System.out.println(Character.SIZE); //16 bits
	}
}
-----------------------------------------------------------------------------------------
01-Apr-23
------------
Boolean Literal :
------------------
1) boolean literal contains only one data type i.e boolean data type which accept 1 bit of memory and it has two states i.e true and false.

2) It takes one bit of memory i.e true or false.
   
     Eg:-
     boolean isValid = true;
     boolean isValid = false;

3) Unlike c and c++, In java it is not possible to assign integreal literal to boolean data type.

       boolean b = 0; (Invalid in java but valid in c and c++)
       boolean c = 1; (Invalid in java but valid in c and c++)

4) We can't assign String value to boolean data type.

    boolean d = "true"; //here true is String literal not boolean, not possible
    boolean e = "false";//here false is String literal not boolean, not possible

------------------------------------------------------------------------------------
public class Test1
{
    public static void main(String[] args)
    {
        boolean isValid = true;
        boolean isEmpty = false;
		
        System.out.println(isValid);
        System.out.println(isEmpty);
     }
}
------------------------------------------------------------------------------------------
public class Test2
{
    public static void main(String[] args)
    {
	boolean c = 0; //Error
        boolean d = 1; //Error
        System.out.println(c);
        System.out.println(d);       
    }
}
-------------------------------------------------------------------------------------------
public class Test3 
{
	public static void main(String[] args) 
	{
		boolean x = "true";  
		boolean y = "false";  
		System.out.println(x);
        System.out.println(y); 
	}
}
-------------------------------------------------------------------------------------------
String Literal :-
----------------
A string literal in Java is basically a sequence of characters. These characters can be anything like alphabets, numbers or symbols which are enclosed with double quotes. So we can say String is alpha-numeric collection of character.


How we can create String in Java :-
-----------------------------------
In java String can be created by using 3 ways :-

1) By using String Literal 

   String x = "Ravi";

2) By using new keyword 

   String y = new String("Hyderabad");

3) By using character array

   char z[] = {'H','E','L','L','O'};
------------------------------------------------------------------------------------
//Three Ways to create the String Object
class StringTest1 
{
	public static void main(String[] args) 
	{
		String s1 = "Hello World";       //Literal
		System.out.println(s1);

		String s2 = new String("Ravi"); //Using new Keyword
		System.out.println(s2);

		char s3[] = {'H','E','L','L','O'}; //Character Array 
		System.out.println(s3);

	}
}
-------------------------------------------------------------------------------------------
//String is collection of alpha-numeric character
class StringTest2 
{
	public static void main(String[] args) 
	{
		String x="B-61 Hyderabad";
		System.out.println(x);
		
		String y = "123";
		System.out.println(y);

		String z = "67.90"; 
		System.out.println(z);

		String p = "A";        
		System.out.println(p);
	}
}
-------------------------------------------------------------------------------------------
//IQ
class StringTest3
{
	public static void main(String args[])
	{		
		String s=15+29+"Ravi"+40+40; 
		System.out.println(s);		
	}
}

-------------------------------------------------------------------------------------------
Punctuators :
---------------
It is  also called separators.

It is used to inform the compiler how things are grouped in the code.

()  {}   []   ;   ,   .   @   …    
------------------------------------------------------------------------------------
Operators :
-------------
It is a symbol which describes that how a calculation will be performed on operands.

Types Of Operators :
------------------------
1) Arithmetic Operator (Binary Operator)

2) Unary Operators

3) Assignment Operator

4) Relational Operator

5) Logical Operators

6) Boolean Operators

7) Bitwise Operators

8) Ternary Operator

9) Member Operator( Dot . Operator)

10) new Operator

11) instanceof Operator
-------------------------------------------------------------------------------------
03-Apr-23
-------------
Arithmetic Operator OR Binary Operator :
-----------------------------------------------
It is known as Arithmetic Operator OR Binary Operator because it works with minimum two operands.

Ex:-   +, - , *, / and % (Modula Or Modulus Operator)
------------------------------------------------------------------------------------
//Arithmetic Operator
// Addition operator to join two Strings working as String concatenation optr
class Test1 
{
	public static void main(String[] args) 
	{
		String s1 = "Welcome to";
		String s2 = " Java ";
		String s3 = s1 + s2;
		System.out.println("String after concatenation :"+s3);
		
	}
}
-------------------------------------------------------------------------------------------
How to read the value from the user/keyboard (Accepting the data from client)
-------------------------------------------------------------------------------------------
In order to read the data from the client or keyboard, java software people has provided a predefined class called Scanner available in java.util package.

static variables of System class :
------------------------------------
System is a predefined class which contains 3 static variables.

System.out :- It is used to print normal message on the screen.

System.err :- It is used to print error message on the screen.

System.in :- It is used to take input from the user.(Attaching the keyboard with System resource)


How to create the Object for Scanner class :
--------------------------------------------------
Scanner sc = new Scanner(System.in);  //Taking the input from the user


Scanner class provides various methods :
-----------------------------------------------
String next() :- Used to read a single word.

String  nextLine() :- Used to read complete line or multiple Words.

byte nextByte() :- Used to read byte value

short nextShort() :- Used to read short value

int nextInt() :- Used to read integer value

float nextFloat() :- Used to read float value

double nextDouble() :- Used to read double value

boolean nextBoolean() :- Used to read boolean value.

char next().charAt(0) :- Used to read a character
-------------------------------------------------------------------------------------
//BUFFER PROBLEM
//WAP in java to read your Name
import java.util.*;
public class ReadName 
{
	public static  void main(String[] args) 
	{
      Scanner sc = new Scanner(System.in);
	  System.out.print("Enter Id :");
      int id =  sc.nextInt();   //123 \n

	  System.out.print("Enter your Name :");
	  String name = sc.nextLine(); //\n [Buffer Problem]
      name = sc.nextLine();
	  System.out.println("Your Id is :"+id);
      System.out.println("Your Name is :"+name);
	}
}
-------------------------------------------------------------------------------------------
//How to read the character
import java.util.Scanner;
class IQ 
{
	public static void main(String... args) 
	{
		Scanner sc = new Scanner(System.in);
	    System.out.print("Enter your Gender[M/F]:");
		char gender = sc.next().charAt(0);
		
		System.out.println("Your Gender is :"+gender);
	}
}
-------------------------------------------------------------------------------------------
//WAP to read your name from the keyboard
import java.util.*;
class Test2
{
	public static void main(String [] args)
	{
       Scanner sc = new Scanner(System.in);
	   System.out.print("Please enter your Name :");
	   String name =  sc.next();
	   System.out.println("Your Name is :"+name);
		
	}
}
-------------------------------------------------------------------------------------------
//Arithmetic Operator (+, -, *, / , %)
//Reverse of a 3 digit number
import java.util.*;
class Test3
{
	public static void main(String[] args) 
	{
		System.out.print("Enter a three digit number :");
		Scanner sc = new Scanner(System.in);
        
		int num =  sc.nextInt(); //num = 567

		int rem = num % 10;  //rem = 7
        System.out.print("The Reverse is :"+rem); //The reverse is :765

        num = num /10;    //num = 56
		rem = num % 10;  //rem = 6
        System.out.print(rem);

		num = num/10; //num = 5
		System.out.println(num);
	}
}

------------------------------------------------------------------------------------------
Unary Operator :
--------------------
The operator which works upon single operand is called Unary Operator. In java we have 3 types of unary opertor.

1) Unary minus operator (-)       

2) Increment Operator (++)

3) Decrement Operator (--)
------------------------------------------------------------------------------------------
//*Unary Operators (Acts on only one operand)
//Unary minus Operator
class Test4 
{
	public static void main(String[] args) 
	{
		int x = 15;
		System.out.println(-x); 
		System.out.println(-(-x));
	}
}
------------------------------------------------------------------------------------------
//Unary Operators
//Unary Pre increment Operator
class Test5 
{
	public static void main(String[] args) 
	{
		int x = 15;
		int y = ++x;    //First increment then assignment
		System.out.println(x+":"+y);
	}
}
------------------------------------------------------------------------------------------
//Unary Operators
//Unary Post increment Operator
class Test6 
{
	public static void main(String[] args) 
	{
		int x = 15;
		int y = x++; //First assignment then increment
		System.out.println(x+":"+y);
	}
}
-------------------------------------------------------------------------------------------
//Unary Operators
//Unary Pre increment Operator
class Test7 
{
	public static void main(String[] args) 
	{
		int x = 15;
		int y = ++15;   //Error
		System.out.println(y);
	}
}
------------------------------------------------------------------------------------------
//Unary Operators
//Unary Pre increment Operator
class Test8
{
	public static void main(String[] args) 
	{
		int x = 15;
		int y = ++(++x);  
		System.out.println(y);
	}
}
Note :- The above two programs will generate CE because we can't use unary operator on constants.
------------------------------------------------------------------------------------------
//Unary Operators
//Unary post increment Operator
class Test9
{
	public static void main(String[] args) 
	{
		int x = 15;
		System.out.println(++x + x++); //32
		System.out.println(x);     //x = 17

        System.out.println("..................");
 
		int y = 15;
		System.out.println(++y + ++y); //33
		System.out.println(y);    //17
	}
}
-------------------------------------------------------------------------------------------
//Unary Operators
//Unary post increment Operator
class Test10
{
	public static void main(String[] args) 
	{
		char ch ='A';
		ch++;
		System.out.println(ch); 
	}
}
-------------------------------------------------------------------------------------------
//Unary Operators
//Unary post increment Operator
class Test11
{
	public static void main(String[] args) 
	{
		double d = 15.15;
		d++;
		System.out.println(d);
	}	
}
 
Note :- Increment and decrement operator we can apply with any data type except boolean.
-------------------------------------------------------------------------------------------
04-Apr-23
------------
//Unary Operators
//Unary Pre decrement Operator
class Test12 
{
	public static void main(String[] args) 
	{
		int x = 15;
		int y = --x; //First decrement then assignment
		System.out.println(x+":"+y);
	}
}
-------------------------------------------------------------------------------------------
//Unary Operators
//Unary Post decrement Operator
class Test13
{
	public static void main(String[] args) 
	{
		int x = 15;
		int y = x--;
		System.out.println(x+":"+y); 
	}
}
-------------------------------------------------------------------------------------------
Interview Question 
----------------------
Whenever we work with Arithmetic Operator or Unary minus operator, the minimum data type required is int, So after calculation of expression it is promoted to int type.

//IQ
class Test14
{
	public static void main(String args[])
	{
		byte i = 1;
		byte j = 1;
		byte k = i + j;  //Error
		System.out.println(k);
	}
}
-------------------------------------------------------------------------------------------
class Test15
{
	public static void main(String args[])
	{
		/*byte b = 6;
        b = b + 7;  //error      
		System.out.println(b); */

		byte b = 6;
        b += 7;       //short hand operator  b += 7  is equal to (b = b + 7)
        System.out.println(b); 
	  
	}
}
-------------------------------------------------------------------------------------------
class Test16
{
	 public static void main(String args[])
	{ 
		     byte b = 1;
			 byte b1 = -b; 
             System.out.print(b1);  
	}
}
-------------------------------------------------------------------------------------------
What is a local variable :
----------------------------
If a variable is declared inside a method  body not as a method parameter then it is called Local / Stack/ Temporary / Automatic variable.

Ex:-

public void input()
{
    int y = 12;
}

Here in the above example y is local variable.

Local variable we can't use outside of the function or method.

A local variable must be initialized before use otherwise we wiil get compilation error.

We can't use any access modifier on local variable except final.

Program
---------

public class Test17
{		 
	public static void main(String [] args)
	{
	     int x;
		 System.out.println(x); //error

		 public  int y = 20; //error
		 System.out.println(y);
	}	
}
-------------------------------------------------------------------------------------------
class IQ 
{
	public static void main(String[] args) 
	{
		System.out.println("Main method started");
		m1();
		System.out.println("Main method ended");
	}
	public static void m1()
	{
		System.out.println("m1 method started");
		m2();
		System.out.println("m1 method ended ");
	}
	public static void m2()
	{
		int x = 100;
        System.out.println("Hiii I am m2 method :"+x);
	}
}
NOTE :- THIS PROGRAM CONTAINS DIAGRAM
------------------------------------------------------------------------------------------
//*Program on Assignment Operator
class Test18
{
	public static void main(String args[])
	 { 
        int x = 5, y = 3;  
        System.out.println("x = " + x);
        System.out.println("y = " + y); 
		
        x %= y;          //short hand operator  x = x % y
        System.out.println("x = " + x);     
		}
}
-------------------------------------------------------------------------------------------
Relational Operator :- 
------------------------
These operators are used to compare the values. The return type is boolean. We have total 6 Ralational Operators.

1) >   (Greater than)

2) <   (Less than)

3) >= (Greater than or equal to)

4) <= (Less than or equal to)

5) == (double equal to)

6) != (Not equal to )

------------------------------------------------------------------------------------
//*Program on relational operator(6 Operators)
class Test19  
{
	public static void main(String args[])
	{
      int a = 10;
      int b = 20;
      System.out.println("a == b : " + (a == b) ); //false
      System.out.println("a != b : " + (a != b) );  //true
      System.out.println("a > b : " + (a > b) );   //false
      System.out.println("a < b : " + (a < b) );   //true
      System.out.println("b >= a : " + (b >= a) ); //true
      System.out.println("b <= a : " + (b <= a) ); //false
    }
}
------------------------------------------------------------------------------------------
If condition :
---------------
It is decision making statement. It is used to test a boolean expression. The expression must return boolean type.

//Program to check a number is 0 or +ve or -ve
import java.util.Scanner;
class Test20
{
	public static void main(String args[])
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Please enter a Number :");

		int num = sc.nextInt();
		if(num == 0)
		System.out.println("It is zero");

		else if(num>0)
		System.out.println(num+" is positive");
		else
		System.out.println(num+" is negative");

		sc.close(); //To close Scanner resource
	}
}
-------------------------------------------------------------------------------------------
/*program to calculate telephone bill
For 100 free call rental = 360
For 101 - 250, 1 Rs per call
For 251 - unlimited , 1.2 Rs per call
*/
import java.util.*;
class Test21
{
public static void main(String args[])
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter current Reading :");
		int curr_read = sc.nextInt();

		System.out.print("Enter Previous Reading :");
		int prev_read = sc.nextInt();

		int nc = curr_read - prev_read;	
		System.out.println("Your Number of call for this month is :"+nc);		

		double bill = 0.0;
		if (nc <=100)
		{
			bill = 360;
		}
		else if(nc<=250)
		{
           bill = 360 + (nc-100)*1.0;
		}
        else if(nc >250)
		{
            bill = 360 + 150 + (nc-250)*1.2;
		}
         System.out.println("The bill is :"+bill);
	}
}
------------------------------------------------------------------------------------------
05-Apr-23
------------
Nested if:
---------
If an 'if condition' is placed inside another if condition then it is called Nested if.
In nested if condition, we have one outer if and one inner if condition, the inner if condition will only execute when outer if condition returns true.

if(condition)  //Outer if condition
{
   if(condition) //inner if condition
   {
   }
   else //inner else
   {
   }
}
else //outer else
{
}
------------------------------------------------------------------------------------------
//Nested if
//big among three number
class Test22
{
public static void main(String args[])
	{
		int a =15;
		int b =18;
		int c =29;

		int big=0;   

		if(a>b)  //(Outer if condition)
		{			
			if(a>c)     //Nested If Block (inner if)        
				big=a;
			else
				big=c;
		}
		else    //already confirmed b is greater than a
		{
			if(b>c)   
				big=b;
			else
				big=c;
		}
	System.out.println("The big number is :"+big);
	}
}

Note :- In the above program to find out the biggest number among three number we need to take the help of nested if condition but the code becomes complex, to reduce the length of the code Logical Operator came into the picture.
----------------------------------------------------------------------------------------
Locical Operator :-
--------------------
It is used to combine or join the multiple conditions into a single statement. 
It is also known as short-Circuit logical operator. 
In Java we have 3 logical Operators 

1) &&  (AND Logical Operator)

2) ||  (OR Logical Operator)

3) !   (NOT Logical Operator)

&&   :- All the conditions must be true. if the first expression is false it will
           not check right side expressions.

||    :- Among multiple conditions, at least one condition must be true. if the             first expression is true it will not check right side expressions. 

!      :- It is an inverter, it makes true as a false and false as a true.

Note :- The && and || operator only works with boolean operand so the following code will not compile.

if(5 && 6)
{

}
-------------------------------------------------------------------------------------------
//*Program on Logical Operator (AND, OR, Not Operator)
//Biggest number among 3 numbers

class Test23
{
public static void main(String args[])
	{
		java.util.Scanner sc = new java.util.Scanner(java.lang.System.in);
		System.out.print("Enter the value of a :");
		int a = sc.nextInt();
		System.out.print("Enter the value of b :");
		int b = sc.nextInt();
		System.out.print("Enter the value of c :");
		int c = sc.nextInt();
		
		int big =0;

		if(a>b && a>c)
			big = a;
		else if(b>a && b>c)
			big = b;
		else
			big = c;
		System.out.println("The big number is :"+big);
	}
}

------------------------------------------------------------------------------------------
//OR Operator (At least one condition must be true)
class Test24
{
public static void main(String args[])
	{		
		int a=10;
		int b=5;
		int c=20;
		System.out.println(a>b || a<c); //true
		System.out.println(b>c || a>c); //false
	}
}
------------------------------------------------------------------------------------------
// !Operator (not Operator works like an Inverter)
class Test25
{
   public static void main(String args[])
	{	
		System.out.println(!true);
	}
}
-------------------------------------------------------------------------------------------
Boolean Operators :
-----------------------
Boolean Operators work with boolean values that is true and false. It is used to perform boolean logic upon two boolean expressions.
It is also known as non short circuit. There are two non short circuit logical operators.

&   boolean AND operator  (All  condions must be true but if first expression                                         is false still it will check all right side expression)

|    boolean OR operator    (At least one condition must be true but if the first
                                      condition is true still it will check all right side expression )
------------------------------------------------------------------------------------

//* Boolean Operators
/*
& boolean AND operator 
| boolean OR operator

*/
//Works with boolean values

class Test26 
{
	public static void main(String[] args) 
	{
	      int z = 5;
		  if(++z > 5 || ++z > 6)   //Logical OR
		  {
			  z++;
		  }
		  System.out.println(z);//7

          System.out.println("................");

		  z = 5;
		  if(++z > 5 | ++z > 6)   //Boolean OR
		  {
			  z++;
		  }
		  System.out.println(z); //8
    }
}

------------------------------------------------------------------------------------------
class Test27 
{
	public static void main(String[] args) 
	{
		int z = 5;
		if(++z > 6 & ++z> 6)
		{
			z++;			
		}
		System.out.println(z);
	}
}
-------------------------------------------------------------------
Bitwise Operator :-
---------------------
In order to work with binary bits java software people has provided Bitwise operator. It also contains 3 operators

& (Bitwise AND) :- Returns true if both the inputs are true.

|  (Bitwise OR) :- Returns false if both the inputs are false
 
^ (Bitwise X-OR) :- Returns true if both the arguments are opposite to each other.
-----------------------------------------------------------------------------------------
//Bitwise Operator
class Test28 
{
	public static void main(String[] args) 
	{
        System.out.println(true & true); //true
		System.out.println(false | true); //true
		System.out.println(false ^ true); //true
      

		System.out.println(6 & 7);  //6
		System.out.println(6 | 7);  //7
		System.out.println(6 ^ 7); //1
	}
}

--------------------------------------------------------------------
06-Apr-23
----------
Bitwise Complement Operator(~)
------------------------------

Bitwise Complement Operator does not work with boolean . It is represent by ~ (tilde) symbol.
//Bitwise Complement Operator
public class Test29
{
    public static void main(String args[]) 
	{
		//System.out.println(~ true); 
		System.out.println(~ 4); //-5
		System.out.println(~ -4); // 3   
    }
}
--------------------------------------------------------------------Ternary Operator OR Conditional Operator :
--------------------------------------------------
The ternary operator (? :) consists of three operands. It is used to evaluate boolean expressions. The operator decides which value will be assigned to the variable.It is used to reduced the size of if-else condition. 
//Ternary Operator OR Conditional Operator

public class Test30
{
    public static void main(String args[]) 
	{
		int a = 50;
		int b = 59;
		int max = 0;

		max=(a>b)?a:b;
		System.out.println("Max number is :"+max);

    }
}
--------------------------------------------------------------------
class IQ 
{
	public static void main(String[] args) 
	{
	  char a = 'A';
      int i = 1;
	  boolean x = false;
      System.out.print(true ? a : 0);
      System.out.print(false ? x : a);
      System.out.println();
	}	
}
--------------------------------------------------------------------

Member access Operator Or Dot Operator :
--------------------------------------------------
It is used to access the member of the class so whenever we want to invoke the member of the class (fields + methods) then we should use dot(.) operator.

We can directly call any static method and static variable from the main method with the help of class name , here object is not required as shown in the program below.

//*Member Access Operator(.) ,To call the member of a class
public class Test31
{	
	static int x = 100;
	
	 static void access()
	{
		System.out.println("I am a static Method...");
		System.out.println("x value is :"+x);
	}
	public static void main(String [] args)
	{
		System.out.println(Test31.x);
        Test31.access();
	}
}

------------------------------------------------------------------
class Welcome
{
	static String msg = "Hyderabad";
}

class IQ 
{
	public static void main(String[] args) 
	{		
	  System.out.println(Welcome.msg.length()); //S.o.print()
	}

}

Note :- From the above program it is clear that we can call the static variable and static method directly with the help of class name using . (Dot) operator.
--------------------------------------------------------------------
/* new Operator

This Operator is used to create Object. If the member of the class (field + method) is static, object is not required. we can directly call with the help of class name.
On the other hand if the member of the class (variables + method) is not declared as static then it is called non-static member Or instance member , to call the non-static member object is required.

To create the object new keyword or new operator is required.
--------------------------------------------------------------------
//new operator
public class Test32
{
	int x = 100; //instance variable (non-static Field)
	public static void main(String [] args)
	 {	
	   Test32 t = new Test32(); //Without object we can't access x
	   System.out.println("x value is :"+t.x);
			
	 }	 
}
--------------------------------------------------------------------
The conclusion is if our member of the class is static then object is not required, on the other hand if the member of the class is 
non-static then object is required.
-------------------------------------------------------------------
instanceof operator :-

1)This Operator will return true/false

2) It is used to check a reference variable is holding the particular/corrosponding type of Object or not.   

3) It is also a keyword.

4) In between the object reference and class name , we must have some kind of relation (assignment relation) otherwise we will get compilation error.
-------------------------------------------------------------------
//* instanceof operator 
class Test33 
{
	public static void main(String[] args) 
	{
		String s = new String("India");
		if(s instanceof Object)
			System.out.println("s is the reference of String");

		Test33 t = new Test33();
		if(t instanceof Test33)
			System.out.println("t is the reference of Test33");

		Integer i = 45;
		if(i instanceof Number)
			System.out.println("i is the reference of Integer");
	 
		}
}
-------------------------------------------------------------------
Types of variable in Java :
----------------------------
07-Apr-23
---------
In java based on the data type, we have 2 types of variables

1) Primitive type
2) Non-primitive type

  Again, Based on the declaration position it is divided into 4 types 
  a) instance variable
  b) static variable
  c) parameter variable 
  d) local variable  [block level variable]
--------------------------------------------------------------------
Control statement in java :
---------------------------
Control Statements in java :
------------------------------
What is drawback of if condition :-
---------------------------------------
The major drawback with if condition is, it checks the condition again and again so It increases the burdon over CPU so we introduced switch-case statement to reduce the overhead of the CPU.

switch case :-
----------------
In switch case dpending upon the parameter the appropriate case would be executed otherwise default would be executed.

In this approch we need not to check each and every case, if the appropriate case is available then directly it would be executed.

break keyword is optional here but we can use as per requirement. It will move the control outside of the body of the switch.
-------------------------------------------------------------------

public class SwitchDemo 
{
	public static void main(String[] args) 
	{		
		char colour = 'b';
		switch(colour)
		{
		case 'r' : System.out.println("Red") ; break;
		case 'g' : System.out.println("Green");break;
		case 'b' : System.out.println("Blue"); break;
		case 'w' : System.out.println("White"); break;
		default : System.out.println("No colour");
		}
		System.out.println("Completed") ;
	}
}
--------------------------------------------------------------------
import java.util.*;
public class SwitchDemo1
{
public static void main(String args[]) 
  {	
		System.out.println("\t\t**Main Menu**\n");	
		System.out.println("\t\t**100 Police**\n");
		System.out.println("\t\t**101 Fire**\n");
		System.out.println("\t\t**102 Ambulance**\n");
		System.out.println("\t\t**139 Railway**\n");
		System.out.println("\t\t**181 Women's Helpline**\n");		

		System.out.print("Enter your choice :");
		Scanner sc = new Scanner(System.in);
		int choice = sc.nextInt();		
		switch(choice)
		{
		case 100:
		System.out.println("Police Services");
		break;
		case 101:
		System.out.println("Fire Services");
		break;
		case 102:
		System.out.println("Ambulance Services");
		break;
		case 139:
		System.out.println("Railway Enquiry");
		break;
		case 181:
		System.out.println("Women's Helpline ");
		break;
		default:
		System.out.println("Your choice is wrong");		
		}
    }
}

-------------------------------------------------------------------
Note :- In the switch statement we can't pass long, float and double value. Strings are allowed from JDK 1.7 version. enums are allowed from java 5 version.

public class Test2 
{
	public static void main(String[] args) 
	{
		double val = 1;
		 switch(val)       //Error, can't pass long, float and double
		{
			 case 1:
				 System.out.println("Hello");
			 break;
		} 
	}
}
--------------------------------------------------------------------
Loop in java :
---------------
A loop is nothing but repeatation of statement that means by using loop we can repeat a statement so many number of times based on specified condition.

In java we have 4 kinds of loop 

1) do-while loop
2) while loop 
3) for loop
4) for-each loop 

do-while loop :-
------------------
It will repeat the statment but in this loop first of all statement will be printed and then only the condition will verify so it is also called exit control loop.

do
{
   statement;
}
while();
-------------------------------------------------------------------
public class Test3
{	
	public static void main(String [] args)
	{
		 
		do
		{
		    int x = 1;  	
			System.out.println("x value is :"+x);
			x++;
		}
		while (x<=10);//Error becoz block level local variable
	}
}
--------------------------------------------------------------------
//Program on do-while loop to print 1-10
public class  Test4
{	
	
	public static void main(String[] args) 
	{    
		int x = 1; //Local variable
		do
		{			
			System.out.print(x+"\n");   
			x++;			
		}
		while (x<=10);
	}	
}
--------------------------------------------------------------------
08-Apr-23
----------
here basic drawback with do-while loop is, first of all it will print the value and then only it will check the condition.

To avoid this problem we introduced while loop 

while loop :- 
-------------
In while loop first of all we will verify the condition, if the condition is true then only the control will enter inside the body of the loop hence it is known as entry control loop.

while(condition)
{
   statement;
}
-------------------------------------------------------------------
//program on while loop
public class Test5 
{
	public static void main(String[] args) 
	{
		int x = -1;

		while(x>=-10)
		{
			System.out.println(x);
			x--;
		}
	}
}
--------------------------------------------------------------------
//Program on for loop
public class Test6 
{
	public static void main(String[] args) 
	{
		for(int i=1; i<=10; i++)
		{
		   System.out.println("i value is :"+i);
		}
		
	}
}
-------------------------------------------------------------------
//Program to accept user input to initialize our loop
import java.util.Scanner;
public class Test7
{
	public static void main(String [] args)
	{
		System.out.print("Please enter a number from where you want to start the loop : ");
		Scanner sc = new Scanner(System.in);
		int i = sc.nextInt();
        do
        {
			System.out.print(i+"\t");      // \t for tab space	
			i = i + 1;
        }
        while (i<=100);
	}
}
--------------------------------------------------------------------
//WAP in java to print all even number from 1 -100

public class Test8
{
	public static void main(String [] args )
	{
	    for(int i=2; i<=100; i=i+2)
		{
			System.out.print(i+"\t");
		}
		
	}
}
---------------------------------------------------------------------
//WAP to print sum of first 100 natural number (1+2+3+4+.......100)
public class Test9 
{
	public static void main(String[] args) 
	{
		int sum = 0;    

		for(int i=1; i<=100; i++)
		{
			 sum = sum + i;		
		}	 

		System.out.println("The sum is :"+ sum);	
	}
}
-------------------------------------------------------------------
for-each loop :
----------------
It is introduced from JDK 1.5 onwards. 

It is also known as enhanced for loop.

It is used to retrieve the values from the collection.
-------------------------------------------------------------------
Fetching the data from an array by using ordinary for loop 
-------------------------------------------------------------------
class OrdinaryLoop
{
	public static void main(String [] args)
	{
		int [] x = {89,67,45,15,9};
		System.out.println("Array length is :"+x.length);

        for(int i=0; i<x.length; i++)
		{
			System.out.println(x[i]);
		}
		
	}
}
--------------------------------------------------------------------

//Program on for each loop
import java.util.*;
public class Test10
{
	public static void main(String [] args)
	{
       int []x = {90,67,45,15,11,9};

	   Arrays.sort(x);

	   for(int y : x)
		{
		   System.out.println(y);
		}        
		
	}
}

Note :
-------
1) In the above program each value of x is assigning to y variable.

2) x is an array variable but y is an ordinary variable

3) in java.util package there is a predefined class called Arrays which contains a static method sort(), by using this static method we can sort an array in ascending order. sort() method takes array as a parameter.
-------------------------------------------------------------------
//Program on Object Array
public class Test 
{
	public static void main(String[] args) 
	{		
		Object [] x = {"nit", 'A', 45.90, 45};

		for(Object y : x)
		{
			System.out.println(y);
		}
	}
}
--------------------------------------------------------------------
Nested loop :
---------------
If we placed a loop inside another loop then it is called Nested loop.

Example :
-----------
 n = 5;

for (int i =0; i<=n; i++) //Outer loop
 {
    statement1;
    for(int j =1; j<=n; j++) //inner loop
     {
         statement2;
     }
}

i=0 (j=1)     

i=0 (j=2)

i=0 (j=3)

i=0 (j=4)

i=0 (j=5)

Note :- With each value of Outer loop the entire inner loop will be rotated.
-------------------------------------------------------------------
//Nested loop
public class  Test11
{
	public static void main(String[] args) 
	{
		int weeks = 4;
		int days = 7;    

		for (int i = 1; i <= weeks; ++i) 
		{
		  System.out.println("Week: " + i);
		  for (int j = 1; j <= days; ++j) 
			 {
				  System.out.println("  Day: " + j);
			 }
		 }
	}
}

-------------------------------------------------------------------
//break
class Test12 
{
	public static void main(String[] args) 
	{
		for(int i=1; i<=10; i++)
		{				
			if(i==5)
				break;
			System.out.println("i value is :"+i);
			
		}
	}
}
-------------------------------------------------------------------
//continue (Will skip the current execution sequence)
class Test13 
{
	public static void main(String[] args) 
	{
		for(int i=1; i<=10; i++)
		{			
			if(i==5)
				continue;
			System.out.println("i value is :"+i);
		}
	}
}
--------------------------------------------------------------------
10-Apr-23
---------
Method return type and its Parameter :
--------------------------------------

What is BLC class?
-------------------
Ans :- The class in java which does not contain main method and it is meant for writing the logic only is known as BLC (Business Logic class).

What is ELC class?
Ans :- The class which contains main method is known as ELC (Executable Logic class)
 It is known as executable logic class because the execution of the program always starts from main method.
--------------------------------------------------------------------
Working with methods and return types :
----------------------------------------------
1) From static method main we can directly call another static method but that another static method must be present in the same class. If the method is not declared as static then we will get compilation error.
--------------------------------------------------------------------
//A static method can be directly call within the same class

package com.ravi.pack1;

class Test1
{
	public static void main (String[] arg)
	{
	    square(5); 	    
	}

	public static void square(int x)
	{  
	  System.out.println(x*x);
	}
}
--------------------------------------------------------------------
The following program exaplains how to call a static method available in another class.

This package contains two files :
----------------------------------
1) FindSquare.java
-------------------
package com.ravi.pack2;

//BLC(Business Logic class)
public class FindSquare
{
  public static void square(int x)
  {  
    System.out.println("Square of "+x+" is :"+(x*x));
  }
}

2) Test2.java
-------------
//A static method available in another class can be call with class name

package com.ravi.pack2;

//ELC(Executable Logic class)
public class Test2
{
	public static void main (String[] args)
	{
	    FindSquare.square(9);
	    	   	   
	}
}

--------------------------------------------------------------------
This package contains two files :
----------------------------------
 
FindSquare.java
----------------
//A static method returning integer value 
package com.ravi.pack3;

public class FindSquare
{
	  public static int square(int x)
	  {  
	    return x*x;
	  }
}

Test3.java
-----------

package com.ravi.pack3;

public class Test3
{
	public static void main (String[] arg)
	{				
		for (int i = 1; i <= 5; i++) 
		{
		      int result = FindSquare.square(i);
		      System.out.println("Square of " + i + " is: " + result);
		}
	}
}


--------------------------------------------------------------------
This package also contains 2 classes :
--------------------------------------
Calculate.java
---------------
/*Program to find out the square and cube of the number by following criteria
 * 
a) If number is 0 or Negative it should return -1
b) If number is even It should return square of the number
c) If number is odd It should return cube of the number
*/

package com.ravi.pack4;

//BLC
public class Calculate 
{
   public static int squareAndCube(int num)  
   {
	   if(num == 0 || num < 0)
	   {
		   return -1;
	   }
	   else if(num %2 == 0)
	   {
		   return (num*num);
	   }
	   else
	   {
		   return (num*num*num);
	   }
   }
}

Test4.java
-----------
package com.ravi.pack4;
//ELC
public class Test4 {

	public static void main(String[] args) 
	{
		int val = Calculate.squareAndCube(-9);
		System.out.println("Value is :"+val);
		
		val = Calculate.squareAndCube(4);
		System.out.println("Value is :"+val);
		
		val = Calculate.squareAndCube(5);
		System.out.println("Value is :"+val);
	}
}

--------------------------------------------------------------------
This package contains 2 files :
--------------------------------
Rectangle.java
---------------
package com.ravi.pack5;

public class Rectangle 
{
  public static double getArea(double height, double width)
  {
	  double area = height*width;
	  return area;
  }
}


Test5.java
-----------
package com.ravi.pack5;

public class Test5 
{
	public static void main(String[] args)
	{
		double areaOfRectangle = Rectangle.getArea(2.3, 3.6);
		System.out.println("Area of Rectangle is :"+areaOfRectangle);
	}
}
--------------------------------------------------------------------
This package also contains 2 programs

EvenOrOdd.java
---------------
package com.ravi.pack6;

//BLC
public class EvenOrOdd 
{
	public static boolean isEven(int num)
    {
        return (num % 2 == 0);
    }
}

Test6.java
-----------
package com.ravi.pack6;

//ELC
public class Test6 
{
	public static void main(String[] args) 
	{
	 boolean val =   EvenOrOdd.isEven(4);	
	 System.out.println("4 is even :"+val);
	 
	 val =   EvenOrOdd.isEven(5);	
	 System.out.println("5 is even :"+val);
	}

}
--------------------------------------------------------------------
This package contains two files 

Circle.java
-----------
//Area of Circle
package com.ravi.pack7;

public class Circle 
{
  public static String getArea(double rad)
  {
	  if(rad ==0 || rad<0)
	  {
		  return ""+0;
	  }
	  else
	  {
	  final double PI = 3.14;  //final keyword to declare constant variable
	  
	  double area = PI*rad*rad;
	  
	  return  ""+area;
	  }
	  
  }
}

Test7.java
----------
package com.ravi.pack7;

import java.text.DecimalFormat;

public class Test7 
{
	public static void main(String[] args) 
	{
		String area = Circle.getArea(8.8);		
		double areaOfCircle = Double.parseDouble(area);
		
		DecimalFormat df = new DecimalFormat("00.00");
		System.out.println("Area is :"+df.format(areaOfCircle)); 	
	}
}

Note :- There is predefined class called DecimalFormat availale in 
        java.text package, it will provide Decmal format as per our
	requirement.
	It contains a predefined method format() which takes double as a parameter.

        DecimalFormat df = new DecimalFormat("00.00");

        00.00 is the format.
--------------------------------------------------------------------
11-Apr-23
---------
Important Points 
-----------------
a) If should always take our Java classes in a separate file that means in a single Java file we should not take multiple classes.

b) We should always write our java classes using BLC (The class which does not contains main method) and ELC (The class which   contains main method) technique.
--------------------------------------------------------------------
The program which takes String as a return type.
//Program to print the Student Details

This package contains 2 files :

1) Student.java
----------------
package com.ravi.pack8;

//BLC
public class Student 
{
   public static String getStudentDetails(int roll, String name, double fees)
   {
	  //return "[Roll is "+roll+", Name is "+name+", Fees is "+fees+"]";
	  
	   return "{ Roll is :"+roll+" Name is :"+name+" Fees is :"+fees+" }";
   }
}


2) Test8.java
--------------
package com.ravi.pack8;
//ELC
public class Test8 {

	public static void main(String[] args)
	{
		String details = Student.getStudentDetails(101, "Ravi", 14000.90);
		System.out.println("Student Details are :"+details);
	}

}
--------------------------------------------------------------------
The program which print the table of the given number.
//Program to print the Student Details

This package contains 2 files :

1) Table.java
----------------
package com.ravi.pack9;

//BLC
public class Table 
{
  public static void printTable(int num) 
  {
	  for(int i=1; i<=10; i++)
	  {		 
		  System.out.println(num +" X "+i+ " = "+(num*i));
	  }
  }
}


2) Test9.java
--------------
package com.ravi.pack9;

import java.util.Scanner;

//ELC
public class Test9 
{
	public static void main(String[] args) 
	{		
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter the number whose table you want to print : ");
		int no = sc.nextInt();
		Table.printTable(no);
		
	}

}
--------------------------------------------------------------------
12-Apr-23
----------
Object Oriented Programming(OOPs) :
-----------------------------------------
An Object is a physical entity which is existing in the real world.

Writing Java program on those Real World Object is known as Object Oriented Programming.

OOPs is a methdology to develop the programs using class and object. 

In object oriented programming we concentrate on Objects. 

Every Object contains properties(Data members or Variables) and behavior (Member function or Method).

Advantages of OOPs
----------------------
We have 3 advantages

1) Modularity

2) Reusability

3) Flexibility

Features of OOPs
--------------------
We have 6 features 

1) Class 
2) Object
3) Abstraction
4) Encapsulation
5) Inheritance
6) Polymorphism

class :-
--------
A class is a model/blueprint/template/prototype for creating an object.

A class is userdefined data type which contains data members and member function.

Example :
---------
public classs Student
{
   Student Data (Student Variables or Student properties)
                            +
  Student behavior (Function / Method of the student)
}

A class is a logical representation of object.

*A class is a component which is used to define object properties and object behavior.

Object :
---------
An object is a physical entity.

Anything which is existing in the real world is called as object.

Example :
-----------
Mouse, Laptop, key, pen and so on.

An object has 3 characteristics :
-----------------------------------
1) Identification (Name of the Object)

2) Properties (Variables OR data members)

3) Behavior (Function Or Method.)
-------------------------------------------------------------------


//Object oriented programming on Pen Object
package com.ravi.oop;

public class Pen 
{
	String name; //instance variable
	String color;//instance variable
	String type;//instance variable
	
	public void usedToWrite()  //Behaviour of Pen Object
	{
		System.out.println("I am :"+name);
		System.out.println("My colour is :"+color);
		System.out.println("My Type is :"+type);
	}
	
	public static void main(String[] args) 
	{
		Pen cello = new Pen();
		cello.name = "cello pen"; //Initializing the properties
		cello.color = "black";    //Initializing the properties
		cello.type = "Ball pen";  //Initializing the properties
		
		cello.usedToWrite(); //calling the behaviour
		
	}

}
-------------------------------------------------------------------
//Object oriented programming on Dog Object

package com.ravi.oop;

public class Dog 
{
    double height;
    String color;
    
    public void displayDogData()
    {
    	System.out.println("My color is :"+color);
    	System.out.println("My height is :"+height);
    }
    
    public void bark()
    {
    	System.out.println("A "+color+ " color dog with "+height+ " height is barking");
    }
    
	public static void main(String[] args) 
	{
		Dog tommy = new Dog();
		tommy.height = 3.6;
		tommy.color = "black";
		
		tommy.bark();
		tommy.displayDogData();

	}

}
--------------------------------------------------------------------
//Object oriented programming on Student Object

package com.ravi.oop;

public class Student
{
	int rollNumber; //instance variable
	String name;    //instance variable
	double height;  //instance variable
	
	public void talk()
	{
		System.out.println("Hi My Name is :"+name);
		System.out.println("My roll number is :"+rollNumber);
		System.out.println("And my height is :"+height);
	}

	public static void main(String[] args) 
	{
		Student raj = new Student();
		raj.rollNumber = 111; //Initializing the properties
		raj.name = "Raj rao"; //Initializing the properties
		raj.height = 5.6;     //Initializing the properties
		
		raj.talk(); //behaviour

		System.out.println(".....................");
		Student ram = new Student();
		ram.rollNumber = 222;  //Initializing the properties
		ram.name = "Ram kumar";//Initializing the properties
		ram.height = 4.9;      //Initializing the properties
		ram.talk();            //behaviour
	}

}
--------------------------------------------------------------------
13-Apr-23
---------
//Default constructor added by the compiler
--------------------------------------------------
In java whenever we write a class and if we don't write any type of constructor then automatically compiler will add default constructor to the class.

class Test
{
    //Here in this class we don't have constructor
}

javac Test.java    (At the time of compilation automatically compiler will add default constructor)

class Test
{
    Test() //default constructor added by the compiler
    {
    }
}
-------------------------------------------------------------------------------------
Why compiler adds default constructor to our class :
------------------------------------------------------------
If the compiler does not add default constructor to our class then object creation is not possible in java. At the time of object creation by using new keyword we depend upon the constructor.

The main purpose of defualt constructor(added by the compiler) to initialize the instance variables of the class with some default values.
The default values are:
byte	- 0
short - 0
int	- 0
long	- 0
float	- 0.0
double - 0.0
char -    (Space)
boolean - false
String - null
Object - null
-------------------------------------------------------------------
package com.ravi.oop;

public class Customer 
{
	int customerId;
	String customerName;
	
	public void displayCustomerData()
	{
		System.out.println("My Customer id : "+customerId);
		System.out.println("My Customer name : "+customerName);
	}

	public static void main(String[] args) 
	{
		Customer c1 = new Customer(); //default constructor invoked
		c1.displayCustomerData();
	}

}
--------------------------------------------------------------------
The above program will generate 0 and null as a default value but these values are not useful for user so user will take one new method (acceptData) to provide user defined value according to the choice of user.

-------------------------------------------------------------------

How to provide our userdefined values for the instance variable :
-------------------------------------------------------------------------
The default values provided by compiler are not useful for the user, hence user will take a separate method (acceptData()) to re-initialize the instance variable value so the user will get its own userdefined values.

-------------------------------------------------------------------
package com.ravi.oop;

import java.util.Scanner;

public class Customer 
{
	int customerId;
	String customerName;
	
	public void acceptData()
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter Customer Id :");
		customerId = sc.nextInt();
		System.out.print("Enter Customer Name :");
		customerName = sc.nextLine();
		customerName = sc.nextLine();
	}
	
	public void displayCustomerData()
	{
		System.out.println("My Customer id : "+customerId);
		System.out.println("My Customer name : "+customerName);
	}

	public static void main(String[] args) 
	{
		Customer c1 = new Customer(); //default constructor invoked
		c1.displayCustomerData();
		
		c1.acceptData(); //Here we are re-initializing our properties
		c1.displayCustomerData();
	}
	
	

}
--------------------------------------------------------------------
14-Apr-23
---------
How to write BLC(Business Logic class ) and ELC (Executable Logic class)
----------------------------------------------------------------------------------
In java if we write everything in a single class then it is not an Object Oriented approach, even though we are creating object and calling the members of the class.

In this approach the REUSABILITY OF THE CLASSES is not possible.
-------------------------------------------------------------------
This entire program contains two package and 4 java files 

com.blc.elc package classes :
-----------------------------
This package contains 3 files 

Player.java
------------
package com.ravi.blc_elc;
//BLC
public class Player 
{
	int playerNumber; //instance variable
	String playerName;//instance variable
	
	public void acceptPlayerData(int pno, String pname) //parameter variable
	{
		playerNumber = pno;
		playerName = pname;
	}
	public void displayPlayerData()
	{
		System.out.println("Player Number is :"+playerNumber);
		System.out.println("Player Name is :"+playerName);
	}
}

PlayerDemo.java
----------------
package com.ravi.blc_elc;
//ELC
public class PlayerDemo 
{
	public static void main(String[] args) 
	{
		Player rohit = new Player(); 
		rohit.acceptPlayerData(45, "Rohit Sharma");
		rohit.displayPlayerData();
		

	}

}

Kohli.java
----------
package com.ravi.blc_elc;

public class Kohli {

	public static void main(String[] args) 
	{
		Player virat = new Player();
		virat.acceptPlayerData(18, "Virat Kohli");
		virat.displayPlayerData();

	}

}


Now to reuse Player class we have created a separate package (com.oop.hospiltal)

This com.oop.hospiltal package contains 1 java class
Rishab.java
------------
package com.oop.hospital;

import com.ravi.blc_elc.Player;

public class Rishab {

	public static void main(String[] args)
	{
		Player pant = new Player(); //Using this class from another package
		pant.acceptPlayerData(17, "Rishab Pant");
		pant.displayPlayerData();

	}

}
--------------------------------------------------------------------
instance variable :
--------------------
A non-static variable which is declared inside the class but outside of a method is called instance variable.

The life of an instance variable starts at the time of object creation.

[Instance variable is having strong association with object , we can't think about instance variable without object]

instance variables are always the part of the object.

As far as as its accessibility is concerned, instance variable we can use anywhere with object reference.


Parameter variable :
-----------------------
If a variable is declared inside the method parameter (not inside the method body) then the variables are called as parameter variables.

As far as its scope is concerned, parameters variables we can access within the same method body but not outside of the method.
-------------------------------------------------------------------

this keyword :
----------------
Whenever our instance variable name and parameter variable name (method body variable) both are same then at the time of variable initialization our runtime environment gets confused that which one is an instance variable which one is parameter variable.

To avoid this problem we should use this keyword. this keyword always refers to the current object and we know that instance variables are the part of object.

this keyword we can't use from a static context.

The following program contains two files 
-----------------------------------------
Product.java
-------------
package com.oop.this_keyword;

public class Product 
{
   String productName;
   double productPrice;   
   public void setProdutData(String productName, double productPrice)
   {
	   this.productName = productName;
	   this.productPrice = productPrice;
	   
   }   
   public void getProductData()
   {
	   System.out.println("Product Name is :"+productName);
	   System.out.println("Product Price is :"+productPrice);
   }
}


ProductDemo.java
----------------
package com.oop.this_keyword;

public class ProductDemo {

	public static void main(String[] args) 
	{		
		Product mobile = new Product();
		
		mobile.setProdutData("Apple", 70000.89);
		mobile.getProductData();
		
	}

}
--------------------------------------------------------------------
17-Apr-23
---------
Role of instance variable while creating the Object :
-----------------------------------------------------------
Whenever we create an object in java, a separate copy of all the instance variables will be created with each and every object as shown in the program below.

The following program contains one file 
---------------------------------------
Demo.java
----------
package com.ravi.instance_copy;

public class Demo 
{
    int x = 10;
    
	public static void main(String[] args)
	{
        Demo d1 = new Demo();		
        Demo d2 = new Demo();
        
        ++d1.x;   
        
        --d2.x;        
        
        System.out.println(d1.x);//11
        System.out.println(d2.x);//9

	}

}
--------------------------------------------------------------------
Role of static variable at the time of creating the object :
------------------------------------------------------------
In static variable only one copy will be created and this single copy will be sharable by all the objects as shown in the program below.

The following program contains one file 
---------------------------------------
Test.java
----------
package com.ravi.static_copy;

public class Test 
{
    static int x = 10;
	public static void main(String[] args) 
	{
		Test t1 = new Test();
		Test t2 = new Test();
        
		--t1.x;   --t2.x;
		
		System.out.println(t1.x); //8
		System.out.println(t2.x); //8
	}

}

Note :-

instance variable -> multiple copies with each object

static variable   -> single copy for all the objects
-------------------------------------------------------------------
When we should declare a variable as an instance variable and when we should go with static variable?
----------------------------------

Whenever the value of the variable is different with respect to objects then we should declare the variable as instance variable.

On the other hand if the value of the variable is common for all the objects then we should declare static variable, if we declare this variable(static variable) as an instance variable then multiple copies will be created for holding same value so westage of memory.

Note :- static variable will save the memory so the overall execution of the program will become faster.

The following program contains two file
-----------------------------------------
Student.java
-------------
package com.ravi.declare_instance_static;
//BLC
public class Student 
{
    int rollNumber;
    String studentName;
    String studentAddress;
    static String instituteName = "Naresh Technology";
    static String courseName = "Java";
    
    public void setStudentData(int rollNumber, String studentName, String studentAddress)
    {
    	this.rollNumber = rollNumber;
    	this.studentName = studentName;
    	this.studentAddress = studentAddress;
    }
  
    public void getStudentData()
    {
    	System.out.println("Roll Number is :"+rollNumber);
    	System.out.println("Student Name is :"+studentName);
    	System.out.println("Student Address is :"+studentAddress);
    	System.out.println("Institute Name is  :"+instituteName);
    	System.out.println("Course Name is  :"+courseName);
    	System.out.println("..............................");
    	
    	
    }
    
}

StaticAndInstance.java
-----------------------
package com.ravi.declare_instance_static;

public class StaticAndInstance {

	public static void main(String[] args) 
	{
		Student ram = new Student(); //According to the diagram
		ram.setStudentData(111, "Ram Kumar", "S R Nagar");
		
		Student raj = new Student(); //According to the diagram
		raj.setStudentData(222, "Raj Kumar", "Ameerpet");
		
		Student virat = new Student(); //According to the diagram
		virat.setStudentData(333, "Virat Kohli", "Delhi");
		
		Student dhoni = new Student(); //According to the diagram
		dhoni.setStudentData(007, "M.S Dhoni", "Ranchi");
		
		ram.getStudentData();  raj.getStudentData(); virat.getStudentData();
		dhoni.getStudentData();

	}

}
--------------------------------------------------------------------
18-Apr-23
---------
How to print object properties value (instance variable value) :
----------------------------------------------------------------------
If we want to print object properties value then we need to override a method called toString() available in java.lang.Object class.

Whenever we override this toString() method in our class then we need not to write any display() method to display our data(instance variable).

In order to call toString() method we need to print the object reference(name of the object) using System.out.println()

Example :
----------
Manager m = new Manager();
System.out.println(m); //It will call toString() method
-------------------------------------------------------------------
This package contains two programs 

Manager.java
-------------
package com.ravi.print_properties;

public class Manager 
{
   int managerId;
   double managerSalary;
   char managerGrade;
  
   
   public void setManagerData(int managerId, double managerSalary)
   {
	   this.managerId = managerId;
	   this.managerSalary = managerSalary;
	   this.setManagerGrade();
   }
   
   public void setManagerGrade()
   {
	   if(managerSalary >= 80000)
	   {
		   managerGrade = 'A';
	   }
	   else if (managerSalary >= 60000)
	   {
		   managerGrade = 'B';
	   }
	   else
	   {
		   managerGrade = 'C';
	   }   
   }

@Override
public String toString() {
	return "Manager [managerId=" + managerId + ", managerSalary=" + managerSalary + ", managerGrade=" + managerGrade
			+ "]";
}  
  
}

ManagerDemo.java
----------------
package com.ravi.print_properties;

import java.util.Scanner;

public class ManagerDemo {

	public static void main(String[] args)
	{
		 Manager m = new Manager();
		 Scanner sc = new Scanner(System.in);
		 System.out.print("Enter Manager Id :");
		 int id = sc.nextInt();
		 System.out.print("Enter Manager Salary :");
		 double salary = sc.nextDouble();
		 m.setManagerData(id, salary);
		 System.out.println(m);
		 
		  
		 
	}

}
--------------------------------------------------------------------
Data hiding :
---------------
Data hiding means our data (variables) must be hidden from outer world that means no one can access our data directly from outside of the class.

To achieve this concept we should declare our class properties or data members as private.

We should not provide access of data directly but we can access our data through methods. Once we are accessing our data through method then we can PERFORM VALIDATION ON DATA WHICH ARE COMING FROM OUTER WORLD.

Note :- Data members must ne declared as private where as member functions (Method) must be declared as public.

The following program contains two files :
-----------------------------------------------
Customer.java
-------------
package com.ravi.data_hiding;
//BLC
public class Customer 
{
    private double balance = 10000;  //Data hiding
   
   public void deposit(int amount)
   {
	   if(amount <= 0 ) 
	   {
		System.out.println("You are a hacker");   
	   }
	   else
	   {
	   balance = balance + amount;
	   System.out.println("Balance After Deposit :"+balance);
	   }
   }
   
   public void withdraw(int amount)
   {
	   balance = balance - amount;
	   System.out.println("Balance After Withdraw :"+balance);
   }
}


BankApplication.java
---------------------
package com.ravi.data_hiding;
//ELC
public class BankApplication 
{
	public static void main(String[] args)
	{
		Customer raj = new Customer();
		raj.deposit(5000);
		raj.withdraw(2000);
	}

}
--------------------------------------------------------------------
Abstraction :
--------------
Showing the essential details without showing the background details (non-essential) is called Abstraction.

In real world a user always interacts with the functionality of the product but not the data or internal details so for a user method/function is essential details where as data is non-essential details.

So being a developer we should always hide the data from the user(by declaring them private) where as on the other hand we should always decalre member function/Method as public so a user can easily interact with the product.

Example :
-----------
class Fan
{
   private int coil;
   private int wings;

   public void start()
   {
   }

   public void stop()
   {
   }
}

Note :- Here User will interact with the functionality of the fan i.e start and stop but will not interact with data(coil, wings) directly.

Note :- In java we can achieve abstarction by using abstract class and interface concept.

abstract class provide partial abstraction(0-100%) where as interface provides 100% abstraction.
-------------------------------------------------------------------
19-Apr-23
----------
Encapsulation :- 
----------------
Binding  the data member with its associated function/method in a single unit is called encapsulation.

In other words we can say "Grouping the related things together is called Encapsulation".

In encapsulation data must be tightly coupled with associated function.

It provides us security because we can't access the data directly, data must be accessible via methods.

We can achieve encapsulation in our program by using following

a) Declare all the data members as private (Tightly encapsulated class)
b) Define getters and setters for each instance variable to perform read and write operation.

Note :
-----
If we declare all the instance variables with private access modifier then it is called tightly encapsulated class

On the other hand if some variables are declared with private access modifier and other variables are not declared with private access modifier then it is called loosly encapsulated class



This program contains two files
-------------------------------

Student.java
-------------
package com.ravi.setter_getter;

public class Student 
{
  private int rollNumber;

	public int getRollNumber() //getter
	{
		return rollNumber;
	}

	public void setRollNumber(int rollNumber) //setter
	{
		this.rollNumber = rollNumber;
	}
  
  
}

StudentDemo.java
-----------------
package com.ravi.setter_getter;

public class StudentDemo 
{
	public static void main(String[] args) 
	{
      Student s1 = new Student();
      s1.setRollNumber(111);
      System.out.println(s1.getRollNumber());    

	}
}
--------------------------------------------------------------------
Constructor :
-------------

1) What is the advantage of writing constructor in our program :
----------------------------------------------------------------

If we don't write a constructor in our program then variable initialization and variable re-initialization both are done in two different lines.

If we write constructor in our program then variable initialization and variable re-initialization both are done in the same line i.e at the time of Object creation.

(As shown in the diagram)
-------------------------------------------------------------------
20-Apr-23
---------
Defination of constructor :
-----------------------------
It is used to construct the object that is why it is called Constructor.

If the name of the class and name of the method both are same then it is called constructor or in other words constructor is a special method whose name is same as class name.

The main purpose of constructor is to initialize the instance variable of the object.

Every java class has a constructor either explicitly written by the user or implicitly added by the compiler.

A constructor never containing any return type including void also, if we try to put the return type then it will become normal method.

A constructor is automatically called and executed at the time of creating object.

A constructor is called and executed once per object that means if we create an object then automatically the constructor will be called and executed, again if we create another object for second time then again the constructor will be called and executed.

In java we have 3 types of constructors :
----------------------------------------------
1) Default constructor

2) No Argument constructor OR Parameterless constructor

3) Parameterized Constructor
-------------------------------------------------------------------------------------
03-Dec-22
-------------
1) Default constructor :-
    ------------------------
    If a constructor is added by compiler in our java class then it is called default constructor.

    The main purpose of default constructor to initialize the instance variables with default values.

    Example:-

    public class Test
    {
         int x,y;
         public Test() //Default constructor added by the compiler
	  {
	      x = 0;   y = 0;
	  }
    }

    If our class is declared with public access modifier then the constructor added by the compiler will also contain public access modifier.
------------------------------------------------------------------------------------
 2) No argument constructor :- 
    ----------------------------------
     The constructor written by the user in the class without any parameter then it is called No argument constructor or parameter less constructor or zero argument constructor.

     By using no argument constructor all the objects will be initialized with same values so it is not recommended approach because we will not be able to customized each individual object with different value, to avoid this parameterized constructor came into picture.

     Ex:-
     public class Test
     {
         int x, y;

	 public Test() //No argument constructor, written by the user
	 {
	    x = 100;
	    y = 200;
	 }
     }
-------------------------------------------------------------------
This package contains two programs 
----------------------------------
Person.java
------------
package com.ravi.no_arg;
//BLC
public class Person 
{
   private int personId;
   private String personName;
   
   public Person() //No Argument Constructor
   {
	   personId = 111;
	   personName="Virat";
   }

@Override
public String toString() {
	return "Person [personId=" + personId + ", personName=" + personName + "]";
}
   
   
}

NoArgumentConstructor.java
--------------------------
package com.ravi.no_arg;
//ELC
public class NoArgumentConstructor {

	public static void main(String[] args) 
	{
	   Person p1 = new Person();
	   System.out.println(p1);
	   
	   Person p2 = new Person();
	   System.out.println(p2);
     }

}
------------------------------------------------------------------
Parameterized constructor :
--------------------------------
If one or more argument is passed to the constructor then it is called parameterized constructor.

If we want initialize our objects with different values(unlike no argument constructor) then we should choose parameterized constructor.

public class Test
{
     private int x,y;

     public Test(int x, int y)
      {
          this.x = x;
	  this.y = y;
      }
}
--------------------------------------------------------------------
This package contains two programs 
----------------------------------
Dog.java
------------
package com.ravi.parameterized;

public class Dog 
{
  private String dogName;
  private double dogHeight;
  private String dogColor;
  
	public Dog(String dogName, double dogHeight, String dogColor)
	{
		super();
		this.dogName = dogName;
		this.dogHeight = dogHeight;
		this.dogColor = dogColor;
	}

	@Override
	public String toString()
	{
		return "Dog [dogName=" + dogName + ", dogHeight=" + dogHeight + ", dogColor=" + dogColor + "]";
	}
  
	
  
}

ParameterizedConstructor.java
-----------------------------
package com.ravi.parameterized;

public class ParameterizedConstructor {

	public static void main(String[] args) 
	{
		Dog d1 = new Dog("ABC", 3.4, "Black");
		System.out.println(d1);
		
		Dog d2 = new Dog("DEF", 5.4, "Grey");
		System.out.println(d2);
		
	}

}
-------------------------------------------------------------------
Program on HAS-A relation :
---------------------------
This program contains 3 files
-----------------------------
College.java
------------
package com.ravi.has_a_reln;
//BLC
public class College 
{
  private String collgeName;
  private String collegeLocation;
  
	public College(String collgeName, String collegeLocation)
	{
		super();
		this.collgeName = collgeName;
		this.collegeLocation = collegeLocation;
	}

	@Override
	public String toString() {
		return "College [collgeName=" + collgeName + ", collegeLocation=" + collegeLocation + "]";
	}
  
	
  
}

Student.java
-------------
package com.ravi.has_a_reln;
//BLC
public class Student
{
  private int studentId;
  private String studentName;
  private College clg ; //HAS-A relation [Student HAS-A college]
  
	public Student(int studentId, String studentName, College clg) //clg = new College("NIT","HYD")
	{
		super();
		this.studentId = studentId;
		this.studentName = studentName;
		this.clg = clg;
	}

	@Override
	public String toString() {
		return "Student [studentId=" + studentId + ", studentName=" + studentName + ", clg=" + clg + "]";
	}
  
  
}

Main.java
---------
package com.ravi.has_a_reln;
//ELC
public class Main {

	public static void main(String[] args) 
	{
		//College c1 = new College("NIT", "Hyd");
		
		Student s1 = new Student(111,"Virat Kohli",new College("NIT","HYD"));
		System.out.println(s1);

	}

}
--------------------------------------------------------------------
21-Apr-23
----------
Another Program on HAS-A Relation :
-----------------------------------
This package contains 3 files :

Company.java
------------
package com.ravi.has_a_relation;

public class Company 
{
   String companyName;
   String companyLocation;
  
	public Company(String companyName, String companyLocation) 
	{
		super();
		this.companyName = companyName;
		this.companyLocation = companyLocation;
	}

	@Override
	public String toString() {
		return "Company [companyName=" + companyName + ", companyLocation=" + companyLocation + "]";
	}
  
	
  
}


Employee.java
-------------
package com.ravi.has_a_relation;

public class Employee 
{
  private int employeeNumber;
  private String employeeName;
  private double employeeSalary;
  private Company company; //HAS-A relation
  
	public Employee(int employeeNumber, String employeeName, double employeeSalary, Company company)   //company = comp
	{
		super();
		this.employeeNumber = employeeNumber;
		this.employeeName = employeeName;
		this.employeeSalary = employeeSalary;
		this.company = company;
		
	}

	@Override
	public String toString() {
		return "Employee [employeeNumber=" + employeeNumber + ", employeeName=" + employeeName + ", employeeSalary="
				+ employeeSalary + ", company=" + company + "]";
	}
  
  
}


Main.java
----------
package com.ravi.has_a_relation;

public class Main {

	public static void main(String[] args) 
	{
		Company comp = new Company("TCS", "Bangalore");
		
		Employee e1 = new Employee(111, "Dhoni", 50000, comp);
		System.out.println(e1);		
		
		Employee e2 = new Employee(112, "Virat", 50000, comp);
		System.out.println(e2);
		
		

	}

}
-------------------------------------------------------------------
Passing an Object reference to the Constructor :
------------------------------------------------
If we pass an Object reference to the Constructor then it is known as Copy Constructor [Parameterized Constructor, there is no copy constructor in java]

Example :
---------
class Order
{
}

class Customer
{
  public Customer(Order order) //Passing object reference to the 
  {                                constructor
				  
  }
}

The advantage of passing an object reference to the constructor is to COPY THE CONTENT OF ONE OBJECT INTO ANOTHER OBJECT.
-------------------------------------------------------------------
The following program contains 3 files :
----------------------------------------
1) Employee.java
-----------------
package com.ravi.object_ref;

public class Employee 
{
    private int employeeNumber;
    private String employeeName;
  
	public Employee(int employeeNumber, String employeeName) 
	{
		super();
		this.employeeNumber = employeeNumber;
		this.employeeName = employeeName;
	}

	@Override
	public String toString() {
		return "Employee [employeeNumber=" + employeeNumber + ", employeeName=" + employeeName + "]";
	}

	public int getEmployeeNumber() {
		return employeeNumber;
	}

	public String getEmployeeName() {
		return employeeName;
	}
	
	
  
  
}

2) Manager.java
---------------
package com.ravi.object_ref;

public class Manager 
{
  private int managerId;
  private String managerName;
  
  public Manager(Employee emp) // emp = e1
  {
	 managerId = emp.getEmployeeNumber();
	 managerName = emp.getEmployeeName();
  }

@Override
public String toString() {
	return "Manager [managerId=" + managerId + ", managerName=" + managerName + "]";
}
  
  
}

3) Main.java
-------------
package com.ravi.object_ref;

public class Main {

	public static void main(String[] args) 
	{
		Employee e1 = new Employee(111, "Dhoni");
		
		Manager m1 = new Manager(e1);
		System.out.println(m1);
	}

}
--------------------------------------------------------------------
The following program contains 2 files :
----------------------------------------
Player.java
------------
package com.ravi.object_ref1;

public class Player 
{
  private String name1, name2;
  
  public Player(String name1, String name2)
  {
	  this.name1 = name1;
	  this.name2 = name2;
  }
  
  public Player(Player p)  // p = p1
  {
	this.name1 = p.name2;
	this.name2 = p.name1;
  }

@Override
public String toString() {
	return "Player [name1=" + name1 + ", name2=" + name2 + "]";
}
  
  
}

Main.java
---------
package com.ravi.object_ref1;

public class Main {

	public static void main(String[] args) 
	{
		Player p1 = new Player("Sachin", "Dhoni");
		
		Player p2 = new Player(p1);
		System.out.println(p1);
		System.out.println(p2);

	}

}
-------------------------------------------------------------------
24-Apr-23
----------
This package contains 3 programs

Baby.java
----------
package com.ravi.milk;

public class Baby
{
  private String babyName;
  private double babyAge;
  private String milkType;
  
   public Baby(String babyName, double babyAge, Milk milk) 
	{
		super();
		this.babyName = babyName;
		this.babyAge = babyAge;
		
		if(milk.getMilkPrice() <=60)
    	{
    		milkType = "Tonned Milk";
    	}
    	else
    	{
    		milkType = "Full Cream";
    	}
	}
	
    

	@Override
	public String toString() {
		return "Baby [babyName=" + babyName + ", babyAge=" + babyAge + ", milkType=" + milkType + "]";
	}   
  
}

Milk.java
----------
package com.ravi.milk;

public class Milk 
{
  private String milkBrand;
  private double milkPrice;
  
  
  
	public String getMilkBrand() {
	return milkBrand;
}

public double getMilkPrice() {
	return milkPrice;
}

	public Milk(String milkBrand, double milkPrice) 
	{
		super();
		this.milkBrand = milkBrand;
		this.milkPrice = milkPrice;
	}
	
	@Override
	public String toString() {
		return "Milk [milkBrand=" + milkBrand + ", milkPrice=" + milkPrice + "]";
	}
  
	
  
}

Main.java
---------
package com.ravi.milk;

public class Main {

	public static void main(String[] args) 
	{
		Milk vijaya = new Milk("Vijaya", 52);
		System.out.println(vijaya);
		
		
		
		Baby b1 = new Baby("Aradhya", 3,vijaya);
		System.out.println(b1);

	}

}
--------------------------------------------------------------------
How many ways to initialize our object properties 
--------------------------------------------------------
There are 5 ways to initialize our object properties (instance variables)

1) AT THE TIME OF DECLARTION

    class Exapmle
    {
        int x = 10;
	int y = 20;
   }
   
   It is not a recommended approach because if we create multiple objects then all the objects will contain same value.

 2) BY USING OBJECT REFERENCE

     class Example
     {
         int x;
	 int y;

	 Example e1 = new Example(); e1.x=10;  e1.y=20;
	 Example e2 = new Example(); e2.x=30;  e2.y=40;
	 Example e3 = new Example(); e3.x=50;  e3.y=60;
     }

       It is also not a recommended approach because here the length of the code will increase as well as the understanability of the code will decrease.


 3) BY USING METHODS

	class Example
	{
            int x;
	    int y;
	    public void input()
	    {
                   x = 100;
		   y = 200'
	    }
	  }

	  Note :- All the objects will initialize with same value

          class Example
	{
            int x;
	    int y;
	    public void input(int x, int y)
	    {
                   this.x = x;
		   this.y = y;
	    }
	  }

           All the objects will initialize with different values

	   It this approach variable initialization and variable re-initialization both will be done in different places so to avoid this constructors are introduced.


	   4) BY USING CONSTRUCTORS(PARAMETERIZED CONSTRUCTOR)

	       This is the best approach to initialize our instance variable but if we want to modify the instance variable then setters are better approach because if we modify the variable value with constructor, every time object is created, memory will be allocated.

	    5) BY USING SETTER METHOD

	    If we want to modify our instance variable then setter is best approach.
------------------------------------------------------------------------------------
Setter and getter method :
-------------------------------
The main purpose of setter method to initialize the instance variable of the class and we can easily modify the instance variable value with single object.

Where as on the other hand the main purpose of getter method to get the value of instance variable if they are declared as private.

Note :- We should use setter and getter when our instance variables are declared as private and we want to perform read and write operation.

We can also generate setter and getter with the eclispe IDE by source -> Generate setter and getter -> select all -> generate
-------------------------------------------------------------------
Return type of the method :
-------------------------------
public void  m1()
{

}

-> void, all 8 primitive data types, class name and interface name and so on we can take as a return type of the method.

Eaxmple :
-----------
public Test m2()
{
      return new Test();
}
--------------------------------------------------------------------
The following package contains two files 
----------------------------------------
Customer.java
--------------
package com.ravi.return_type;

import java.util.Date;
import java.util.Scanner;

public class Customer 
{
	 int customerId;
	private String customerName;
	private double customerBill;
	private Date date; //HAS-A relation

	public Customer(int customerId, String customerName, double customerBill, Date date)
	{
		super();
		this.customerId = customerId;
		this.customerName = customerName;
		this.customerBill = customerBill;
		this.date = date;
	}
	
	public static Customer getCustomerObject()
	{
	    Scanner sc = new Scanner(System.in);
	    System.out.print("Enter Customer Id :");
	    int id = sc.nextInt();
	    System.out.print("Enter Customer Name :");
	    String name = sc.nextLine();
	    name = sc.nextLine();
	    System.out.print("Enter Customer Bill :");
	    double bill = sc.nextDouble();
	    Date d = new Date();
		return new Customer(id,name,bill,d);
	}

	@Override
	public String toString() {
		return "Customer [customerId=" + customerId + ", customerName=" + customerName + ", customerBill="
				+ customerBill + ", date=" + date + "]";
	}

	

}
 
Main.jav
---------
package com.ravi.return_type;

import java.util.Scanner;

public class Main {

	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.println("How many Object you want :");
		int obj = sc.nextInt();
		for(int i=1; i<=obj; i++)
		{
	Customer  c1 = Customer.getCustomerObject();
			   System.out.println(c1);
	
		}
	}

}
--------------------------------------------------------------------
25-Apr-23
----------
Lab Program:
---------------
A class called Customer is given to you. 
The task is to find the Applicable Credit card Type and create CardType object based on the Credit Points of a customer.

Define the following for the class.

Attributes : 
	customerName : String,private
	creditPoints: int, private

Constructor :
	parameterizedConstructor: for both cusotmerName & creditPoints in that order.

Methods :
	Name of the method : getCreditPoints
	Return Type : int
	Modifier   : public 
	Task : This method must return creditPoints
	
	Name of the method : toString, Override it, 
	Return type : String 
	Task :  return only customerName from this.

Create another class called CardType. Define the following for the class

Attributes :
	customer : Customer, private
	cardType : String, private
Constructor :
	parameterizedConstructor: for customer and cardType attributes in that order

Methods :
	Name of the method : toString  Override this.  
	Return type : String
	Modifier : public
	Task :  Return the string in the following format.
		The Customer 'Rajeev' Is Eligible For 'Gold' Card.


Create One more class by name CardsOnOffer and define the following for the class.

Method : 
	Name Of the method : getOfferedCard 
	Return type : CardType
	Modifiers: public,static
	Arguments: Customer object
	Task : 	Create and return a CardType object after logically finding cardType from creditPoints as per the below rules.
		creditPoints	    cardType
		100  - 500		-   Silver
		501  - 1000	-   Gold
		1001 >		-   Platinum
		< 100		-   EMI
		
Creat  an ELC class which contains Main method to test the working of the above.
--------------------------------------------------------------------
This package contains 4 files 

Customer.java
-------------
package com.ravi.lab_program;

public class Customer 
{
   private String customerName;
   private int creditPoints;
   
	public Customer(String customerName, int creditPoints) 
	{
		super();
		this.customerName = customerName;
		this.creditPoints = creditPoints;
	}
    public int getCreditPoints()
    {
    	return this.creditPoints;
    }
	@Override
	public String toString() {
		return this.customerName;
	}
   
    
}

CardType.java
-------------
package com.ravi.lab_program;

public class CardType 
{
  private Customer customer;
  private String cardType;
	public CardType(Customer customer, String cardType) 
	{
		super();
		this.customer = customer;
		this.cardType = cardType;
	}
	@Override
	public String toString() 
	{
		//The Customer 'Rajeev' Is Eligible For 'Gold' Card.
		return "The Customer '"+customer+"' Is Eligible For '"+this.cardType+"' Card";
	}
  
	
  
}

CardsOnOffer.java
------------------
package com.ravi.lab_program;

public class CardsOnOffer 
{
  public static CardType getOfferedCard(Customer object)  //object = c1
  {
	 int creditPoint = object.getCreditPoints();
	 if(creditPoint >=100 && creditPoint <=500)
	 {
		 return new CardType(object, "Silver");
	 }
	 else if(creditPoint >500 && creditPoint <=1000)
	 {
		 return new CardType(object, "Gold");
	 }
	 else if(creditPoint > 1000)
	 {
		 return new CardType(object, "Platinum");
	 }
	 else
	 {
		 return new CardType(object, "EMI");
	 }
  }
}


Main.java
---------
package com.ravi.lab_program;

import java.util.Scanner;

public class Main {

	public static void main(String[] args) 
	{
	  Scanner sc = new Scanner(System.in);
	  System.out.print("Enter the Name of the Customer :");
	  String name = sc.nextLine();
	  System.out.print("Enter the credit points of the Customer :");
	  int creditPoint = sc.nextInt();
	  
	  Customer c1 = new Customer(name, creditPoint);
	  CardType offeredCard = CardsOnOffer.getOfferedCard(c1);
	  System.out.println(offeredCard);
	  
	  
	}

}
--------------------------------------------------------------------
instance block in java
------------------------
It is a new feature introduced in java. The main purpose of instance block to initialize the instance variable of the class before the constructor, that is the reason it is also known as instance initializer.

An instance block we can write inside the class even inside the method or constructor.

An instance block will be automatically placed in the second line of constructor at the time of compilation.

An instance block will be executed automatically at the time of creating the object BEFORE THE CONSTRUCTOR BODY EXECUTION.

Instance block will execute once per object that means whenever we create an object, instance block will be executed.

If we have multiple instance blocks in a class then they would be executed in the same order as they were written in the class(order wise)
-------------------------------------------------------------------
The following package contains two programs 
-------------------------------------------
Demo.java
----------
package com.ravi.instance_block;
//BLC
public class Demo 
{
   public Demo()
   { 
	  
	   System.out.println("No Argument Constructor....");
   }
  
   //Instance Block [Compiler will placed in the 2nd line of constructor]
   {
	   System.out.println("Instance Block....");
   }  
}

InstanceDemo.java
-----------------
package com.ravi.instance_block;
//ELC
public class InstanceDemo 
{
	public static void main(String[] args) 
	{
		Demo d1 = new Demo();
		
		Demo d2 = new Demo();

	}

}
-------------------------------------------------------------------
The following package contains two programs 
-------------------------------------------
Test.java
----------
package com.ravi.instance_block;

public class Test 
{
   private int x,y;
   public Test()
   {
	   System.out.println(x);
	   System.out.println(y);
	   x = 300;
	   y = 400;
	   System.out.println(x);
	   System.out.println(y);
   }
   
   {
	   x = 100;
	   y = 200;
   }
   
   
}

TestInstance.java
------------------
package com.ravi.instance_block;

public class TestInstance {

	public static void main(String[] args)
	{
		 new Test(); //Nameless Object OR Anonymous Object

	}

}
--------------------------------------------------------------------
The following package contains two programs 
-------------------------------------------
Foo.java
----------
package com.ravi.instance_block;

public class Foo 
{
	int x;
   public Foo()
   {
	   System.out.println("No Argument Constrcutor...");
	   System.out.println("x value is :"+x);
   }
   
   {
	   x = 100;
   }
   
   {
	   x = 200;
   }
   
   {
	  x = 300; 
   }
   
   {
	   x = 900;
   }
}

FooInstance.java
-----------------
package com.ravi.instance_block;

public class FooInstance {

	public static void main(String[] args)
	{
		new Foo();

	}

}
--------------------------------------------------------------------
26-Apr-23
----------
Relationship between the classes :
----------------------------------------
In java, in between the classes we have two types of relation

1) IS-A Relation

2) HAS-A Relation

IS-A relation we can achieve by Inheritance Concept.

HAS-A relation we can achieve by Association Concept.
------------------------------------------------------------------------------------
Inheritance (IS-A Relation) :
--------------------------------
Deriving a new class (child class) from existing class (parent class) in such a way that the new class will acquire all the properties and features (except private) from the existing class is called inheritance.

It is one of the most imporatnt feature of OOPs which provides "CODE REUSABILITY".

Using inheritance mechanism the relationship between the  classes is parent and child. According to C++ the parent class is called Base class and the child class is called Derived class, According to Java the parent class is called super class and the child class is called sub class.

In java we provide inheritance using 'extends' keyword.

By using inheritance all the feature of super class is by default available to the sub class so the sub class need not to start the process from begning onwards.

Inheritance provides IS-A relation between the classes. IS-A relation is tightly coupled relation (Blood Relation) so if we modify the super class content then automatically sub class content will also modify.

Inheritance provides us hierarchical classification of classes, In this hierarchy if we move towards upward direction more generalized properties will occur, on the other hand if we move towards downwand more specialized properties will occur.

Java is having 4 types of inheritance

1) Single level inheritance

2) Multilevel inheritance

3) Hierarchical inheritance

4) Multiple inheritance

Note :- Java does not support multiple inheritance.
-------------------------------------------------------------------
Note :- In java there is a predefined class called Object, by default this class is the super class of all the classes we have in java.

Write a program in java to implement single level inheritance 
-------------------------------------------------------------------
This package contains 3 files :
------------------------------
Super.java
----------
package com.ravi.inheritance;

public class Super 
{
   protected int x,y;
   
   public void acceptData(int c, int d)
   {
	 x = c;
	 y = d;
   }
   
}

Sub.java
---------
package com.ravi.inheritance;

public class Sub extends Super 
{
    public void showData()
    {
    	System.out.println("x value is :"+x);
    	System.out.println("y value is :"+y);
    }
}

Main.java
---------
package com.ravi.inheritance;

public class Main {

	public static void main(String[] args) 
	{
		Sub s = new Sub();
		s.acceptData(100, 200);
		s.showData();

	}

}

Note :- While working with Inheritance concept it is always better to create the object for sub class that is more Specialized class.
--------------------------------------------------------------------
27-Apr-23
---------
Write a program in java to implement single level inheritance 
-------------------------------------------------------------
This package contains 3 files

1)TemporaryEmployee.java
------------------------
package com.ravi.single_level_ex1;

public class TemporaryEmployee 
{
  protected int employeeNumber;
  protected String employeeName;
  protected String employeeAddress;
}

2) PermanentEmployee.java
---------------------------
package com.ravi.single_level_ex1;

public class PermanentEmployee extends TemporaryEmployee 
{
  protected String department;
  protected String designation;
  
  
  public void setData(int eno, String name, String addr, String dept, String desi)
  {
	  employeeNumber = eno;
	  employeeName  = name;
	  employeeAddress = addr;
	  department = dept;
	  designation = desi;
  }


@Override
public String toString() {
	return "PermanentEmployee [department=" + department + ", designation=" + designation + ", employeeNumber="
			+ employeeNumber + ", employeeName=" + employeeName + ", employeeAddress=" + employeeAddress + "]";
}  
  
}

3) SingleLevel.java
--------------------
package com.ravi.single_level_ex1;

public class SingleLevel {

	public static void main(String[] args) 
	{
		PermanentEmployee pe = new PermanentEmployee();
		pe.setData(111, "Puja", "Hyderabad", "Computer", "Programmer");
		System.out.println(pe);

	}

}
--------------------------------------------------------------------
WAP in java to implement Multi-level inheritance
------------------------------------------------
Here we can develop the program using Single file approach, In this approach our main method must be present in the source file name (MultiLevel.java)

We have only one file (MultiLevel.java)
---------------------------------------
package com.ravi.single_file;

class GrandFather
{
	public void house()
	{
		System.out.println("4 BHK house!!!");
	}
}

class Father extends GrandFather
{
	public void land()
	{
		System.out.println("2 acres land!!!");
	}
}
class Daughter extends Father
{
	public void car()
	{
		System.out.println("Audi car!!!");
	}
}


//ELC
public class MultiLevel 
{
	public static void main(String[] args) 
	{
		Daughter d = new Daughter();
		d.house(); d.land(); d.car();

	}

}
--------------------------------------------------------------------
The following program on Hierarchical inheritance contains 4 files

1) Emloyee.java
---------------
package com.ravi.hierarchical_ex;

public class Employee 
{
  protected double salary;
}

2) Developer.java
------------------
package com.ravi.hierarchical_ex;

public class Developer extends Employee
{
   public Developer(double salary)
   {
	 this.salary = salary;   
   }

	@Override
	public String toString() {
		return "Developer [salary=" + salary + "]";
	}
   
   
}


3) Designer.java
----------------
package com.ravi.hierarchical_ex;

public class Designer extends Employee 
{
  public Designer(double salary)
  {
	  this.salary = salary;
  }

	@Override
	public String toString() {
		return "Designer [salary=" + salary + "]";
	}
  
  
}

4) Hierarchical.java
---------------------
package com.ravi.hierarchical_ex;

public class Hierarchical {

	public static void main(String[] args) 
	{
		Developer d1 = new Developer(50000);
		
		Designer d2 = new Designer(30000);
		
		System.out.println(d1);  System.out.println(d2);

	}

}
--------------------------------------------------------------------
super keyword :
------------------
super keyword is mainly used to access the member of super class. In java we can use super keyword in following ways :-

1) To call the variable of the super class

2) To call the method of the super class

*3) To call the constructor of the super class.

1) To call the variable of the super class
--------------------------------------------
    Whenever super class variable name and sub class variable name both are same and if we create an object for the sub class then the sub class will provide more priority to its own class variable, If we want to invoke the super class variable then we should use super keyword.

    super keyword always refers to its immediate super class.

    Note :- We should use super keyword when the super class member name and sub class member name both are same as welll as We can't use super keyword from static context.
-------------------------------------------------------------------
Program on super keyword to access the super class variable :
-----------------------------------------------------------
Here we have a single file approach
------------------------------------
Main.java
---------
package com.ravi.super_var_demo;

class Father
{
  protected double balance = 20000;	
}
class Son extends Father
{
	protected double balance = 5000;
	
	public Son()
	{
		System.out.println("Son balance is :"+balance);
		System.out.println("Father balance is :"+super.balance);
	}
}

public class Main 
{
	public static void main(String[] args)
	{
		new Son(); 
	}

}
--------------------------------------------------------------------
2) To call the method of the super class
---------------------------------------------
   Whenever super class method name and sub class method name both are same and if we create an object for the sub class then by default it will invoke or call the sub class method, if we want to call the super class method then we should use super keyword.
-------------------------------------------------------------------
Program on super keyword to access the super class method :
-----------------------------------------------------------
Here we have a single file approach
------------------------------------
Main.java
---------
package com.ravi.super_method_ex;
class Super
{
	public void show()
	{
		System.out.println("Super class show method!!!!");
	}
}
class Sub extends Super
{
	public void show()
	{		
		System.out.println("Sub class show method!!!!");
		super.show();
	}
}
public class Main {

	public static void main(String[] args) 
	{
		new Sub().show(); //calling the show method with Anonymous object

	}

}
--------------------------------------------------------------------
28-Apr-23
---------
3) To call the super class constructor : (Constructor Chaining)
-------------------------------------------------------------------
Whenever we write a class in java and we don't write any kind of constructor to the class then the java compiler will automatically add one default constructor to the class.

THE FIRST LINE OF ANY CONSTRUCTOR IS RESERVERD EITHER FOR super() or this() keyword.

In the first line of any constructor if we don't specify either super() or this() then the compiler will automatically add super() to the first line of constructor.

Now the purpose of this super() [added by java compiler], to call the default constructor or No-Argument constructor of the super class.

In order to call the constructor of super class as well as same class, we have total 4 cases.

1) super() :- To call the no-argument constructor or default constructor of the super class

Program to call the No argument constructor of the Super class 
--------------------------------------------------------------
Main.java
----------
package com.ravi.no_arg_constr;
class A
{
	public A()
	{
		System.out.println("class A");
	}
}
class B extends A
{
	public B()
	{	   
		System.out.println("class B");
	}
}
class C extends B
{
	public C()
	{
		System.out.println("class C");
	}
}
public class Main 
{

	public static void main(String[] args) 
	{
		new C();
	}

}
--------------------------------------------------------------------
Case 2 :- 
--------
super(String str) :- To call the parameterized constructor of super class.

Program to call the parameterized constructor of the Super class 
--------------------------------------------------------------
Main.java
----------
package com.ravi.resource;
class Super
{
	public Super(String name)
	{
	  	System.out.println("My institute name is :"+name);
	}
}
class Sub extends Super
{
	public Sub()
	{
		super("NIT"); //calling the parameterized constructor of super class
		System.out.println("It is in Hyderabad");
	}
}
public class Main {

	public static void main(String[] args) 
	{
		new Sub();

	}

}
-------------------------------------------------------------------
Case 3 :
--------
this() :- calling the own class(same class or current class) no argument constructor.

Program to call the No Argument constructor of the same class 
--------------------------------------------------------------
Main.java
----------

package com.ravi.same_class_no_argument;

class Parent
{
   public Parent()
   {	  
	   System.out.println("No argument constructor of Parent class ");
   }
   
   public Parent(String str)
   {
      this(); //calling the no-argument constructor of same class
      System.out.println("Parameterized Constructor :"+str);
   }
}
class Child extends Parent
{
	public Child()
	   {
		   super("Ravi");
		   System.out.println("No argument constructor of Child class");
	   }
}
public class Main
{
	public static void main(String[] args)
	{
		new Child();

	}
}
--------------------------------------------------------------------
H.W
case 4 :
--------
this(int x) :- Calling the parameterized constructor of same class.


-------------------------------------------------------------------
Program on super keyword to call the parameterized constructor of super class

Main.java
---------
package com.ravi.super_keyword;

class Shape
{
	protected int a; //a = 5
	public Shape(int a)
	{
		this.a = a;
		System.out.println(a);
	}
}
class Square extends Shape
{
	public Square(int x) 
	{
		super(x);		
	}
	
	public void getArea()
	{
		System.out.println("Area of Square is :"+(a*a));
	}
	
}

public class Main {

	public static void main(String[] args) 
	{
		Square ss = new Square(5);
		ss.getArea();

	}

}
--------------------------------------------------------------------
Program on super keyword to call the parameterized constructor of super class

Main.java
-----------
package com.ravi.super_keyword;

class Shape
{
	protected int a; //a = 5 -> 20
	public Shape(int a)
	{
		this.a = a;
		System.out.println(a);
	}
}
class Square extends Shape
{
	public Square(int x) 
	{
		super(x);		
	}
	
	public void getArea()
	{
		System.out.println("Area of Square is :"+(a*a));
	}
	
}

class Rectangle extends Shape
{
	int z;
	public Rectangle(int l ,int b) //l=20   b = 30
	{
		super(l);
		z = b;
	}
	
	public void getArea()
	{
		System.out.println("Area of Rectangle :"+(a*z));
	}
}

public class Main {

	public static void main(String[] args) 
	{
		Square ss = new Square(5);
		ss.getArea();

		Rectangle rr = new Rectangle(20, 30);
		rr.getArea();
	}

}
-------------------------------------------------------------------
Lab Program :
-------------
This package contains 4 files 

Shape.java
----------
package com.ravi.lab_exam;

public class Shape 
{
  private int data;  //2

	public Shape(int data) //data = 2
	{
		super();
		this.data = data;
	}

	public int getData() {
		return data;
	}

	public void setData(int data) {
		this.data = data;
	}

	@Override
	public String toString() {
		return "Shape [data=" + data + "]";
	}
	
	
	  
  
}

Circle.java
------------
package com.ravi.lab_exam;

import java.text.DecimalFormat;

public class Circle extends Shape 
{
   final double PI = 3.14;
   
   public Circle(int radius)  //radius = 2
   {
	   super(radius);
   }
   
   public void areaOfCircle()
   {
	   
	   double area = PI*getData()*getData();
       DecimalFormat df = new DecimalFormat("00.00");
       
	   System.out.println("Area of circle is :"+df.format(area));
   }
}

Rectangle.java
---------------
package com.ravi.lab_exam;

public class Rectangle extends Shape 
{
   private int length;
   
 
   public Rectangle(int length, int breadth)
   {
	   super(breadth);
	   this.length = length;
   }

   public void areaOfRectangle()
   {
	   double area = length* getData();
	   
	   System.out.println("Area of rectangle is :"+area);
   }
   
}

Test.java
---------
package com.ravi.lab_exam;

public class Test {

	public static void main(String[] args) 
	{
		Circle c1 = new Circle(3);
		c1.areaOfCircle();
		
		Rectangle rr = new Rectangle(2, 3);
		rr.areaOfRectangle();

	}

}

-------------------------------------------------------------------
01-May-23
----------
*Why java does not support multiple inheritance ?
-------------------------------------------------------
Whenever a sub class wants to inherit the properties of two or more super classes and both the super class contains same method name then it leads ambiguity problem for the sub class to invoke the method of super classes as shown in our example (diagram)

In our example two super classes i.e class A and class B contain sum() method and there is a sub class called C which try to extends two super classes i.e A and B.

For sub class C, it is difficult to call sum() method because there would be ambiguity problem.

That is the reason java does not support multiple inheritance using classes also known as "Diamond Problem" in java, but same(multiple inheritance) we can achieve by using interface concept later.

In java multiple inheritance is possible using interfaces but not by using the classes.
--------------------------------------------------------------------
Access modifiers in java :
-----------------------------
An access modifiers describes the accessibility scope of the classes as well as the member of the classes.

In java we have 4 access modifiers

1) private (Within the same class)

2) default (Within the same package)

3) protected (Accessible from another package but using inheritance)

4) public  (No restriction, Accessible from everywhere)

private :- 
---------
It is an access modifier and it is the most restrictive access modifier because the member declared as private can't be accessible from outside of the class.
In Java we can't declare an outer class as a private or protected. Generally we should declare the data member(variables) as private.

In java outer class can be declared as public, abstract and final only.

default :-
----------
It is an access modifier which is less restrictive than private. It is such kind of access modifier whose physical existance is not avaialble that means when we don't specify any kind of access modifier before the class name, variable name or method name then by default it would be default.

As far as its accessibility is concerned, default members are accessible within the same folder(package) only.


protected :
------------
It is an access modifier which is less restrictive than default because the member declared as protected can be accessible from the outside of the package (folder) too but by using inheritance concept.

Both the programs are available in different package
-----------------------------------------------------------
The protected modifier programs contains 3 files (two program in the same package + one is another package)

Test.java + Main.java (Same package)

Demo.java (Another package)

Test.java
-----------
package com.ravi.constructor;

public class Test 
{
    protected int x = 100;
}



Main.java
----------
package com.ravi.constructor;

public class Main {

	public static void main(String[] args) 
	{
		Test t1 = new Test();
		System.out.println(t1.x);

	}

}

Demo.java
---------
package com.ravi.inheritance;

import com.ravi.constructor.Test;

public class Demo extends Test{

	public static void main(String[] args) 
	{
		Demo d1 = new Demo();
		System.out.println(d1.x);

	}

}
--------------------------------------------------------------------
public :-
-------
It is an access modifier which does not contain any kind of restriction that is the reason the member declared as public can be accessible from everywhere without any restriction.

According to Object Oriented rule we should declare the classes and methods as public where as variables must be declared as private or protected according to the requirement.
-------------------------------------------------------------------
02-May-23
----------
Type casting in Java :
-----------------------
Type casting is nothing but converting one data type to another data type.
In java type casting can be divided into two types

1) Implicit type casting OR Widening OR Automatic type casting

2) Explicit type casting OR Narrowing OR Manual type casting

Implicit type casting :-
------------------------
If we try to assign a smaller data type to bigger data type then by default, compiler does not have any issue so it will be converted automatically This is the  reason it is known as Implicit or automatic type casting.

byte -> short -> char -> int -> long -> float -> double

Eg:-  byte b = 12;
         short s = b;
--------------------------------------------------------------------------------------------
//program on Implicit type casting 

package com.ravi.implicit;

public class ImplicitEx1 
{
	public static void main(String[] args)
	{
	  byte b = 15;
	  short s = b;
      System.out.println("value is :"+s);
	}
}
----------------------------------------------------------------------------------------------
package com.ravi.implicit;

public class ImplicitEx2 
{
	public static void main(String[] args) 
	{
	  int i = 4567;
	  long x = i;	  
	  System.out.println("Value is :"+x);
	}
}
---------------------------------------------------------------------------------------------
package com.ravi.implicit;

public class ImplicitEx3 
{
	public static void main(String[] args)
	{
	   int x = 'A';
	   System.out.println("x value is :"+x);
	}

}
----------------------------------------------------------------------------------------------

Explicit type casting :
-----------------------
Whenever we try to assign a bigger data type to smaller data type then by default, compiler does not allow this but if we want to perform the explicit type casting then we need to convert the bigger type into smaller type by performing manual type casting.
While performing the explicit type casting there may be chance of loss of data if the value for smaller data type will be beyond the range.

double -> float -> long ->int -> char -> short -> byte

Eg:-
short s = 23;

byte b = s; //not possible short is bigger, byte is smaller

byte b = (byte) s; //converting short to byte type
---------------------------------------------------------------------------------------------
package com.ravi.explicit;

public class ExplicitEx1 
{
	public static void main(String[] args)
	{
	  short s = 127;
	  byte b = (byte)  s;  
      System.out.println("value is :"+b); 
	}
}
----------------------------------------------------------------------------------------------
package com.ravi.explicit;

public class ExplicitEx2 {

	public static void main(String[] args)
	{
		long l = 1299L;
		
		int x =  (int) l;
		
		System.out.println("x value is :"+x);

	}

}
---------------------------------------------------------------------------------------------
package com.ravi.explicit;

public class ExplicitEx3 {

	public static void main(String[] args) 
	{
		float f1 = (float)123.89;
		
		float f2 = 234.78f;
		
		float f3 = 1567.67F;
		
		System.out.println("f1 = "+f1+ " f2 = "+f2+ " f3 = "+f3);

	}

}
--------------------------------------------------------------------
HAS-A relation between the classes :
------------------------------------------
In order to acheive HAS-A relation concept we should use Association.

Association (Relationship between the classes through Object reference)
-------------------------------------------------------------------------------------
Association :
---------------
Association is a connection between two separate classes that can be built up through their Objects. 

The association builds a relationship between the classes and describes how much a class knows about another class. 

This relationship can be unidirectional or bi-directional. In Java, the association can have one-to-one, one-to-many, many-to-one and many-to-many relationships.

Example:-
One to One: A person can have only one PAN card
One to many: A Bank can have many Employees
Many to one:  Many employees can work in single department 
Many to Many: A Bank can have multiple customers and a customer can have multiple bank accounts.

Example :
-----------
The following program contains 3 files :-

1) Student.java
------------------
package com.ravi.association_demo;

public class Student 
{
  private int studentId;
  private String studentName;
  private long mobileNumber;
  
     //GENERATE SETTER AND GETTER
	public int getStudentId() 
	{
		return studentId;
	}
	public void setStudentId(int studentId) //111
	{
		this.studentId = studentId;
	}
	public String getStudentName() 
	{
		return studentName;
	}
	public void setStudentName(String studentName) 
	{
		this.studentName = studentName;
	}
	public long getMobileNumber() 
	{
		return mobileNumber;
	}
	public void setMobileNumber(long mobileNumber) 
	{
		this.mobileNumber = mobileNumber;
	}
	
	//Method to get student information 
    public String getStudentData()
    {
    	return ""+studentId+" : "+studentName+ " : "+mobileNumber;
    	
    }
  

}


2) Trainer.java
------------------
package com.ravi.association_demo;

import java.util.Scanner;

public class Trainer 
{
   public void viewStudentProfile(Student s)
   {
	   Scanner sc = new Scanner(System.in);
	   System.out.print("Enter Student Id :");
	   int id = sc.nextInt();
	   
	   if(id == s.getStudentId())
	   {
		  System.out.println(s.getStudentData());
	   }
	   else
	   {
		   System.out.println("Sorry!!! Student record is not available");
	   }
	   sc.close();   
   }	
}




3) Main.java
----------------
package com.ravi.association_demo;

public class Main 
{
	public static void main(String[] args)
	{
		Student s1 = new Student();
		s1.setStudentId(1); 
		s1.setStudentName("Pooja"); 
		s1.setMobileNumber(9812345678L);
		
		
		Trainer ravi = new Trainer();
		ravi.viewStudentProfile(s1);
				
	}

}
-------------------------------------------------------------------
03-May-23
----------
Composition :
---------------
Composition relation is a restricted form of Aggregation in which two classes (or entities) are highly dependent on each other; the composed object cannot exist without the other entity. The composition can be described as a part-of relationship.

A car has an engine. Composition makes strong relationship between the objects. It means that if we destroy the owner object, its members  will be also destroyed with it. For example, if the Car is destroyed the engine will also be destroyed as well.

Program on Composition :
------------------------------
The following program on composition contains 3 files :

Engine.java
--------------
package com.ravi.composition;
//Composition(Strong reference type)

public class Engine 
{
   private String engineType;
   private int horsePower;
   
	public Engine(String engineType, int horsePower) 
		{
			super();
			this.engineType = engineType;
			this.horsePower = horsePower;
		}
	
	//Getter Methods
   
	public String getEngineType()
	{
	   return engineType;
	}
	public int getHorsePower() 
	{
	   return horsePower;
	}

	@Override
	public String toString() {
		return "Engine [engineType=" + engineType + ", horsePower=" + horsePower + "]";
	}  
	
}


Car.java
---------
package com.ravi.composition;

public class Car {

	private String carName;
	private Engine engine;
	
	public Car(String carName)  //Car c1 = new Car("Naxon");
	{
		this.carName = carName;
		this.engine = new Engine("Battery", 1200); //composition (Strong Association)
	}

	@Override
	public String toString() {
		return "Car [carName=" + carName + ", engine=" + engine + "]";
	}	
}


Main.java
-----------
package com.ravi.composition;

public class Main
{
	public static void main(String[] args) 
	{
		Car c1 = new Car("Naxon");
		System.out.println(c1);
	}

}
--------------------------------------------------------------------
Aggregation (Weak Reference) :
-----------------------------------
Aggregation is a relation between two classes which can be built through entity reference,  It is a weak reference type that means one object entity does not depend upon another object entity.

An aggregation is a form of Association, which is a one-way relationship or a unidirectional association.

For example, customers can have orders but the reverse is not possible, hence unidirectional in nature.

class Customer
{
int cid;
String cname;
Order order;//has-a relationship
}

Example of Aggregation :
-----------------------------
The following program contains 3 files :

College.java
--------------
package com.ravi.aggregation;

public class College 
{
   private String collegeName;
   private String collegeLocation;
   
	public College(String collegeName, String collegeLocation)
	{
		super();
		this.collegeName = collegeName;
		this.collegeLocation = collegeLocation;
	}

	//to print the Object properties we can override toString() method of Object class
	
	@Override 
	public String toString() {
		return "College [collegeName = " + collegeName + ", collegeLocation = " + collegeLocation + "]";
	}  
	
}

Student.java
--------------
package com.ravi.aggregation;

public class Student 
{
  private int studentRoll;
  private String studentName;
  private College clg; //HAS-A relation
  
	public Student(int studentRoll, String studentName, College clg) //clg = c1
	{
		super();
		this.studentRoll = studentRoll;
		this.studentName = studentName;
		this.clg = clg;
	}

	@Override
	public String toString() {
		return "Student [studentRoll = " + studentRoll + ", studentName = " + studentName + ", clg=" + clg + "]";
	}  
    
}

Main.java
-----------
package com.ravi.aggregation;

public class Main {

	public static void main(String[] args) 
	{
		College c1 = new College("NIT", "Hyderabad");
		
		Student s1 = new Student(1, "Virat", c1);
		System.out.println(s1); 
		
		Student s2 = new Student(2,"Ravi",c1);
		System.out.println(s2);
	}

}
-------------------------------------------------------------------
Polymorphism :
------------------
Poly means "many" and morphism means "forms".

It is a Greek word whose meaning is "same object having different behavior".

In our real life a person or a human being can perform so many task, in the same way in our programming languages a method or a constructor can perform so many task.

Eg:-

void add(int a, int b)

void add(int a, int b, int c)

void add(float a, float b)

void add(int a, float b)

Polymorphism can be divided into two types :

1) Static polymorphism OR Compile time polymorphism OR Early binding

2) Dynamic Polymorphism OR Runtime polymorphism OR Late binding

Static Polymorphism :
------------------------
The polymorphism which exist at the time of compilation is called static polymorphism.

In static polymorphism, compiler has very good idea that which method is going to invoke(call) depending upon the type of parameter we have passed in the method.

This type of preplan polymorphism is called static polymorphism. 

Example:- Method Overloading

Dynamic Polymorphism :
----------------------------
The polymorphism which exist at runtime is called dynamic polymorphism.

In dynamic polymorphism, compiler does not have any idea about method calling, at runtime JVM will decide that which method is invoked depending upon the class type.

This type of polymorphism is called dynamic polymorphism.(Dynamic Method dispatched)

Example:- Method Overriding
-------------------------------------------------------------------
 Note :- In static polynorphism method calling is done at the time of compilation so it is also knoan as Early Binding.
 On the other hand In dynamic Polymorphism method calling is done at the of execution so it is also known as Late Binding.

04-May-23
----------
Method Overloading :
------------------------
Writing two or more methods in the same class or even in the super and sub class in such a way that the method name must be same but the argument must be different.

While Overloading a method we can change the return type of the method.

While overloading the method the argument must be different otherwise there will be ambiguity problem.

IQ
---
We can overload the main method but JVM will always search the main method which takes String array as a parameter. 

Example :
------------
public static void main(String [] args)  //JVM will serach this method 
{
}
public static void main(String x)
{
}
public static void main(int y)
{
}

--------------------------------------------------------------------The following program explains about Constructor Overloading
Here we have 2 files 

Addition.java
--------------
package com.ravi.constructor_overloading;

public class Addition 
{
   public Addition(int x, int y)
   {
	   System.out.println("Sum of two integer is :"+(x+y));
   }
   
   public Addition(int x, int y, int z)
   {
	   System.out.println("Sum of three integer is :"+(x+y+z));
   }
   
   public Addition(float x, float y)
   {
	   System.out.println("Sum of two float is :"+(x+y));
   }
}

Main.java
---------
package com.ravi.constructor_overloading;

public class Main {

	public static void main(String []  args) 
	{
		new Addition(2.3f, 7.8F);		
		new Addition(10,20, 30);		
		new Addition(50, 50);
	}

}

--------------------------------------------------------------------
The following program explains that we can change the return type of the method while overloading of a method 

Here we have 2 files 

1) Sum.java
------------
package com.ravi.method_overload;

public class Sum
{
  public int add(int x, int y)
  {
	  int z = x+y;
	  return z;
  }
  
  public String add(String x, String y)
  {
	  String z = x+y;
	  return z;
  }

  public double add(double x, double y)
  {
	  double z = x+y;
	  return z;
  }
}


2) Main.java
------------
package com.ravi.method_overload;

public class Main {

	public static void main(String[] args) 
	{
		Sum s1 = new Sum();
		String add = s1.add("Data", "base");
		int x = s1.add(12, 12);
		double y = s1.add(12.89, 12.90);
		
		System.out.println(add+" : "+x+" : "+y);

	}
}

--------------------------------------------------------------------
Var-Args :
------------
It was introduced from JDK 1.5 onwards.

It stands for variable argument. It is an array variable which can hold 0 to n number of parameters of same type or different type by using Object class.

It is represented by exactly 3 dots (...) so it can accept any number of argument (0 to nth) that means now we need not to define method body again and again, if there is change in method parameter value.

var-args must be only one and last argument.(var args must be the last argument)    
-------------------------------------------------------------------
The following program of var-args contains 2 files 

Test.java
----------
package com.ravi.var_args;

public class Test 
{
  public void input(int...  x)
  {
	  System.out.println("Var args executed");
  }
}

Main.java
----------
package com.ravi.var_args;

public class Main {

	public static void main(String ...x)
	{
		Test t1 = new Test();
		t1.input();
		t1.input(12);
		t1.input(15,19);
		t1.input(10,20,30);
		t1.input(10,20,30,40);
						
	}

}
--------------------------------------------------------------------
Program on var-args to add the parameter values

Here we have 2 files 
--------------------

Test.java
----------

package com.ravi.var_args1;
public class Test 
{
  public void acceptData(int ...x)
  {
	  int total = 0;
	  
	  for(int y : x)
	  {
		  total = total + y;
	  }
	  System.out.println("Sum of the parameter is :"+total);
  }
}

Main.java
---------
package com.ravi.var_args1;

public class Main {

	public static void main(String[] args) 
	{
		Test t1 = new Test();
		t1.acceptData();
		t1.acceptData(10,20);
		t1.acceptData(10,20,30);
		t1.acceptData(100,100,100,100);

	}

}
-------------------------------------------------------------------
Program on var-args to show that var-args must only one and last argument

Here we have 2 files 
--------------------
Test.java
-----------
package com.ravi.var_args2;

public class Test 
{
	
	
	/*
	 * public void accept(int ...x, int ...y) //invalid {
	 * 
	 * }
	 * 
	 * 
	 * public void accept(int ...x, int y) //Invalid {
	 * 
	 * }
	 */
	 
	 
	
      public void accept(int x, int ...y) //valid
      {    	
    	 System.out.println(x);
    	for(int z : y)
    	{
    		System.out.println(z);
    	}
      }	
}

Main.java
----------

package com.ravi.var_args2;

public class Main {

	public static void main(String[] args) 
	{
		Test t1 = new Test();
		t1.accept(10, 20,30,40);
	}
}

-------------------------------------------------------------------
Program on var-args to show that we can accept hetrogeneous types of data

Here we have 2 files 
--------------------
Test.java
-----------
package com.ravi.var_args3;

public class Test 
{
   public void acceptHetro(Object ...obj)
   {
	   for(Object o : obj)
	   {
		   System.out.println(o);
	   }
   }
}

Main.java
----------
package com.ravi.var_args3;

public class Main {

	public static void main(String[] args) 
	{
		Test t1 = new Test();
		t1.acceptHetro("Ravi",true,45.90,12,'A');

	}

}
--------------------------------------------------------------------
05-May-23
---------
Ambiguity issues while overloading a method :(WAV)
---------------------------------------------------
Test.java
----------
class Input
{
	public void accept(byte b)
	{
		System.out.println("byte is invoked..");
	}
	public void accept(short b)
	{
		System.out.println("short is invoked..");
	}

}
public class Test
{
	public static void main(String [] india)
	{
		Input i = new Input();
		      i.accept(9); //error
	}
}


Note :- The above program will generate compilation error because accept method does not contain any integer type variable.

Test.java
----------
class Input
{
	public void accept(byte b)
	{
		System.out.println("byte is invoked..");
	}
	public void accept(short b)
	{
		System.out.println("short is invoked..");
	}

}
public class Test
{
	public static void main(String [] india)
	{
		Input i = new Input();
		      i.accept((byte)9);
			   i.accept((short)15);
	}
}
---------------------------------------------------------------------
class Input
{
	public void accept(int b)
	{
		System.out.println("int is invoked..");
	}
	public void accept(long b)
	{
		System.out.println("long is invoked..");
	}

}
public class Test
{
	public static void main(String [] india)
	{
		Input i = new Input();
		i.accept(15);
	}
}

Note :- Here the method which accepts int as a parameter will be invoked.
--------------------------------------------------------------------
//Nearest data type
class Input
{
	public void accept(String b)
	{
		System.out.println("String is invoked..");
	}
	public void accept(Object b)
	{
		System.out.println("Object is invoked..");
	}

}
public class Test
{
	public static void main(String [] india)
	{
		Input i = new Input();
		i.accept("NIT");
		i.accept(null);
	}
}

Points to remember :
--------------------
1) While ambiguity issues compiler will provide more priority to the 
   nearest data type.

2) While ambiguity issues compiler will also provide the priority 
   on the basis of following (WAV)

   [Widening  ->  Autoboxing  -> var-args]
   
--------------------------------------------------------------------
//Nearest data type (WAV)
class Input
{
	public void accept(long b)
	{
		System.out.println("long invoked..");
	}
	public void accept(Integer b)
	{
		System.out.println("Integer is invoked..");
	}

}
public class Test
{
	public static void main(String [] india)
	{
		Input i = new Input();
		i.accept(15); //long
	}
}


---------------------------------------------------------------------
//Nearest data type (WAV)
class Input
{
	public void accept(int ...b)
	{
		System.out.println("Var args invoked..");
	}
	public void accept(Integer b)
	{
		System.out.println("Integer is invoked..");
	}

}
public class Test
{
	public static void main(String [] india)
	{
		Input i = new Input();
		i.accept(15); //Integer
	}
}
---------------------------------------------------------------------
Method Overriding :
-----------------------
Writing two or more methods in the super and sub class in such a way that method signature(method name along with method parameter) of both the methods  must be same in the super and sub classes. 

While working with method overriding generally we can't change the return type of the method but from JDK 1.5 onwards we can change the return type of the method in only one case that is known as Co-Variant.

Without inheritance method overriding is not possible that means if there is no inheritance there is no method overriding.
---------------------------------------------------------------------
What is the advantage of Method Overriding ?
-----------------------------------------------------
The advantage of Method Overriding is, each class is specifying its own specific behavior.
---------------------------------------------------------------------
06-May-23
---------
Upcasting :- 
------------
It is possble to assign sub class object to super class reference variable using dynamic polymorphism. It is known as Upcasting.

Example:-    Animal a = new Dog();  //valid [upcasting]

Downcasting :
---------------
By default downcasting is not possible, Here we are trying to assign super class object to sub class reference variable but the same we can achieve by using explicit type casting. It is known as downcasting

Eg:-    Dog d = new Animal(); //Invalid

	  Dog d =(Dog) new Animal(); //Valid because Explicit type casting

	  But by using above statement (Downcasting) whenever we call a method we will get a runtime exception called java.lang.ClassCastException. [Animal cann't be  cast to Dog]
--------------------------------------------------------------------
Program on Method Overriding using upcasting :
-----------------------------------------------
class Animal
{	
	void eat()
	{
		System.out.println("I can't say");
	}
}
class Dog extends Animal
{	
	void eat()  
	{
		System.out.println("Dog is non-Veg type");		
	}	
}
class Rabbit extends Animal
{
	void eat()  
	{
		System.out.println("Rabbit is Veg type");		
	}	
}
public class AnimalDemo
{
	public static void main(String[] args) 
	{
       Animal a1 = new Dog();  //upcasting
	   a1.eat();	 
	   
	   Animal a2 = new Rabbit(); a2.eat();
	}
}

  -------------------------------------------------------------------
@Override Annotation :
--------------------------
In Java we have a concept called Annotation, introduced from JDK 1.5 onwards. All the annotations must be start with @ symbol.

@Override annotation is optional but it is always a good practice to write @Override annotation before the Overridden method so compiler as well as user will get the confirmation that the method is overridden method and it is available in the super class.

If we use @Override annotation before the name of the method in the sub class and if the method is not available in the super class then it will generate a compilation error so it is different from comment because comment will not generate any kind of compilation error if method is not an overridden method, so this is how it is different from comment.
--------------------------------------------------------------------
class A
{
	public void show()
	{
		System.out.println("class A");
	}
}
class B extends A
{	
	@Override
	public void show()   
	{
		System.out.println("class B");		
	}
}
class  CheckOverriding
{
	public static void main(String[] args) 
	{
		A a = new B();  
		a.show();
	}
 }
---------------------------------------------------------------------
08-May-23
---------
Role of Access Modifier while Overriding a method :
----------------------------------------------------------
While overriding the method from super class, the access modifier of sub class method must be greater or equal in comparison to access modifier of super class method otherwise we will get compilation error.

public is greater than protected, protected is greater than default (public > protected > default)
[default < protected < public]

So the conclusion is we can't reduce the visibility while overriding a method.

Note :- private access modifier is not availble (visible) in sub class so it is not the part of method overriding.


This program contains only 1 file 
---------------------------------
ShapeDemo.java
--------------
class Shape
{
	public void draw()
	{
		System.out.println("I can't say");
	}
}
class Rectangle extends Shape
{    
	@Override
	public void draw()
	{
		System.out.println("Drawing Rectangle");
	}
}
public class ShapeDemo
{
	public static void main(String [] args)
	{
		Shape s;

		s = new Rectangle(); s.draw();  //dynamic method dispatch

		
	}
}
---------------------------------------------------------------------

Co-variant concept in method overriding :
------------------------------------------------
In general we cann't change the return type of method while overriding a method. if we try to change it will generate compilation error as shown in the program below.

class Base
{
	public void show()
	{
		 System.out.println("Super class show method..");		 
	}
}
class Derived extends Base
{
	@Override
        public int show() //error
	{
		 System.out.println("Sub class show method..");		
		 return 0;
	}
}
class CoVariant 
{
	public static void main(String[] args) 
	{
		Base b = new Derived();
		       b.show();
	}
}
---------------------------------------------------------------------
But from JDK 1.5 onwards we can change the return type of the method in only one case that the return type of both the METHODS(SUPER AND SUB CLASS METHODS) MUST BE IN INHERITANCE RELATIONSHIP called Co-Variant as shown in the program below.
---------------------------------------------------------------------
class Animal
{
}
class Horse extends Animal
{
}

class Super
{
	public Animal display()
	{
		System.out.println("Super class display method!!!");
		return new Animal();
	}
}
class Sub extends Super
{
	@Override
	public Horse display()
	{
		System.out.println("Sub class display method!!!");
		return new Horse();
	}
}
class CoVariant1 
{
	public static void main(String[] args) 
	{
		Super s = new Sub();
		s.display();
	}
}

Note :- Co-variant return type is only possible with Inheritance 
        relationship so we can put the return type of the method 
	with class name i.e with HAS-A relation
--------------------------------------------------------------------
CoVariant2.java
---------------
class Parent  
{
    public Number show()
    {
      System.out.println("Parent : Show Method");
	  return null;
    }
}
class Child extends Parent
{
	@Override
	public Integer show()
        {
           System.out.println("Child : Show Method");
	   return null;
	}
}
public class CoVariant2 
{
	public static void main(String[] args) 
	{
		Parent p  = new Child();  p.show();
		

	}
}
--------------------------------------------------------------------
09-May-23
----------
* Can we override main method?
           OR
Can we override static method
           OR
What is method hiding in java?

Points to remember :(4 points)
-------------------------------
1) We can't override static method because it is the part of the class but not the part of the Object

2) We can't overide static method with non-static (instance) method

3) We can't overide non-static method with static method.

4) We can't override main method but we can overload the main method, Here JVM will always search the main method which contains String array as a parameter.

Defination
----------
We can't override static method because it is not the part of the object it is executed at the time of loading the .class file into JVM memory.

If a sub class defines a static method with the same signature with the static method in the super class, the method in the sub class is hidden by the method in the super class. 

We can declare a method with the same signature in the sub class as declared in the super class which  looks like we can override static methods in Java but in reality this is method hiding. 

Note :- a) we can't override static and  private methods.

           b) We can't override static method with instance method

	   c) We can't override instance method with static method    

--------------------------------------------------------------------
class Super
{
	public static void accept()
	{
		System.out.println("static method of super class!!");
	}
}
class Sub extends Super
{
	public static void accept()
	{
		System.out.println("static method of sub class!!");
	}
}
public class StaticOverride 
{
	public static void main(String[] args) 
	{
		Super s1 = new Sub();
		s1.accept();

		Sub s2 = new Sub();
		s2.accept();
	}
}

-------------------------------------------------------------------
final keyword :
---------------

1) to declare a class as a final

2) to declare a method as a final

3) to declare a variable as a final

final keyword :
-----------------
In java we use final keyword to provide some kind of restrictions.

We can use final keyword in three ways in java 

1) To declare a class as a final (Inheritance is not possible)

2) To declare a method as a final (We can't override)

3) To declare a variable(Field) as a final 


To declare a class as a final :
-------------------------------
Whenever we declare a class as a final class then we cann't extend or inherit that class otherwise we will get a compilation error.

We should declare a class as a final if the composition of the class (logic of the class) is very important and we don't want to share the feature of the class to some other developer to modify the original behavior of the existing class, In that situation we should declare a class as a final.

Declaring a class as a final does not mean that the variables and methods declared inside the class will also become as a final only the class behavior is final that means we can modify the variables value as well as we can create the object for the final classes.

Note :- In java String is declared as final class.
-------------------------------------------------------------------
2) To declare a method as a final (Overriding is not possible)
--------------------------------------------------------------------
Whenever we declare a method as a final then we can't override that method in the sub class otherwise there will be a compilation error.

We should declare a method as a final if the body of the method i.e the implementation of the method is very important and we don't want to override or change the super class method body by sub class method body then we should declare the super class method as final method.


class A
{
	protected int a = 10;
	protected int b = 20;

     public final void calculate()
	  {
		int sum = a+b;
		System.out.println("Sum is :"+sum);
	  } 
}
class B extends A
{
	
	public void calculate() 
	{
		int mul = a*b;
		System.out.println("Mul is :"+mul);	
	}
}
class FinalMethodEx 
{
	public static void main(String [] args) 
	{
		 A a1 = new B();
		 a1.calculate();
	}
}
--------------------------------------------------------------------
3) To declare a variable(field) as a final :(Re-assignment is not possible)
------------------------------------------------------------------

In older langugaes like C and C++ we use "const" keyword to declare a constant variable but in java const is a reserved word for future use so instead of const we should use "final" keyword.

If we declare a variable as a final then we can't perform re-assignment (i.e nothing but re-initialization) of that variable.

In java It is always a better practise to declare a final variable by uppercase letter according to the naming convention.

Some example of predefined final variables 

Byte.MIN_VALUE   -> MIN_VALUE is a static and final variable

Byte.MAX_VALUE  -> MAX_VALUE is a static and final variable

Example:-   final int DATA = 10; (Now we can not perform re-assignment )
-------------------------------------------------------------------
class A
{
	final int A = 10;
	public void setData()
	{
		 A = 10;   //error re-assignment is not possible
		 System.out.println("A value is :"+A);
	}
}
class FinalVarEx 
{
	public static void main(String[] args) 
	{
		A a1 = new A();
		a1.setData();
	}
}
-------------------------------------------------------------------
class FinalVarEx1 
{
	public static void main(String[] args) 
	{
		final int A = 15;
		byte b = A;
		System.out.println(b);
	}
}

The above program will compile and generate the output
-------------------------------------------------------------------
class Test 
{
	public static void main(String[] args) 
	{
		final long l = 12;
		int x = l;
		System.out.println(x);
	}
}

Even long type is final but we can't assign long to int because long is always bigger then int.
--------------------------------------------------------------------
Note :- 

1) final variables must be initialized at the time of declaration or later (only constructor), after that we can't perform re-initialization.
 
2) A blank final variable can't be initialized by default constructor.

3) A blank final variable must be initialized by the user as a part of constructor. If we have multiple constructor then final variable must be initialized with all the constructor to provide values for the blank final variable to all the objects.
--------------------------------------------------------------------
class BlankFinalVar 
{
	final int A;  //Blank final variable   //Error
	
	public static void main(String[] args) 
	{
		BlankFinalVar fv = new BlankFinalVar();
		System.out.println(fv.A); 
	}
}

------------------------------------------------------------------
class Demo
{	
	 final int A; // blank final variable
	
	public Demo()  //No Argument constructor
	{		
		A = 15;
		System.out.println(A);
	}

	public Demo(int x)  //parameterized constructor
	{		
		A = x;
		System.out.println(x);
	}
}	
public class  BlankFinalVariable
{
	public static void main(String[] args) 
		{		
	         Demo d1 = new Demo();

			 Demo d2 = new Demo(8);
	    }
}
--------------------------------------------------------------------
Working with Object class and its methods :
--------------------------------------------------
There is a predefined class called Object available in java.lang package, this Object class is by default the super class of all the classes we have in java.

class Test 
{

}

Note :- Object is the super class for this Test class. by default this Object class is super class so explicitly we need not to mention.

Since, Object is the super class of all the classes in java that means we can override the method of Object class as well as we can use the methods of Object class anywhere in java because every class is sub class of Object class.

The Object class provides some common behavior to each sub class Object like we can compare two objects , we can create clone (duplicate) objects, we can object print object properties(instance variable), providing a unique number to each and every object(hashCode()) and so on.
-------------------------------------------------------------------
 Method chaining in java :
 -------------------------
class Test 
{	
	public static void main(String[] args) 
	{
		String str = "India";
		int x = str.toUpperCase().concat(" is great").length();
		System.out.println(x);
		
		System.out.println(str.getClass().getName());
	}
}
--------------------------------------------------------------------
11-May-23
-----------
Working with method of Object class :
--------------------------------------
public final native Class getClass() :-
------------------------------------------
It is a predefined method of Object class.

This method returns the runtime class of the object, the return type of this method is java.lang.Class.

This method will provide the class + class name. [class Test]

This getClass() method return type is java.lang.Class so further we can apply any other method of java.lang.Class class method.


//getClass() method of Object class

Program :
---------
public class Test 
{
	public static void main(String[] args) 
	{
	   Test t1 = new Test();
	   String name = t1.getClass().getName();
	   System.out.println("Name of the class is :"+name);

	    String str = "india";
	    name = str.getClass().getName();
	   System.out.println("Name of the class is :"+name);

	    
	}
}
--------------------------------------------------------------------
public native int hashCode() :-
-----------------------------
It is a predefined method of Object class.

Every Object contains a unique number generated by JVM at the time of Object creation is called hashCode.

we can find out the hashCode value of an Object by using hashCode() method of Object class, return type of this method is int.

Program :
---------
//calling the hashCode() of Object class
public class Demo2   
{
	public static void main(String[] args) 
	{
		Demo2 d1 = new Demo2();
		System.out.println("Hash Code is :"+d1.hashCode());

		Demo2 d2 = new Demo2();
		System.out.println("Hash Code is :"+d2.hashCode());
	}
}
-------------------------------------------------------------------
public String toString() :
----------------------------
It is a predefined method of Object class.

it returns a string representation of the object. In general, the toString method returns a string that "textually represents" this object. The result should be a concise but informative representation that is easy for a person to read

toString() method of Object class conatins following logic.

public String toString()
{
	return getClass().getName()+" @ "+Integer.toHexString(hashCode());   
}

Please note internally the toString() method is calling the hashCode() method of Object class.

In java whenever we print any Object reference by using System.out.println() then internally it will invoke the toString() method of Object class as shown in the following program.
-------------------------------------------------------------------
package com.nit.intro;

public class Demo 
{
	public static void main(String[] args)
	{
		Demo d = new Demo();
		System.out.println(d);  //toString()

	}

}
--------------------------------------------------------------------
Now we got the idea that toString() method is present in the super class i.e Object class, which is printing String representation of the Object and this method will automatically call, whenever we print any Object reference by using System.out.println().

As a developer, we can override the toString() method in our own class anywhere in java so we can get the output of our own class method as shown below.

Overriding the toString() method in our userdefined class :
--------------------------------------------------------------------
package com.nit.intro;

public class Demo 
{
	@Override
	public String toString()
	{
		return "TCS";
	}
	public static void main(String[] args)
	{
		Object d = new Demo(); //upcasting
		System.out.println(d);  //toString()

	}

}
--------------------------------------------------------------------
Overriding hashCode() method of Object class :
----------------------------------------------
//Overriding hashCode() method but not in a proper way because it returns fixed value

class Employee
{
	int eid;

	@Override
	public int hashCode()
	{
		return 15;  //Here we are returning a fixed value
	} 	
}
public class Demo3 
{
	public static void main(String[] args) 
	{
		Employee e1 = new Employee();
		System.out.println(e1.hashCode());

		Employee e2 = new Employee();
		System.out.println(e2.hashCode());
	}
}
--------------------------------------------------------------------
//Overriding hashCode() method in a proper way
class Employee  
{
	int eid;

	public Employee(int eid)
	{
		this.eid = eid;
	}

	@Override
	public int hashCode()    
	{                                    
		return eid;  
	}
}
public class Demo4 
{
	public static void main(String[] args) 
	{
		Employee e1 = new Employee(12);
		Employee e2 = new Employee(13); 
		
		System.out.println(e1.hashCode());  //hashCode()
		System.out.println(e2.hashCode());  //hashCode()

		System.out.println(e1);  //toString()  //Employee@c
		System.out.println(e2);  //toString()  //Employee@d
		
	}
}
--------------------------------------------------------------------
//Overriding the hashCode() and toString() method
class Employee
{
	int eid;
	public Employee(int eid)
	{
		this.eid = eid;
	}

	@Override 
	public String toString()
	{
		return eid+" ";
	}

	@Override
	public int hashCode()
	{
		return eid;
	}
}
public class Demo5 
{
	public static void main(String[] args) 
	{
		Employee e1 = new Employee(11); 
		Employee e2 = new Employee(12); 
		
		System.out.println(e1);  
		System.out.println(e2);		
	}
}
--------------------------------------------------------------------
public boolean equals(Object obj) :
----------------------------------------
It is a predefined method of Object class.

It is used to compare two Objects based on the reference i.e memory address becuase internally equals method uses == operator which always compares based on the the reference i.e the memory address so even though two objects are content wise same but still it will generate false.

//In the program we are calling the equals(Object o) method of Object class.

This package contains two files
--------------------------------

Product.java
-------------
package com.ravi.equals_method;

public class Product 
{
  private int productId;
  private String productName;
	public Product(int productId, String productName) 
	{
		super();
		this.productId = productId;
		this.productName = productName;
	}  
  
}

ProductEquality.java
----------------------
package com.ravi.equals_method;

public class ProductEquality 
{
  public static void main(String[] args) 
  {
	Product p1 = new Product(111, "Mobile");	
	Product p2 = new Product(222, "Camera");
	Product p3 = new Product(111, "Mobile");
	Product p4 = p2;
	
	System.out.println(p1==p2); //false
	System.out.println(p1==p3); //false
	System.out.println(p2==p4); //true
	
	System.out.println(p1.equals(p2)); //false
	System.out.println(p1.equals(p3)); //false
	System.out.println(p2.equals(p4)); //true
  }
}
--------------------------------------------------------------------
package com.ravi.equals_method;
class Employee
{
	private int employeeId;
	private String employeeName;
	
	public Employee(int employeeId, String employeeName) 
	{
		super();
		this.employeeId = employeeId;
		this.employeeName = employeeName;
	}
	
	@Override
	public boolean equals(Object obj)  //obj = e2    [e2 is of Employee type]
	{
		Employee e2 = (Employee)obj;  //Downcasting
		int id1 = this.employeeId;
		String name1 = this.employeeName;
		
		int id2 = e2.employeeId;
		String name2 = e2.employeeName;
		
		//Here equals() method of String class will verify whether both the       Strings are same or not
		if(id1==id2 && name1.equals(name2))
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	
	
}

public class Main 
{
	public static void main(String[] args) 
	{
		Employee e1 = new Employee(111, "Virat");
		Employee e2 = new Employee(111, "Virat");
		System.out.println(e1.equals(e2));

	}

}

Note :- In the above program we have overridden equals(Object obj) method from the Object class.

Object class equals(Object obj) method meant for memory address comparison because internally it uses == operator only.

The Overridden equals(Object obj) method of Employee class is used to compare the content of two objects, if the contents are same then it will return true otherwise it will return false.

WE CAN OVERRIDE equals(Object obj) METHODS IN OUR CLASS FOR CONTENT COMPARISION.
-------------------------------------------------------------------
package com.ravi.equals_method;

class Customer
{
	private Integer customerId;
	private String customerName;
	
	public Customer(Integer customerId, String customerName) {
		super();
		this.customerId = customerId;
		this.customerName = customerName;
	}
	
	@Override
	public boolean equals(Object obj)
	{
		if(obj instanceof Customer)
		{
			Customer c2 = (Customer) obj; //down casting
			
			if(this.customerId == c2.customerId && 
		    this.customerName.equals(c2.customerName))
			{
				return true;
			}
			else
			{
				return false;
			}
		}
		else
		{
			return false;
		}
	}
	
}

class Student
{
	private Integer studentId;
	private String studentName;
	
	public Student(Integer studentId, String studentName) {
		super();
		this.studentId = studentId;
		this.studentName = studentName;
	}
}


public class ELC {

	public static void main(String[] args) 
	{
		Customer c1 = new Customer(111,"raj");
		Customer c2 = new Customer(111,"raj");
		Student s1 = new Student(111,"raj");
		System.out.println(c1.equals(c2));
		System.out.println(c1.equals(s1));  //due to instanceof it will give false
		System.out.println(c1.equals(null)); //for null instanceof operator provides false
	}

}
-----------------------------------------------------------------
13-May-23
----------
enum in java :
--------------
An enum is class in java that is used to represent group of universal constants. It is introduced from JDK 1.5 onwards. 

In order to craete an enum, we can use enum keyword and all the univarsal constants of the enum must be separeted by comma. Semicolon is optional at the end.

Example:-

enum Color 
{
    RED, BLUE, BLACK, PINK     //public + static + final

 }

The enum constants are by default public, static and final.

An enum we can define inside the class, outside of the class and even inside of the method.

If we define an enum inside the class then we can apply public, private, protected and static.

Every enum in java extends java.lang.Enum class so an enum can implement interfaces but can't extends a class.

By deafult every enum is implicitly final so we can't inherit an enum.

In order to get the constant value of an enum we can use values() method which return enum array, but this method is provided as part of enum keyword that means this method is not available inside the enum class.

In order to get the order position of enum constants we can use ordinal() method which is given inside the enum class and the return type of this method is int. The order position of enum constant will start from 0.

As we know an enum is just like a class so we can define any method, constructor inside an enum.

All the enum constants are by default object of type enum.

Enum constants must be decalred at the first line of enum otherwise we will get compilation error.
----------------------------------------------------------------
public class Test1
{
	public static void main(String[] args) 
	{
		enum Month
		{
			JANUARY, FEBRUARY,MARCH     //public + static + final
		}

		System.out.println(Month.MARCH);
	}
}
-----------------------------------------------------------------
enum Month 
{
	JANUARY,FEBRUARY,MARCH 
} 
public class Test2
{
	enum Color {	RED,BLUE,BLACK } 

     public static void main(String[] args) 
	{
		enum Week {SUNDAY, MONDAY, TUESDAY }
		
		System.out.println(Month.FEBRUARY);
		System.out.println(Color.RED);
		System.out.println(Week.SUNDAY);
	}
}
Note :- From the above Program it is clear that we can define an enum inside a class, outside of a class and inside a method as well.
----------------------------------------------------------------
//Comapring the constant of an enum
public class Test3 
{
	enum Color { RED,BLUE } 

     public static void main(String args[])
     {
          Color c1 = Color.RED; 
          Color c2 = Color.RED;  
		  
          if(c1 == c2)
          {
                System.out.println("==");
          }
          if(c1.equals(c2))
          {
                 System.out.println("equals");
          }
     }	
}

Note :- In the above program c1 and c2 variables having same memory address so when we compare by == operator it will return true and even if we compare by equals(Object obj) of object class it will also return true.
-----------------------------------------------------------------
public class Test4 
{
	static enum Season   //private, public, protected, static
	{
	SPRING, SUMMER, WINTER, RAINY;
	}

	public static void main(String[] args) 
	{
		System.out.println(Season.RAINY);
	}
}

Note :- If we declare an enum inside a class it can be private, default, protected, public and static
-----------------------------------------------------------------
//Interview Question
class Hello
{
	int x = 100;
}

enum Direction extends Hello
{
	EAST, WEST, NORTH, SOUTH
}

class Test5 
{
	public static void main(String[] args) 
	{
		System.out.println(Direction.SOUTH);
	}
}
Note :- The above program will generate the error because by default every enum extends java.lang.Enum class. Which is an abstract class.
----------------------------------------------------------------
//All enums are by default final so can't inherit

enum Color
{
	RED, BLUE, PINK;
}
class Test6 extends Color
{
	public static void main(String[] args) 
	{
		System.out.println(Color.RED);
	}
}
-----------------------------------------------------------------
//values() to get all the values of enum

class Test7 
{
	 enum Season   
	{
	SPRING, SUMMER, WINTER, FALL, RAINY
	}

	public static void main(String[] args) 
	{
		Season s1[] = Season.values();    //enum keyword method

		for(Season x : s1)
			System.out.println(x);
	}
}
Note :- In the above program we use values() method of enum keyword, this method is defined as a part of enum keyword that means it is not available inside the java.lang.Enum class.
-----------------------------------------------------------------
//ordinal() to find out the order position
class Test8
{
	static enum Season   
	{
	SPRING, SUMMER, WINTER, FALL

	}


	public static void main(String[] args) 
	{
		Season s1[] = Season.values();

		for(Season x : s1)
			System.out.println(x+" order is :"+x.ordinal());
	}
}

Note :- In the above class we use ordinal method of Enum class to get the order position of an enum constants. The order position will start from 0.
-----------------------------------------------------------------
//We can take main () inside an enum

enum Test9 
{
	TEST1, TEST2, TEST3 ;  //Semicolon is compulsory 

	public static void main(String[] args) 
	{
		System.out.println("Enum  main method");
	}	
}

Note Inside an enum we can take main method but ; is compulsory and all the enum constants must be the first line of enum
-----------------------------------------------------------------
//constant must be in first line of an enum

enum Test10
{
	public static void main(String[] args) 
	{
		System.out.println("Enum  main method");
	}

	 HR, SALESMAN, MANAGER;
}

Note :- In the above program we will get a compilation error because enum constants must be define in the very first line of an enum.
-----------------------------------------------------------------
//Writing constructor in enum
enum Season
{
	WINTER, SUMMER,SPRING, RAINY; //All are object of type enum

	Season()
	{
		System.out.println("Constructor is executed....");
	}
}
class Test11 
{
	public static void main(String[] args) 
	{
		System.out.println(Season.WINTER);
	}
}
Note :- All enum constants are by default Object of type enum  so when JVM will load enum to the memory all objects will be automatically loaded so for every enum Object respective constructor will be executed.
-----------------------------------------------------------------
   //Writing constructor with message
   enum Season   
	{
	SPRING("Pleasant"), SUMMER("UnPleasent"), RAINY("Rain"), WINTER;

      String msg;
	  
	    Season(String msg)
		{
		  this.msg = msg;
		}

		Season()
		{
			this.msg = "Cold";
		}

		public String getMessage()
		{
			return msg;
		}
	}
class Test12
{	
	public static void main(String[] args) 
	{
		Season s1[] = Season.values();

		for(Season x : s1)
			System.out.println(x+"  is :"+x.getMessage());
	}
}
-----------------------------------------------------------------
enum MyType 
{
ONE 
{
	@Override
    public String toString() 
	{
        return "this is one";
    }
},
 
TWO 
{
	@Override
    public String toString() 
	{
        return "this is two";
    }
}
}
public class Test13
{
	public static void main(String[] args) 
	{
		System.out.println(MyType.ONE);
		System.out.println(MyType.TWO);
	}
}
-----------------------------------------------------------------
public class Test14
{  
	enum Day
		{ 
		  SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY
		}  
  
public static void main(String args[])
{    
	Day day=Day.MONDAY;  
	  
	switch(day)
	{  
	 case SUNDAY:   
	 System.out.println("Sunday");  
	 break;  
	 case MONDAY:   
	 System.out.println("Monday");  
	 break;  
	 default:  
	 System.out.println("other day");  
    }  
  
  }
}  
-----------------------------------------------------------------
15-May-23
---------
Abstract class and abstract methods :
-------------------------------------------
A class that does not provide complete implementation (partial implementation) is defined as an abstract class.

An abstract method is a common method which is used to provide easiness to the programmer because the programmer faces complexcity to remember the method name.

An abstract method observation is very simple because every abstract method contains abstract keyword, abstract method does not contain any method body and at the end there must be a terminator i.e ; (semicolon)

In java whenever action is common but implementations are different then we should use abstract method, Generally we declare abstract method in the super class and its implementation must be provided in the sub class.

if a class contains at least one method as an abstract method then we should compulsory declare that class as an abstract class.

Once a class is declared as an abstract class we can't create an object for that class.

*All the abstract methods declared in the super class must be overridden in the sub classes otherwise the sub class will become as an abstract class hence object can't be created for the sub class as well.

In an abstract class we can write all abstract method or all concrete method or combination of both the method. 

It is used to acheive partial abstraction that means by using abstract classes we can acheive partial abstraction(0-100%).

*An abstract class may or may not have abstract method but an abstract method must have abstract class.

Note :- We can't declare an abstract method as final (illegal combination of modifiers)
-------------------------------------------------------------------------------------------
Program on abstract class and abstract method :

abstract class Shape
{
	 abstract void draw();
}
class Rectangle extends Shape
{
    @Override
	public void draw()
	{
	   System.out.println("Drawing Rectangle");
	}
}
class Square extends Shape
{
   @Override
	public void draw()
	{
	   System.out.println("Drawing Square");
	}
}

public class ShapeDemo  
{
	public static void main(String[] args) 
	{
		Shape s ;

		s = new Rectangle(); s.draw();

		s = new Square(); s.draw();
	}
}

--------------------------------------------------------------------abstract class Car
{
	int speed = 120;
	
	public Car()
	{
		System.out.println("Car class constructor!!!!");
	}
	
	public void getDetails()
	{
		System.out.println("It has four wheels");
	}
	
	public abstract void run();	
}
class Naxon extends Car
{
	@Override
	public void run() 
	{
		System.out.println("Run safely");		
	}
}
public class IQ 
{
	public static void main(String[] args) 
	{
		Car c = new Naxon();
		c.getDetails();
		c.run();
		System.out.println("Car speed is :"+c.speed);
	}

}


Note :- An abstract class constructor will be executed with the help of sub class constructor by using super keyword.
--------------------------------------------------------------------
Main.java
----------
abstract class AA
{
   public abstract void show();
   public abstract void demo();
}
 abstract class BB extends AA
{
	@Override
	public void show()  
	{
		System.out.println("Show method implemented in BB class!!!");
	}	
}
 class CC extends BB
 {
	@Override
	public void demo() 
	{
		System.out.println("Demo method implemented in CC class!!!");		
	}
	 
 }
public class Main 
{

	public static void main(String[] args) 
	{
		BB b = new CC();
		b.show();
		b.demo();
		
		

	}

}

-------------------------------------------------------------------
This package contains 5 classes :
----------------------------------

1) Shape.java
--------------
package com.ravi.shape_demo;

import java.util.Scanner;

public abstract class Shape 
{
	Scanner sc = new Scanner(System.in);
    public abstract void input();
	public abstract void area();
}

2) Rectangle.java
------------------
package com.ravi.shape_demo;

public class Rectangle extends Shape 
{
	int length ;
  	int breadth;
  	
	@Override
	public void input() 
	{
	   System.out.print("Enter the length of the Rectangle :");
	   length = sc.nextInt();
	   System.out.print("Enter the breadth of the Rectangle :");
	   breadth = sc.nextInt();
	}

	@Override
	public void area() 
	{
		double area = length * breadth;
		System.out.println("Area of rectangle is :"+area);
	}

	

}

3) Square.java
---------------
package com.ravi.shape_demo;

public class Square extends Shape
{
    private int side;
	@Override
	public void input() 
	{
		System.out.print("Enter the side of the Square :");
		side = sc.nextInt();		
	}

	@Override
	public void area() 
	{
		double area = side* side;
		System.out.println("Area of square is :"+area);
		
	}
}

4) Circle.java
---------------
package com.ravi.shape_demo;

public class Circle extends Shape
{
    final double PI = 3.14;
    double radius;
	@Override
	public void input() 
	{
		 System.out.print("Enter the radius of the Circle :");
		 radius = sc.nextDouble();			
	}

	@Override
	public void area() 
	{
		double area = PI*radius*radius;
		System.out.println("Area of Circle is :"+area);
		
	}
}

5) ELC.java
------------
package com.ravi.shape_demo;

public class ELC {

	public static void main(String[] args) 
	{
		Shape s = null;
		
		s = new Rectangle(); s.input(); s.area();
		s = new Square(); s.input(); s.area();
		s = new Circle(); s.input(); s.area();

	}

}
--------------------------------------------------------------------
17-May-23
----------
interface (Upto 1.7) :-
------------------------
An interface is a keyword in java which is similar to a class.

Upto JDK 1.7 an interfcae contains only abstract method that means there is a gurantee that inside an interfcae we don't have concrete or general or instance methods.

From java 8 onwards we have a facility to write default and static methods.

By using interface we can acheive 100% abstraction concept because it contains only abstract methods.

In order to implement the member of an interface, java software people has provided implements keyword.

All the methods declared inside an interface is by default public and abstract so at the time of overriding we should apply public access modifier to sub class method.

All the variables declared inside an interface is by default public, static and final.

We should override all the abstract methods of interface to the sub class otherwise the sub class will become as an abstract class hence object can't be created.

We can't create an object for interface, but reference can be created.

By using interfcae we can acheive multiple inheritance in java.

Note :- inside an interface we can't declare any blocks (instance, static) as well as we can't write constructor inside an interface.
-------------------------------------------------------------------
The following package contains 3 files :
-----------------------------------------
Moveable.java(I)
----------------
package com.ravi.interface_demo;

public interface Moveable 
{   
    int SPEED = 80; //public + static + final
    void move(); //public + abstract
}

Car.java(C)
-----------
package com.ravi.interface_demo;

public class Car implements Moveable 
{
	@Override
	public void move() 
	{
		// SPEED = 100;
		System.out.println("Car speed is :"+SPEED);
	}

}

Main.java
----------
package com.ravi.interface_demo;

public class Main {

	public static void main(String[] args) 
	{
		Moveable m = new Car();
		m.move();
		System.out.println("Speed is :"+Moveable.SPEED);

	}

}


The following package contains 3 files :
-----------------------------------------
Bank.java(I)
-------------
package com.ravi.banking_interface;

public interface Bank 
{
    void deposit(int amount);
    void withdraw(int amount);
}

Customer.java(C)
----------------
package com.ravi.banking_interface;

public class Customer implements Bank 
{
    private double balance = 10000;
    
	@Override
	public void deposit(int amount) 
	{
		balance = balance + amount;
		System.out.println("After deposit the amount is :"+balance);
	}

	@Override
	public void withdraw(int amount) 
	{
		balance = balance - amount;
		System.out.println("After withdraw the amount is :"+balance);
	}

}

ELC.java
---------
package com.ravi.banking_interface;

import java.util.Scanner;

public class ELC {

	public static void main(String[] args) 
	{
	   Bank b = new Customer();
	   Scanner sc = new Scanner(System.in);
	   System.out.print("Enter the amount u want to deposit :");
	   int dep = sc.nextInt();
	   b.deposit(dep);
	   
	   System.out.print("Enter the amount u want to withdraw :");
	   int wit = sc.nextInt();
	   b.withdraw(wit);
	   sc.close();
	}

}
--------------------------------------------------------------------
The following package contains 3 files :
-----------------------------------------
Client.java
-----------
package com.ravi.client_data;

public interface Client 
{
   void sum();
   void sub();
   void mul();
}


Developer.java
---------------
package com.ravi.client_data;

public class Developer implements Client 
{
    private int x,y;
    
    public void acceptData(int x, int y)
    {
    	this.x = x;
    	this.y = y;
    }
    
	@Override
	public void sum() 
	{
		int sum = x + y;
		System.out.println("Addition is :"+sum);
	}

	@Override
	public void sub()
	{
		int sub = x - y;
		System.out.println("Subtraction is :"+sub);

	}

	@Override
	public void mul()
	{
		int mul = x * y;
		System.out.println("Multiplication is :"+mul);

	}

}



Main.java
---------
package com.ravi.client_data;

public class Main {

	public static void main(String[] args) 
	{
		Developer d = new Developer();
		d.acceptData(12, 14);
		d.sum();  d.sub();  d.mul();
		
		
		
	}

}
--------------------------------------------------------------------
Multiple inheritance by using interface :
------------------------------------------
Upto java 7, interface does not contain any method body that means all the methods are abstract method so we can achieve multiple 
inheritance by providing the logic in the implementer class as shown in the below program

This package contains 4 files 
------------------------------
A.java(I)
----------
package com.ravi.multiple_inheritance;

public interface A 
{
  void sum();
}

B.java(I)
---------
package com.ravi.multiple_inheritance;

public interface B 
{
   void sum();
}


Implementer.java(C)
-------------------
package com.ravi.multiple_inheritance;

public class Implementer implements A,B
{
	@Override
	public void sum() 
	{
		int x = 100;
		int y = 200;
		int sum = x + y;
		System.out.println("Sum is :"+sum);
		
	}

}

MultipleInheritance.java
-------------------------
package com.ravi.multiple_inheritance;

public class MultipleInheritance {

	public static void main(String[] args) 
	{
		Implementer i = new Implementer();
		i.sum();
	}

}
--------------------------------------------------------------------
18-May-23
----------
Interface Program on loose coupling (No dependency):
-------------------------------------------------------------
This Project contains 5 files 
--------------------------------
HotDrink.java(I)
-------------------
package com.ravi.loose_coupling;

public interface HotDrink 
{
    void prepare();
}

Tea.java(C)
-------------
package com.ravi.loose_coupling;

public class Tea implements HotDrink
{
	@Override
	public void prepare() 
	{
		System.out.println("Preparing Tea");		
	}

}


Coffee.java(C)
-----------------
package com.ravi.loose_coupling;

public class Coffee implements HotDrink
{
	@Override
	public void prepare() 
	{
		System.out.println("Preparing Coffee");		
	}
}

Restaurant.java(C)
---------------------
package com.ravi.loose_coupling;

public class Restaurant 
{
  public void createObject(HotDrink hk)  // hk = new Coffee();
  {
	  hk.prepare();
  } 
}

Main.java(C)
---------------
package com.ravi.loose_coupling;

public class Main {

	public static void main(String[] args) 
	{
		Restaurant r = new Restaurant();
		
		HotDrink tea = new Tea();
		r.createObject(tea);
		
		
		HotDrink coffee = new Coffee();
		r.createObject(coffee);
		
	}

}
--------------------------------------------------------------------------------------------
Note :- We can also take return type of the method as an interface so that method can return the object of all the sub classes which are implementing from that particular interface.

public HotDrink accept()
{

   return  new Tea(); OR new Coffee(); OR null OR new Horlicks(); .....(future)
}

Note :- 

a) If the degree of dependency is very high then it is called 
   tightly coupled.

b) If the degree of dependency is very low then it is called 
   loosly coupled.
--------------------------------------------------------------------
Extending interface :
-------------------------
One interface can extends another interface but one interface can't implement another interface.

The following program explains how one interface can extends another interface -------------------------------------------------------------------
package com.ravi.jdk_seven;

interface A1
{
	void m1();
}
interface B1
{
	void m2();
}
interface C1 extends A1,B1
{
	void m3();	
}
class ImplementInterface implements C1
{
	@Override
	public void m1() 
	{
		System.out.println("It is m1 method...");	
	}
	@Override
	public void m2()
	{
	  System.out.println("It is m2 method....");	
	}
	
	@Override
	public void m3()
	{
		System.out.println("It is m3 method....");	
	}	
}
public class ExtendingInterface 
{
	public static void main(String[] args) 
	{
		ImplementInterface i = new ImplementInterface();
		i.m1();  i.m2(); i.m3();
	}
}
--------------------------------------------------------------------
Implementing class or interface by using Anonymous inner classs :
-------------------------------------------------------------------
By using anonymous inner class without using an external class, inside the ELC class only we can take an anonymous class to override the super method.

Main.java
----------
package com.ravi.anonymous;
class Super
{
	public void show()
	{
		System.out.println("Super class Show method!!!");
	}
}

public class Main 
{
	public static void main(String[] args) 
	{
		Super s = new Super() //Anonymous inner class
		{
			@Override
			public void show()
			{
				System.out.println("Sub class Show method!!!");
			}
		};
		s.show();

	}

}
--------------------------------------------------------------------
package com.ravi.anonymous;
abstract class Hello
{
	abstract public void demo();
}

class Test 
{
  public static void main(String[] args) 
  {
	 Hello h = new Hello()  //Anonymous inner class
	 {
		@Override
		public void demo() 
		{
			System.out.println("Overridden Method!!!!");
			
		}	 
	 };
	   h.demo();
  }
}
--------------------------------------------------------------------
package com.ravi.interface_anonymous;

interface Vehicle
{
	void horn();  //public + abstract
}

public class Main 
{
	public static void main(String[] args) 
	{
		Vehicle car = new Vehicle() //Anonymous inner class
		{
			@Override
			public void horn() 
			{
				System.out.println("Car horn!!!");				
			}
			
		};
		
		Vehicle bus = new Vehicle() //Anonymous inner class
		{
			@Override
			public void horn() 
			{
				System.out.println("Bus horn!!!");				
			}
			
		};
		
		car.horn(); bus.horn();		
		
	}

}
--------------------------------------------------------------------
package com.ravi.drink;
interface HotDrink
{
	void prepare();	
}

class Restaurant
{
	public void createObject(HotDrink hd)
	{
		hd.prepare();
	}
}

public class Main 
{
	public static void main(String[] args) 
	{
		HotDrink tea = new HotDrink() 
		{			
			@Override
			public void prepare() 
			{
				System.out.println("Preparing Tea");
				
			}
		};
		
		HotDrink Coffee = new HotDrink() 
		{			
			@Override
			public void prepare() 
			{
				System.out.println("Preparing Coffee");
				
			}
		};
		
		Restaurant r = new Restaurant();
		r.createObject(tea);
		r.createObject(Coffee);
	}
}
--------------------------------------------------------------------
In java there is a predefined interface called Runnable available in java.lang package so we can directly use thid interface to implement with Anonymous inner class

public interface Runnable 
{
   public abstract void run();
}

Note :- This interface is predefined Here we are just implementing this interface using Anonymous class.

ELC.java
---------
package com.ravi.drink;

public class ELC {

	public static void main(String[] args) 
	{
		Runnable r1 = new Runnable() 
		{			
			@Override
			public void run() 
			{
				System.out.println("Running here");
				
			}
		};
		r1.run();

	}

}
--------------------------------------------------------------------
java 8 features : (March 2014)
-----------------------------
Limitation of abstract method :
           OR
Maintenance problem with interface in an Industry upto JDK 1.7
--------------------------------------------------------------
The major maintenance problem with interface is, if we add any abstract method at the later stage of development inside an existing interface then all the implementer classes have to override that abstract method otherwise the  implementer class will become as an abstract class so it is one kind of boundation as shown in the program below.

This package contains 4 files :-
---------------------------------
HotDrink.java(I)
-----------------
package com.ravi.java8;

public interface HotDrink 
{
  void preapare();
  
  void expressPrepare();
}

Tea.java(C)
------------
package com.ravi.java8;

public class Tea implements HotDrink
{
	@Override
	public void preapare() 
	{
		System.out.println("Preparing Tea");
		
	}

	@Override
	public void expressPrepare() 
	{
		System.out.println("Premium Tea is available");		
	}

}

Coffee.java
------------
package com.ravi.java8;

public class Coffee implements HotDrink
{
	@Override
	public void preapare() 
	{
		System.out.println("Preparing Coffee");
		
	}
	@Override
	public void expressPrepare() 
	{
		System.out.println("No implementation becoz coffee does not have premium version");		
	}

}

Main.java
----------
package com.ravi.java8;

public class Main {

	public static void main(String[] args) 
	{
		HotDrink hd;
		
		hd = new Tea(); hd.preapare();
		
		hd = new Coffee();; hd.preapare();

	}

}

In the above interface HotDrink We are adding one abstract method expressPrepare() so now it is boundation to override this abstract method  expressPrepare() in the both the sub classes i.e Tea and Coffee hence here Tea and Coffee class will generate errors.
--------------------------------------------------------------------
Introducing default method from java 8 :
----------------------------------------
This package contains 4 files 

Vehicle.java(I)
----------------
package com.ravi.java8_new;

public interface Vehicle 
{
  void run();
  void horn();
  
  default void digitalMeter() //java 8
  {
	  System.out.println("INTRODUCING DIGITAL METER");
  }
  
}

Car.java(C)
-----------

package com.ravi.java8_new;

public class Car implements Vehicle
{
	@Override
	public void run() 
	{
		System.out.println("Car is running");		
	}	
	@Override
	public void horn() 
	{
		System.out.println("Car is horn facility");
		
	}
	
	@Override
	public void digitalMeter() //java 8
	  {
		  System.out.println("Car is having digital meter");
	  }

}

Bike.java
----------
package com.ravi.java8_new;

public class Bike implements Vehicle
{
	@Override
	public void run() 
	{
		System.out.println("Bike is running");		
	}

	@Override
	public void horn() 
	{
		System.out.println("Bike is horn facility");
		
	}
	
	@Override
	public void digitalMeter()
	{
		System.out.println("Bike is having digital meter");
	}
}

Main.java(C)
------------
package com.ravi.java8_new;

public class Main {

	public static void main(String[] args) 
	{
	  Vehicle v;
	  v = new Car(); v.run(); v.horn(); v.digitalMeter();
	  v = new Bike(); v.run(); v.horn(); v.digitalMeter();
	}

}
-------------------------------------------------------------------
20-May-23
---------
interface from JDK 1.8 onwards :
------------------------------------
Upto JDK 1.7 we can use only abstract methods inside an interface, as we know all the abastrct methods must be overridden in the sub class otherwise the sub class will become as an abstract class.

This facility of abstract methods leads to maintenance problem because if we add any new abstract method inside an existing interface then that method has to override by all the sub classes or the classes which are implementing from that particular interface.

To avoid this boundation problem java software people has introduced default and static method inside an interface so from JDK 1.8 onwards we can define the body of the method inside an interface by declaring those method as default method or static method or both.
-------------------------------------------------------------------
What is default Method inside an interface?
------------------------------------------------
default method is just like concrete method which contains method body and we can write inside an interface from java 8 onwards.

default method is used to  provide  specific implementation for the implementer classes which are implmenting from interface because we can override default method inside the sub classes to provide our own specific implementation.

*By using default method there is no boundation to override the default method in the sub class, if we really required it then we can override to provide my own implementation.

by default, default method access modifier is public so at the time of overriding we should use public access modifier.
-------------------------------------------------------------------
//default method for specific class method implementation

interface HotDrink
{
	void prepare();

	default void expressPrepare()     //possible from jdk 1.8 
	{
        System.out.println("Preparing with premium");
	}
}
class Tea implements HotDrink
{
	@Override
	public void prepare()
	{
		System.out.println("Preparing Tea");
	}

	@Override
	public void expressPrepare()  //public is compulsory here
	{
        System.out.println("Preparing premium Tea");
	}
}
class Coffee implements HotDrink
{
 @Override
  public void prepare()
	{
		System.out.println("Preparing Coffee");
	}	
}
public class DefaultMethod 
{
	public static void main(String[] args) 
	{
		HotDrink hk;
		hk = new Tea(); hk.prepare(); hk.expressPrepare();		
		hk = new Coffee(); hk.prepare(); 
	}
}
--------------------------------------------------------------------
interface I
{
	default void demo()
	{
		System.out.println("Demo Method in interface I1");
	}
}

class A
{
	public void demo()
	{
		System.out.println("Demo Method in class A");
		
	}
}

class B extends A implements I
{	
	
}

public class DefaultMethod1 
{
	public static void main(String[] args) 
	{
		B b1 = new B();
		b1.demo();
	}
}

Note :- default methods are having low priority than normal methods (Concrete Method). class is having more power than interface.
--------------------------------------------------------------------
What is static method in interface ?
---------------------------------------
 From JDK 1.8 onwards, In addition to default methods, We can define static methods in interfaces. (A static method is a method that is associated with the class in which it is defined rather than with any object. Every instance of the class shares its static methods.)
 
 static method is used to provide common implementation for all the classes which are implementing the interface. Here we can provide some common method impelmentation because we can't override static method (Method hiding concept).

 static methods define inside an interface are by default not available to implementer classes we can use static methods with the help of interface only.
 ------------------------------------------------------------------
//static method implementation common for all
interface HotDrink
{
	void prepare();

	static void expressPrepare() //possible from 1.8 onwards
	{
		System.out.println("Prepare without sugar...");
	}	
}
class Tea implements HotDrink
{
	public void prepare()
	{
		System.out.println("Preparing Tea");
	}	
}
class Coffee implements HotDrink
{
  public void prepare()
	{
		System.out.println("Preparing Coffee");
	}
}
class StaticMethod 
{
	public static void main(String[] args) 
	{
		HotDrink hk1 = new Tea();
		HotDrink hk2 = new Coffee();
		HotDrink.expressPrepare();  //common for all
		hk1.prepare();
        hk2.prepare();		
	}
}
-------------------------------------------------------------------
interface Vehicle
{
	static void move()
	{
		System.out.println("Static method of Vehicle");
	}
}
class StaticMethod1 implements Vehicle
{
	
  	public static void main(String[] args) 
	{
	    Vehicle.move(); 
		move();   //error

		StaticMethod1.move(); //error

        StaticMethod1 sm = new StaticMethod1();   
		sm.move(); //error
	} 
}
---------------------------------------------------------------------
22-May-23
----------
Multiple Inheritance by using default method :
----------------------------------------------
Now as we know from java 8 onwards we can take default method inside an interface so can we still use multiple inheritance using interface concept?

Yes, Java language has provided a way through which even we can provide multiple inheritance using interfaces, where interfaces are containing default method as shown in the program below.

In order to differenciate between the member of super interfaces we have to use super keyword.
----------------------------------------------------------------------
interface I1
{
	default void m1()
	{
		System.out.println("Default method of I1 interface...");
	}
}
interface I2
{
	default void m1()
	{
		System.out.println("Default method of I2 Interface...");
	}
}
class MyClass implements I1,I2
{
   @Override
   public void m1()
	{
	   System.out.println("m1 method of MyClass");
		I1.super.m1();
		I2.super.m1();
	}
}
class MultipleInheritance 
{
	public static void main(String[] args) 
	{
		MyClass m = new MyClass();
		m.m1();
	}
}
----------------------------------------------------------------------
@FunctionalInterface Annotation :
---------------------------------------
If an interface contains only one abstract method then we can say that interface is Functional Interface.

Functional Interface can be defined by @FunctionInterface annotation.

Functional Interface may contain default method and static method but it must contain only one abstract method.

----------------------------------------------------------------------
Lambda Expression :
----------------------
It is a new feature introduced in java from JDK 1.8 onwards.
It is an anonymous function i.e function without any name.
In java it is used to enable functional programming.
It is used to concise our code as well as we can remove boilerplate code.
It can be used with functional interface only.
If the body of the Lambda Expression contains only one statement then curly braces are optional.
We can also remove the variables type while defining the Lambda Expression parameter.
If the lambda expression method contains only one parameter then we can remove () symbol also.

Independently Lamda Expression is not a statement.

It requires a target variable i.e interface reference

Lamda target can't be class or abstract class, it will work with interface only.
----------------------------------------------------------------------
@FunctionalInterface
interface Calculate
{
	int getSquare(int num);	
}

class Lambda 
{
	public static void main(String[] args) 
	{
		Calculate c = x -> x*x;

		System.out.println("Square is :"+c.getSquare(4));
	}
}
----------------------------------------------------------------------
@FunctionalInterface
interface Moveable
{
	void move();  //SAM (Single Abstract Method)
}
class Lambda1 
{
	public static void main(String[] args) 
	{
		Moveable car =  () -> System.out.println("Moving With Car......"); 		
		car.move();		

		Moveable bike = () -> System.out.println("Moving with Bike");
		bike.move();

		Moveable bus = () -> System.out.println("Moving with Bus");
		bus.move();
	}
}
----------------------------------------------------------------------
@FunctionalInterface
interface Calculate
{
	 void add(int a, int b, double c);  	
}
public class Lambda2 
{
	public static void main(String[] args) 
	{
		Calculate calc = (a,b,c)->   System.out.println("Sum is :"+(a+b+c));
	
		calc.add(12,24,14.24);
	}
}
---------------------------------------------------------------------
@FunctionalInterface
interface Length
{
	 int getLength(String str);   
}
public class Lambda3 
{
	public static void main(String[] args)     
	{
		Length l =  x -> x.length();
			 
		System.out.println("Length is :"+l.getLength("Hyderabad"));
	}
}
-----------------------------------------------------------------
23-May-23
---------
@FunctionalInterface
interface Length
{
	 int getLength(String str);
}
public class Lambda4 
{
	public static void main(String[] args) 
	{
		 Length l =  str -> str.length();		

        java.util.Scanner sc = new java.util.Scanner(System.in);
		System.out.print("Enter your Name :");
		String name = sc.nextLine();
		System.out.println("Length of "+name+" is :"+l.getLength(name));
	}
}
-----------------------------------------------------------------
<T> type parameter :
---------------------
-> It is known as Type parameter.

-> It is independent type which will accept all the Warpper     
   classes and userdefined class

Program :
---------
class Test<T>
{
	T obj;

	public void setObj(T obj) //setter
	{
		this.obj = obj;
	}

	public T getObj() //getter
	{
		return this.obj;
	}
}

public class Demo
{
	public static void main(String [] args)
	{
       Test<Integer> ti = new Test<Integer>();
	   ti.setObj(15);
	   System.out.println(ti.getObj());

	   Test<String> ts = new Test<String>();
	   ts.setObj("NIT");
	   System.out.println(ts.getObj());
      
	}
}
-----------------------------------------------------------------
Working with predefined functional interfaces :
------------------------------------------------------
In order to help the java programmer to write concise  java code in day to day programming java software people has provided the following predefined functional interfaces

1) Predicate<T>   
2) Consumer<T>
3) Function<T,R>
4) Supplier<T>

Note :-
-------
All these predefined functional interfaces are provided as a part of java.util.function package.


Predicate<T> funactional interface  :
-------------------------------------------
It is a predefined functional interface available in java.util.function sub package.

It contains an abstract method test() which takes type parameter <T> and returns boolean value. The main purpose of this interface to test one argument boolean expression.

@FunctionalInterface
public interface Predicate<T>   
{
  boolean test(T x);
}


Note :- Here T is a "type parameter" and it can accept any type of User defined class as well as  Wrapper class like Integer, Float, Double and so on.

We can't pass primitive type.

----------------------------------------------------------------
//Program to check whther a number is even or odd

import java.util.function.*;
import java.util.Scanner;
public class Demo
{
	public static void main(String [] args)
	{
       Predicate<Integer> p1 =  x -> x%2==0;
	   Scanner sc = new Scanner(System.in);
	   System.out.print("Enter a Number :");
	   int num = sc.nextInt();
	   System.out.println(num +" is even ?"+p1.test(num));
		      
	}
}
----------------------------------------------------------------
//Program to check whether a name starts with 'A' or not
import java.util.function.*;
import java.util.Scanner;
public class Demo
{
	public static void main(String [] args)
	{
       Predicate<String> p2 =  str ->str.startsWith("A");
	   
	   Scanner sc = new Scanner(System.in);
	   System.out.print("Enter your Name :");
	   String name = sc.next();
	  System.out.println("Is "+name+" starts with A :"+p2.test(name));
		      
	}
}
------------------------------------------------------------------
//Program to check whether a year is leap year or not
import java.util.function.*;
import java.util.Scanner;
public class Demo
{
	public static void main(String [] args)
	{
       Predicate<Integer> p3 =  num -> num%4==0;
	   
	   Scanner sc = new Scanner(System.in);
	   System.out.print("Enter A year:");
	   int year = sc.nextInt();
	  System.out.println("Is "+year+" leap year :"+p3.test(year));
		      
	}
}
-----------------------------------------------------------------
24-May-23
---------
Consumer<T> functional interface :
-----------------------------------------
It is a predefined functional interface available in java.util.function sub package.

It contains an abstract method accept() and returns nothing. It is used to accept the parameter value or consume the value.

@FunctionalInterface
public interface Consumer<T>
{
    void accept(T x);
 }
---------------------------------------------------------------------
Program on Consumer interface :
-------------------------------
import java.util.function.*;
public class Lambda7
{
	public static void main(String [] args)
	{
		 Consumer<Integer> printInt = x -> System.out.println(x);
         printInt.accept(15);

		 Consumer<String> printString = x -> System.out.println(x);
		 printString.accept("Naresh i Technology");

		 Consumer<Double> printDouble = x -> System.out.println(x);
		 printDouble.accept(78.90);

		  Consumer<Boolean> printBoolean = x -> System.out.println(x);
		 printBoolean.accept(true);

		   Consumer<Character> printChar = x -> System.out.println(x);
		   printChar.accept('A');

		   Consumer<Student> printStudent = x -> System.out.println(x);
           printStudent.accept(new Student());
	}
}

class Student
{
	@Override
	public String toString()
	{
		return "Consumer Student Object";
	}
}
----------------------------------------------------------------------
Function<T,R> functional interface :
-----------------------------------------
Type Parameters:
T - the type of the input to the function.
R - the type of the result of the function.

It is a predefined functional interface available in java.util.function sub package.It provides an abstract method apply that accepts one argument(T) and produces a result(R).

Note :- The type of T(input) and the type of R(Result) both will be decided by the user.

@FunctionalInterface
public interface Function<T,R>
{
   R apply(T x);        
 }
 --------------------------------------------------------------------
//Program to find out the square of the number

import java.util.function.*;
import java.util.Scanner;

public class Lambda8
{
	public static void main(String[] args) 
	{
		Function<Integer,Integer> fn =  x -> x*x;		

		Scanner sc = new Scanner(System.in);
		System.out.print("Enter the Number :");
		int num = sc.nextInt();
		System.out.println("The square of "+num+" is :"+fn.apply(num));       
	  
	}
}
---------------------------------------------------------------------
//Program to find out the length of the String
import java.util.function.*;
import java.util.Scanner;
public class Lambda9 
{
	public static void main(String[] args) 
	{
		Function<String, Integer> fn = str -> str.length();

		Scanner sc = new Scanner(System.in);
		System.out.print("Enter your Name :");
		String name = sc.next();
		System.out.println("Length of "+name+" is :"+fn.apply(name));
	}
}
----------------------------------------------------------------------
25-May-23
---------
Supplier<T> interface :
---------------------------
It is a predefined functional interface available in java.util.function sub package. It provides an abstract method get() which does not take  any argument but produces a value of type T

@FunctionalInterface
public interface Supplier<T>
{
   T get();
}
---------------------------------------------------------------------
import java.util.function.*;
class Student
{ 
    private int id;
    private String name;
    private String gender;
    private int age;
 
    public Student(int id, String name, String gender, int age) 
	{
        this.id = id;
        this.name = name;
        this.gender = gender;
        this.age = age;
    }
 
    @Override
    public String toString() 
		{
        return "Student [id=" + id + ", name=" + name + ", gender=" + gender + ", age=" + age + "]";
        }
}
		
public class Lambda10 
{
	public static void main(String[] args) 
	{
      Supplier<Student> stdSupplier = () -> new Student(1, "Virat", "Male", 24);
		
        Student std =  stdSupplier.get();
        System.out.println(std);       
	}
}
----------------------------------------------------------------------
This package contains two files :-

Employee.java
--------------
package com.ravi.supplier_demo;

public class Employee 
{
  private int employeeNumber;
  private String employeeName;
  private Double employeeSalary;
  
public Employee(int employeeNumber, String employeeName, Double employeeSalary) 
{
	super();
	this.employeeNumber = employeeNumber;
	this.employeeName = employeeName;
	this.employeeSalary = employeeSalary;
}

@Override
public String toString() {
	return "Employee [employeeNumber=" + employeeNumber + ", employeeName=" + employeeName + ", employeeSalary="
			+ employeeSalary + "]";
}
  
  
}

Lambda11.java
--------------
package com.ravi.supplier_demo;

import java.util.function.Supplier;

public class Lambda11 {

	public static void main(String[] args)
	{
		Supplier<Employee> sup = ()->
		{
			Employee e1 = new Employee(555, "Virat", 45000.90);
			return e1;
		};

		Employee employee = sup.get();
		System.out.println(employee);
	}

}
---------------------------------------------------------------------
What is marker interface ?
-------------------------------
An interface which does not contain any method and field is called marker interface. In other words, an empty interface is known as marker interface or tag interface.

It describes run-time type information about objects, so the JVM have additional information about the object. [like object is clonable OR object is serializable]

Example :
----------
public interface Drawable  //Marker interface
{
}

Note :-In java we have Clonable and Serializable are predefined marker interface.
----------------------------------------------------------------------
What is the advantage of writing constructor in the abstract class ?
--------------------------------------------------------------------
If my abstract class contains any properties then we can initialize those properties of abstract class with the help of sub class object by using super keyword.
---------------------------------------------------------------------
*What is difference between abstract class and interface ?
------------------------------------------------------------------
The following are the difference between abstract class and interface.

1) An abstract class can contain instance variables but interface variables are by default public , static and final


2) An abstract class can contain constructor but inside an interface we can't define constructor

3) An abstract class can contain instance and static blocks but inside an interface we can't define any blocks.

4) Abstract class can't refer Lambda expression but using Functional interface we can refer Lambda Expression.

5) An abstract class can have state (properties) of an object but interface can't have state of an object.	

6) We can write concrete method inside an abstract class but inside an interface we can't write concrete method, only abstract , default and static methods are allowed.
---------------------------------------------------------------------
                          OOPS ENDED
			  ----------
26-May-23
---------
Class loader sub system with JVM Architecture :
------------------------------------------------------
The three main components of JVM 

1) class loader sub system

2) Runtime Data Areas

3) Execution engine

class loader sub system internally performs 3 task

a) Loading     b) Linking      c) Initialization

Class loader sub system with JVM Architecture :
------------------------------------------------------
The three main components of JVM 

1) class loader sub system

2) Runtime Data Areas

3) Execution engine

class loader sub system internally performs 3 task

a) Loading     b) Linking      c) Initialization

Loading:
----------
In order to load the required .class file, JVM makes a request to class loader sub system. The class loader sub system follows delegation hierarchy algorithm to load the required .class files from different areas.

To load the required .class file we have 3 different kinds of class loader

1) Bootstrap class loader

2) Extension/Platform class loader

3) Application/System class loader

Bootstrap class Loader :-
----------------------------
It is responsible to load the required .class file from java API that means all the predfined classes (provided by java software people) .class file will be loaded by Bootstrap class loader.
It is the super class of Extension class loader as well as It has the highest priority among all the class loader.

Extension/Platform  class  Loader :-
--------------------------------------
It is responsible to load the required .class files from ext (extension) folder. Inside the extension folder we have  jar file(Java level zip file) given by some third party or user defined jar file.
It is the super class of Application class loader as well as It has more priority than Application class loader.


Note :- Command to create the jar file 

           jar cf MyJar.jar  FileName.class

Application/System class Loader :-
--------------------------------------
It is responsible to load the required .class file from class path level i.e Environment variable. It has lowest priority as well as It is the sub class of Extension/Platform class loader.

How Delegation Hierarchy algorithm works :-
---------------------------------------------------
Whenever JVM makes a request to class loader sub system to load the required .class file into JVM memory, first of all class loader sub system makes a request to Application class loader, Application class loader will delegate(by pass) the request to the Extension class loader, Extension class loader will also delegate the request to Bootstrap class loader.

Bootstrap class loader will load the .class file from lib folder(jrt.jar) and then by pass the request to extension class loader, Extension class loader will load the .class file from ext folder(*.jar) and by pass the request to Application class loader, It will load the .class file from environment variable into JVM memory. 

Note :- 
------
If all the class loaders are failed to load the .class file into JVM memory then we will get a Runtime exception i.e java.lang.ClassNotFoundException
---------------------------------------------------------------------
package com.ravi.supplier_demo;

public class Test 
{
	public static void main(String[] args) 
	{
	  System.out.println("Loaded BY :"+Test.class.getClassLoader());
	  System.out.println("Paraent of Application :"+Test.class.getClassLoader().getParent());

	}

}

/* getClassLoader() is a predefined method of class called Class available in java.lang package and it's return type is ClassLoader. 

getParent() is a predefined method of ClassLoader class in java available in java.lang package. It is an abstract class.
*/
----------------------------------------------------------------------
Linking :-
------------
verify :-
-------
It ensures the correctness of the .class files, If any suspicious activity is there in the .class file then It will stop the execution immediately by throwing an exception i.e java.lang.VerifyError.

There is something called ByteCodeVerifier(Component of JVM), responsible to verify the .class file i.e byte code. Due to this verify module JAVA is highly secure language. java.lang.VerifyError is the sub class of java.lang.linkageError

prepare:
---------
It will allocate the memory for all the static data member, here all the static data member will get the default values so if we have static int x = 100;
then for x we will get the default value i.e 0.

Resolve :-
-----------
All the symbolic references will be converted to direct references or actual reference.

javap -verbose  FileName.class

Note :- By using above command we can read the internal details of .class file.
-----------------------------------------------------------------
27-May-23
---------
Initialization :-
-----------------
In Initialization, all the static data member will get their actual (Original) value as well as if any static block is present in the class then the static block will be exceuted here.

static block :-
---------------
It is a very special block in java which will be executed automatically at the time of loading the .class file into JVM memory by class loader sub system.

Example:-

static
{

}

The main purpose of static block to initialize the static data member of the class.

static block will be executed only once because class loading is possible only once in java.

If we have multiple static blocks are present in a class then It will be executed according to order (Top to bottom).

static block will be executed before the main method.

We can't access static field before it is declared otherwise we will get illegal forward reference error but we can initialize in the static block before declaration.

[Initialization is possible but accessing is not possible]
----------------------------------------------------------------
//static block
class Foo
{
	Foo()
	{
		System.out.println("No Argument constructor..");
	}

	{
		System.out.println("Instance block..");
	}

	static
	{
		System.out.println("Static block...");
	}
}
public class StaticBlockDemo
{
	public static void main(String [] args)
	{
        new Foo(); //Foo class loaded here
		new Foo();
		System.out.println("Main Completed...");
		
	}
}

// javac StaticBlockDemo.java
// java StaticBlockDemo  //StaticBlockDemo.class is loaded

Note :- From the above program it is clear that static block is executed only once at the time of loading the .class file.
----------------------------------------------------------------
class Test
{
	static int x;

	static
	{
		x = 100;
	}
	
	static
	{
		x = 200;
	}

	static 
	{
		x = 300;
	}

	static
	{
		System.out.println("x value is :"+x);
	}
}
class StaticBlockDemo1   
{
	public static void main(String[] args) 
	{
		System.out.println(Test.x);

	}
}

Note :- Static blocks are executed according to the order.
         [top to bottom]
----------------------------------------------------------------
class Foo
{	
    static int x;
    static
	{
		
		System.out.println("x value is :"+x);
	}

}

class StaticBlockDemo2 
{
	public static void main(String[] args) 
	{
		 new Foo();
	}
}


Note : All static data members are initailzed with default values
-----------------------------------------------------------------
class Demo
{
	 final int a;	//blank final variable

	public Demo()
	{		
		a = 10;
		System.out.println(a);
	}
	
	
}	
public class  InstanceDemo
{
	public static void main(String[] args) 
		{		
	         Demo d1 = new Demo();	
	    }
}

points :
---------
1) blank final variable can't be initialized by default constructor

2) A user can initialize with the help of constructor , but it must be initialized to all the constructor defined inside the class.
----------------------------------------------------------------
class Demo
{
	// static blank final variable
	static final int a;	

	static
	{		
		a = 10;
	}
}	
public class  StaticBlockDemo3
{
	public static void main(String[] args) 
		{		
	         System.out.println("a value is :"+Demo.a);		
	    }
}
----------------------------------------------------------------
Interviwe Question :
--------------------
class  A   
{
	static 
	{
		System.out.println("A");
	}

	 
	{
		System.out.println("B");
	}

	A() 
	{
		System.out.println("C");
	}
}
class B extends A
{
	static 
	{
		System.out.println("D");
	}

	 
	{
		System.out.println("E");
	}

	B() 
	{
		System.out.println("F");
	}

}
public class StaticBlockDemo4 
{
	public static void main(String[] args) 
	{
		new B();
	}
}
----------------------------------------------------------------
//illegal forward reference

class Demo 
{
    static 
	{   
		i = 10;
        System.out.println(i); //before defining accessing is not poss
    }

    static int i;
}

public class StaticBlockDemo5
{

    public static void main(String[] args) 
	{
        new Demo();
	}
}
---------------------------------------------------------------
class Demo 
{
    static 
	{   
		i = 10; //before defining initialization is possible
    }

    static int i;
}

public class StaticBlockDemo6
{

    public static void main(String[] args) 
	{
		System.out.println(Demo.i);
	}
}
------------------------------------------------------------------*Can we execute a Java program without main method ?
---------------------------------------------------------------
 We can't execute a java program without main method, Upto jdk 1.6 it was possible to execute a java program without main method by writing the static block. From JDK 1.7 onwards now we can't execute java program without main method because JVM checks the presence of the main method before initializing the class.

Eg:-
class WithoutMain
{
        static
	{
	System.out.println("Hello world");
	System.exit(0);
	}
}
The above program was possible to execute upto JDK 1.6.
----------------------------------------------------------------
29-May-23
---------
How many ways we can load the .class file into JVM memory :
-----------------------------------------------------------------------
There are multiple ways to load the .class file into JVM memory.The following are the common examples :-

1) By using java tools [java command]
2) By using Constructor [Object creation]
3) By using(accessing) static variable and static method
4) By using Inheritance
5) By Reflection API

1) By using Java tools 
    javac Test.java 
    java Test [Load the Test.class file into JVM memoy]

 
2) By using Constructor [Object creation]

3) By Calling static variable and static method using class name.


Program on class loading by constructor and static Member
---------------------------------------------------------
class Demo
{
	static int x = 10;
	static
	{
		System.out.println("Static Block of Demo class Executed!!! :"+x);
	}
}
class ClassLoading 
{
	public static void main(String[] args) 
	{
	System.out.println("Main method executed");
	Demo d1 = new Demo(); //By Using Constructor
    System.out.println(Demo.x);  //By accessing static data member
	}
}
-----------------------------------------------------------------
4) By Using Inheritance
----------------------------   
When we create the Object for Sub class then, first of all super class .class file will be loaded then sub class .class file will be loaded.
Note :- Always Object is the first class to load into JVM memory

class A
{
	static
	{
		System.out.println("Static Block of super class A!!");
	}
}
class B extends A 
{
	static
	{
		System.out.println("Static Block of Sub class B!!");
	}
}
class InheritanceLoading 
{
	public static void main(String[] args) 
	{
		 new B();
	}
}
----------------------------------------------------------------
5) By Reflection API (Explicit class loading)
-------------------------------------------------

Java software people has provided a predefined class called "Class" available in java.lang package.

This class called Class contains a predefined static method forName(String className), through which we can load the required .class file into JVM memory dynamically.

It throws a checked exception i.e java.lang.ClassNotFoundException

Class.forName("com.ravi.Test");   

----------------------------------------------------------------
package com.ravi.supplier_demo;

class Student
{
  static
  {
	  System.out.println("Static block of student class");
  }
}

public class Test 
{	
	public static void main(String[] args) throws ClassNotFoundException 
	{
	  Class.forName("com.ravi.supplier_demo.Student");
	}

}

Note :- forName(String className) is a predefined method of class called Class available in java.lang package, this method return type is java.lang.Class is Reflation API.
----------------------------------------------------------------
*What is the drawback of 'new' keyword ?
                       OR
What is the difference between new keyword and newInstance() method?
                      OR
How to create the Object for the classes which are coming dynamically from the database or from some file.

The major drawback with new keyword is, It demands the class name at the begning or at the time of compilation so new keyword is not suitable to create the object for the classes which are coming from database or files at runtime.

In order to create the object for the classes which are coming at runtime from database or files, we should use newInstance() method available in java.lang.Class class.
----------------------------------------------------------------
class ObjectAtRuntime 
{	
   public static void main(String [] args) throws Exception
   {
      Object obj =   Class.forName(args[0]).newInstance();
      Class cls = obj.getClass();
	  String name = cls.getName();
      System.out.println("Object created for ="+name);
  	}
}

javac ObjectAtRuntime.java
java ObjectAtRuntime java.lang.String


/* getclass() is the method of Object class and its return type is Class, so we can apply any method of class called Class, getName() is the method of Class class.
*/
   
-----------------------------------------------------------------
package com.ravi.new_keyword_drawback;

class Student
{
	public void getMessage()
	{
		System.out.println("Hot summer!!!!");
	}
}

public class CreateObjectDynamically 
{
	public static void main(String[] args) throws InstantiationException, IllegalAccessException, ClassNotFoundException 
	{
		Object obj = Class.forName(args[0]).newInstance();
	    Student st = (Student) obj; //Downcasting
	    st.getMessage();
	    
	}

}
--------------------------------------------------------------
30-May-23
---------
* What is the difference between java.lang.ClassNotFoundException and 
java.lang.NoClassDefFoundError :
--------------------------------

java.lang.ClassNotFoundException :-
-----------------------------------------
It occurs when we try to load the required .class file at runtime by using Class.forName() statement or loadClass() of ClassLoader class and if the required .class file is not available at runtime then we will get an exception i.e java.lang.ClassNotFoundException

Note :- It does not have any concern at compilation time, at run time it will simply check whether the required .class file is available or not.
----------------------------------------------------------------
class Foo
{
	static
	{
		System.out.println("static block gets executed...");
	}
}
class ClassNotFoundExceptionDemo 
{
	public static void main(String[] args) throws ClassNotFoundException
	{
		Class.forName("Customer"); 
	}
}


Note :- Here, Customer.class file is not available so at the 
        time of execution, our class loaders are unable to 
	load the Customer.class as a result JVM will throw
	an exception i.e java.lang.ClassNotFoundException
---------------------------------------------------------------
java.lang.NoClassDefFoundError :
--------------------------------------
It occurs when the class was present at the time of COMPILATION but at runtime the required .class file is not available(manually deleted by user) then we will get an exception i.e java.lang.NoClassDefFoundError.

class Message
{
	public void greet()
	{
		System.out.println("Hello Everyone I hope you are fine..");
	}
}
public class NoClassDefFoundErrorDemo 
{
	public static void main(String[] args) 
	{
		Message m = new Message();
		m.greet();
	}
}



//After compilation delete the Message.class file manually.

Note :- java.lang.ClassNotFoundException does not have any concern with compile time, But in the case java.lang.NoClassDefFoundError class must be present at compilation time but it was deleated by the user after compilation
---------------------------------------------------------------
Runtime Data Areas :
-------------------------
a) Method Area :
-------------------
In this area all class level information is available. Actually the .class file is dumpped here hence we have all kinds of information related to class is available like name of the class, name of the immediate super class, package name, method name , variable name, static variable, all method available in that particular class and so on.

This method area returns type java.lang.Class class , this java.lang.Class class object can hold any .class file 
(Class c = AnyClass.class)

There is only one method area per JVM.

The following program explains how to get the complete information regarding the class.
----------------------------------------------------------------
This pacakge contains two files :
---------------------------------

Test.java
---------
package com.ravi.method_area;

public class Test 
{
  public void m1()
  {
	  
  }
  
  public void m2()
  {
	  
  }
  
  public void m3()
  {
	  
  }

   public void m4()
  {
	  
  }
}


ClassDescription.java
----------------------
package com.ravi.method_area;

import java.lang.reflect.Method;

public class ClassDescription {

	public static void main(String[] args) throws ClassNotFoundException 
	{
		          
		Class<?> cls = Class.forName(args[0]);
		System.out.println("Name of the class :"+cls.getName());
		System.out.println("Name of the Package :"+cls.getPackageName());
         
	    Method [] methods = cls.getDeclaredMethods();
	    int count =0;
	    for(Method x : methods)
	    {
	    	count++;
	    	System.out.println(x.getName());
	    }
        System.out.println("The total methods present are :"+count);
	}

	
}
---------------------------------------------------------------
Note :
--------
In the above program java.lang.Class has provided three methods 

getName() :- To get the name of the class

getPackageName() :- To get the package Name


Method [] getDeclaredMethods() :-  To get the complete method details(number of method)

The return type is Method array

Method is a predefined class available in java.lang.reflect sub pacakge 

Note :- We never import java.lang pacakge but java.lang.reflect is the sub package so we need to import.
----------------------------------------------------------------
31-May-23
----------
b) Heap memory :-
--------------------
It stores information regarding object and instance variables. All the objects are created as a part of HEAP memory so automatically all the instance variables are also the part of HEAP memory.

There is only one HEAP area per JVM.
----------------------------------------------------------------
Stack Memory :
--------------
For every thread, JVM creates a separate runtime stack. Each stack is created as a part of stack memory. All the local variables, parameter variables are also the part of stack memory.

Each entry in the stack is called Stack Frame, Each stack frame contains three parts
1) Local variable Array
2) Frame Data
3) Operand Stack
--------------------------------------------------------------
Garbage Collector :-
----------------------
In older language like C++, It is the responsibility of the programmer to allocate the memory as well as to de-allocate the memory otherwise there may be chance of getting OutOfMemoryError

But in Java a user is not responsible to de-allocate the memory that means memory allocation is the responsibility of user but  memory de-allocation is automatically done by Garbage Collector.

Garbage collection is the process of looking at heap memory, identifying which objects are in use and which are not, and deleting the unused objects (The object which does not contain any references).

It is an automatic memory management in java. JVM internally contains a thread called Garbage collector, It is responsible to delete the unused objects or the objects which are not containing any references in the heap memory.

Note :- GC uses an algorithm mark and sweep to make an un-used objects eligible for Garbage Collection.
--------------------------------------------------------------
There are 3 ways to make an Object eligible for Garbage Collector :
----------------------------------------------------------------
1) Assigning a null literal to reference variable

    Employee e1 = new Employee();
    e1 = null;

 2) Creating an object inside the method

      public void createObject()
      {
          Employee e2 = new Employee();
      }
Note :- Once the method execution is over automatically Object is eligible for Garbage Collector

3) Assigning new object to the Existing reference variable

     Employee e3 = new Employee();

     e3 = new Employee();

----------------------------------------------------------------
01-Jun-23
---------
HEAP AND STACK DIAGRAM PROGRAM WITH GARBAGE COLLECTOR :
--------------------------------------------------------
------------------
How to create a Heap and Stack diagram
                   OR
How to verify that how many objects are eligible for Garbage Collector
                   OR
Output of any complex to complex program
-------------------------------------------------------------
CustomerDemo.java
------------------
class Customer
{
	private String name;
	private int id;

	public Customer(String name , int id) //constructor
	{
		this.name=name;
		this.id=id;
	}

	public void setId(int id)  //setter  
	{
		this.id=id;
	}

	public int getId() //getter
	{
		return id;
	}
}

public class CustomerDemo
{
	public static void main(String[] args) 
	{
		int val=100;
		Customer c = new Customer("Ravi",2);

		m1(c);
		//GC [Here only 1 object is eligible 4 GC i.e 3000x]
		System.out.println(c.getId());
	}

	public static void m1(Customer cust)
	{
		cust.setId(5);
		cust = new Customer("Rahul",7);
		cust.setId(9);
		System.out.println(cust.getId());
	}
}  

// Output is 9 5
-------------------------------------------------------------
Employee.java
--------------
public class Employee
{
	int id=100;
	public static void main(String[] args) 
	{
		int val=200;

		Employee e1 = new Employee();

		e1.id=val;

		update(e1);	
		
		System.out.println(e1.id);

        Employee e2 = new Employee(); 

		e2.id=500;

		switchEmployees(e2,e1);		
		    //GC [2 objects i.e 2000x and 4000x are eligible 4 GC]
			System.out.println(e1.id);
		    System.out.println(e2.id);
	    } 
		
	 public static void update(Employee e)
	 {
        e.id=900;
		e=new Employee();
		e.id=400;
	 }
	 public static void switchEmployees(Employee e1,Employee e2)
	  {
		 int temp=e1.id;
		 e1.id=e2.id; 
		 e2= new Employee();
		 e2.id=temp;
	  }
   }
--------------------------------------------------------------
Sample.java
-----------
public class Sample
{	
	private Integer i1 = 900;
	public static void main(String[] args) 
	{
		Sample s1 = new Sample();

		Sample s2 = new Sample();

		Sample s3 = modify(s2);

		s1=null;
        //GC [4 objects 1000x,2000x, 5000x,6000x are elibile 4 GC]
		System.out.println(s2.i1);
	}
public static Sample modify(Sample s)
	{
		s.i1=9;
		s = new Sample();
		s.i1= 20;  
        System.out.println(s.i1);
		s=null;
		return s;
	}
}
--------------------------------------------------------------
02-Jun-23
---------
public class Test 
{
	Test t;
	int val;

	public Test(int val)
	{
		this.val = val;
	}

	public Test(int val, Test t)
	{
		this.val = val;
		this.t = t;
	}

	public static void main(String[] args) 
	{
		Test t1 = new Test(100);
		
		Test t2 = new Test(200,t1);

		Test t3 = new Test(300,t1);

		Test t4 = new Test(400,t2);

		t2.t = t3; //3000x
		t3.t = t4; //4000x
		t1.t = t2.t;//3000x
		t2.t = t4.t;//2000x

System.out.println(t1.t.val);
System.out.println(t2.t.val);
System.out.println(t3.t.val);
System.out.println(t4.t.val);
	}
	
}
//300 200 400 200
---------------------------------------------------------------------
class Alpha
{
	int val;
	static int sval = 200;
	static Beta b = new Beta();

	Alpha(int val)
	{
      this.val = val;
	}
}

public class Beta  
{
	public static void main(String[] args) 
	{
		Alpha am1 = new Alpha(9);
		Alpha am2 = new Alpha(2);

		Alpha []ar = fill(am1, am2);
		ar[0] = am1; //2000x
        System.out.println(ar[0].val);
        System.out.println(ar[1].val);
	}
	public static Alpha[] fill(Alpha a1, Alpha a2)
	{
		a1.val = 2;

		Alpha fa[] = new Alpha[]{a2, a1};

		return fa;
	}
}
----------------------------------------------------------------
* Why static method does not act upon instance variable?
---------------------------------------------------------
-> As we know all our static member is executed at the time of loading the .class file into JVM memory but on the other hand instance variable are created/initialized at the time creating the object, so at the time class loading instance variables are not available hence static method does not act upon instance variable.

The following two programs will not compile because we are trying to access the instance variable from static method.
---------------------------------------------------------
Demo.java
----------
class Demo 
{
	int var;
	public static void main(String[] args) 
	{
		System.out.println(var);
	}
}


StaticTest.java
----------------
class Test
{
	int var;

	public Test(int var)
	{
		this.var = var;
	}
	public static void access()
	{
		System.out.println(var);
	}
}
class StaticTest 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test(15);
		t1.access();
	}
}
---------------------------------------------------------------
PC Register :-
--------------
The Java Virtual Machine can support many threads of execution at once . Each Java Virtual Machine thread has its own pc (program counter) register.

In order to hold the current executing instruction of a thread we use PC register. For a single JVM we can have multiple PC Registers ecah PC register  refers to a particular thread.
---------------------------------------------------------------
03-Jun-23
---------
Native method stack :-
--------------------------
For every thread in java a seperate native stack is created. It stores the native method information.

native code means the code written in native languages like C, C++ .
In order to convert java into native code language we need native method libraries.

Interpreter :- 
---------------
JVM stands for Java Virtual Machine. It is a software in the form of Interpreter written in 'C' language. 

The main purpose of JVM to load and execute the .class file.JVM has a component called class loader subsystem responsible to load the required .class file as well as It allocates the necessary memory needed by the java program.

JVM executes our program line by line. It is slow in nature (Execution is slow) so java software people has provided a special compiler i.e JIT compiler to boost up the execution.

JIT compiler :-
-----------------
It stands for just in time compiler. It is the part of JVM which increases the speed of execution of a java program(boost up the execution).

It holds the frequently used instruction  or repeated method instruction and make it available at the time of executing java program directly so the execution will become faster.
-----------------------------------------------------------------
                EXCEPTION HANDLING
		-------------------

Exception :-
-------------
An exception is an abnormal situation or an unexpected situation in a normal execution flow.

Due to an exception our execution of the program will be disturbed first and then terminated permanently.

An exception occurs due to dependency, when one part of the program is dependent to another part in order to complete the task then there might be a chance of getting an exception.

EXCEPTION ALSO OCCURS DUE TO THE WRONG INPUT GIVEN BY THE USER.

Note :- Exception always occurs at runtime only.
-----------------------------------------------------------------
04-Jun-23
---------
Exception Hierarchy :-
--------------------
(Diagram is available in paint window = Exception_Hierarchy)

As a developer we are responsible to handle the exception whereas errors are taken care by System admin because error we can not recover where as Exception we can recover that means we can handle.
-----------------------------------------------------------------

Exception is the super class of all the exceptions we have in java whether it is a predefined Exception or userdefined Exception
-----------------------------------------------------------------
Criteria of Exception in java :
---------------------------------
Java software people has provided some predefined classes  for exception which are as follows :

1) int x = 10;
    int y = 0;
    int z = x/y; (Whenever we try to divide an int value by 0 then we will get ArithmeticExcepion)

    java.lang.ArithmeticException


 2) int [] a = {12, 89, 90};
     System.out.println(a[3]);

     java.lang.ArrayIndexOutOfBoundsException



 3) String x = null ;
     System.out.println(x.length()); 

     java.lang.NullPointerException



 4) String y = "Ravi";
     int z = Integer.parseInt(y);
     System.out.println(z);

     java.lang.NumberFormatException

-----------------------------------------------------------------
WAP in java that proves that Exception is the super class of all the Exceptions we have in java 

package com.arvi.communication;

public class Test {

	public static void main(String[] args) 
	{
		Exception e1 = new ArithmeticException("Dividing an int by zero");
		System.out.println(e1);
		
		Exception e2 = new ArrayIndexOutOfBoundsException();
		System.out.println(e2);	
		
	}
}

---------------------------------------------------------------
WAP in java that describes whenever an Exception encounter in our Program then our program will halt in the middle.

package com.ravi.basic;
import java.util.Scanner;
public class Test 
{
	public static void main(String[] args) 
	{
			System.out.println("Main method started....");  		  
			Scanner sc = new Scanner(System.in);
			System.out.print("Enter the value of a ");
			int a = sc.nextInt();
			
			System.out.print("Enter the value of b ");
			int b = sc.nextInt();
			
			int c = a/b;  //Program will halt here if b = 0	
			
			System.out.println("c value is :"+c);	
			System.out.println("Main method ended....");	
			sc.close();
		}
}

Note :- In the above program whenever the value of b is 0(zero) then our program will halt in the middle and it is an abnormal termination.
-----------------------------------------------------------------
The Object Orientation technology has provided the following keywords to work with Exception Handling.

1) try
2) catch
3) finally (try with Resources from Java 7)
4) throw
5) throws
-----------------------------------------------------------------
Key points Some points to remember :
--------------------------------
-> With try block we can write either catch block or finally block or both.
-> In between try and catch we can't write any kind of statement.
-> try block will trace our program line by line.
-> If we have any exception inside the try block, try block will automatically  create the appropriate Exception object and then throw the Exception Object to the nearest catch block.
-> In the try block whenever we get an exception the control will directly jump to the nearest catch block and the remaining code of try block will not be executed.
 -> catch block is responsible to handle the exception.
 -> catch block will only execute if there is an exception inside try block.
 ----------------------------------------------------------------

try :-
-----
Whenever our statement is error suspecting statement or Risky code then put that statement inside the try block.

The try block will trace the program line by line and if any exception occurs then It will automatically create the appropriate exception object and throw the exception object to the nearest catch block.

try block must be followed either by catch block or finally block or both. In between the try-catch we can't write any kind of statement.

The line in the try block where we got the exception after that line the remaining code in the try block will never be executed.

---------------------------------------------------------------------------------------
catch :
-------
The main purpose of catch block to handle the exception which is thrown by try block.

The catch block will only execute if there is an exception inside the try block otherwise catch block will not be executed.
-----------------------------------------------------------------
package com.ravi.basic;

import java.util.Scanner;

public class TryDemo {

	public static void main(String[] args)  
	{		
		   System.out.println("Main method started....");	       
		    try
		    {
		    	   Scanner sc = new Scanner(System.in);
				   System.out.print("Enter the value of x :");
				   int x = sc.nextInt();

				   System.out.print("Enter the value of y :");
				   int y = sc.nextInt();

				   int z = x/y;  
				   System.out.println("z value is :"+z);
				   System.out.println("Inside try Block");
		    }		   
		    catch(Exception e)
		    {
		    	System.out.println("Inside catch Block");
		    	System.err.println(e);
		    } 
		    
		   System.out.println("Main method ended....");
	}
}

Note :- In the above program even we have an arithmetic exception but due to the support of try-catch (Exception handling mechanism) our execution of the program will be completed normally.
It would not be an abnormal termination.
-----------------------------------------------------------------

package com.ravi.basic;

import java.util.Scanner;

public class CustomerDemo 
{
	public static void main(String[] args) 
	{
		try
		{
			System.out.println("Welcome User! Welcome to my application..");
			Scanner sc = new Scanner(System.in);
			
			System.out.print("Enter the value of x :");
			int x = sc.nextInt();
			
			System.out.print("Enter the value of y :");
			int y = sc.nextInt();
			
			int z  = x /y;
			System.out.println("Z value is :"+z);
			sc.close();
			
		}
		catch(Exception e)
		{
		  System.err.println("Sir don't put zero ");	
		}
		
		System.out.println("Thank you 4 visiting...");
	}
}
Note :- The main purpose of exception handling to provide user-friendly messages to our client as shown in the above program.
-----------------------------------------------------------------
05-Jun-23
----------
Throwable class methods :
---------------------------
1) getMessage() :- Predefined method of Throwable class which provides only message details from the exception. We should write this getMessage() in the S.o.p statement.

2) printStackTrace() :- Predefined method of Throwable class which provides complete details like package name, class name , exception message, file name, method name and exception location (line number)

PrintStackTrace.java
---------------------
package com.ravi.basic;

public class PrintStackTrace 
{
	public static void main(String[] args) 
	{
		System.out.println("Main method started...");		
		try
		{
			String x = "Ravi";
			int y = Integer.parseInt(x);
			System.out.println(y);	
		}
		catch(Exception e)
		{
			e.printStackTrace(); //For complete Exception details
			System.out.println("---------------------------");
			System.err.println(e.getMessage()); //only for Exception message				
		}
		System.out.println("Main method ended...");		

	}

}
-----------------------------------------------------------------
Working with Specific exception :
--------------------------------------
In order to the handle the exception in the catch block we can write Exception super class or we can also write appropriate type of exception like ArithmeticException, ArrayIndexOutOfBoundsException and so on.
-----------------------------------------------------------------
package com.ravi.basic;
public class SpecificException 
{
	public static void main(String[] args) 
	{
		try
		{
			int a [] = {12,23,34,45};
			System.out.println(a[4]); //new ArrayIndexOutOfBoundsException();
		    System.out.println("Inside try");
		}
		catch(ArrayIndexOutOfBoundsException e)  //Specific Exception class
		{
		  System.err.println("Array is out of limit");		 
		}	
		System.out.println("Main is completed!!!");		
	}
}
-----------------------------------------------------------------
Working with Infinity and undefined with integral and floating point literal :
-------------------------------------------------------------------------------------
Whenever we divide a number by 0(zero) i.e integral Literal then in both the cases i.e 10/0(Infinity) and 0/0 (Undefined), we will get java.lang.ArithmeticException and our program will halt in the middle because java software people has not provided any final(constant) variable support as a part of integral literal to represent infinity and undefined.

On the other hand when we divide a number by 0.0 i.e with floating point literal then for both the cases i.e 10/0.0 (Infinity) and 0/0.0 (undefined) java software people has provided static and  final (constant) variables i.e POSITIVE_INFINITY, NEGATIVE_INFINITY and NaN (Not a number) to handle this situation and our program will not halt in the middle.
-----------------------------------------------------------------
package com.ravi.basic;

public class InfinityFloatingPoint 
{
   public static void main(String[] args) 
   {
	    System.out.println("Main method started");
	   
		System.out.println(-10/0.0); //-Infinity
		System.out.println(10/0.0);  //Infinity
		System.out.println(0/0.0);   //NaN
		
		System.out.println(10/0); //java.lang.AE (HALT)
		System.out.println(0/0);  //java.lang.AE (HALT)	
		
		System.out.println("Main method ended");
	}
}
----------------------------------------------------------------
Multiple try-catch :
---------------------
According to our requirement we can provide multiple try-catch for different kinds of exception.

MultipleTryCatch.java
---------------------

package com.ravi.basic;
public class MultipleTryCatch 
{
	public static void main(String[] args) 
	{
		System.out.println("Main started..");		
		try
		{
		   int a = 100, b = 0,c;
		   c = a/b;  // new ArithmeticException();
		   System.out.println("c value is :"+c);
		}
		catch(ArithmeticException e)
		{
		  System.err.println("Divide by zero problem....");	
		  e.printStackTrace();
		}		
		System.out.println("........................");
		try
		{
			int x[] = {12,90};
			System.out.println(x[2]);
		}
		catch(ArrayIndexOutOfBoundsException e)
		{
		   System.err.println("Array is out of limit...");	
		   System.out.println(e.getMessage());
		}
		System.out.println("Main completed..");
	}
}
----------------------------------------------------------------
Multiple catch blocks with a single try :
-------------------------------------------
We should always take multiple catch blocks with a single try block for providing more clearity regarding the exception so the user will get the 
appropriate exception message and accordingly the user can solve the exceptions one by one.

While working with multiple catch block the super class catch block must be the last catch block otherwise we will get a compilation error that is unreachable code.

In the try block if we have multiple exceptions then try block will entertain only the first exception, after solving first exception then we will get second exception message and so on.
-----------------------------------------------------------------
package com.ravi.basic;
public class MultyCatch 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Started...");		
		try
		{
			int a=10,b=0,c;
			c=a/b;
			System.out.println("c value is :"+c);	
			
			int x[] = {12,78,56};
			System.out.println(x[5]);
		}	
		
		catch(ArrayIndexOutOfBoundsException e1)
		{
			System.err.println("Array is out of limit...");
		}
		catch(ArithmeticException e1)
		{
			System.err.println("Divide By zero problem...");
		}
		catch(Exception e1)
		{
			System.err.println("Super Catch block");
			e1.printStackTrace();
		}	
		
			
		System.out.println("Main Ended...");
	}
}
-------------------------------------------------------------
finally block :
---------------
The finally block is used to handle the resources. According to software engineering the resources are memory creation, buffer creation, Opening of a database, opening of a file, network resources and so on, So we need to handle them carefully.

finally is a block which is guaranted for execution whether an exception has been thrown or not.

We should write all the closing statements inside the finally block so finally block will execute and it will close all the resources.

if we use the combination of try and finally then only the resources will be handled but not the exception on the other hand if we use the combination of try and catch and finally the exception and resources both will be handled.
--------------------------------------------------------------
package com.ravi.basic;

import java.util.Scanner;

public class FinallyBlock 
{
	public static void main(String[] args)
	{	
		
		try
		{				
			System.out.println("Main method started");
			int a = 10;
			int b = 0;
			int c = a/b;  // new ArithmeticException();  HALT
			System.out.println("c value is :"+c);			
		}
		finally
		{			    
			System.out.println("Finally block will be executed....");
		}
		
        System.out.println("Main method completed");
	}
}
--------------------------------------------------------------
package com.ravi.basic;

public class FinallyWithCatch 
{
	public static void main(String[] args) 
	{		
		try
		{
			String x = null;
			System.out.println(x.length());
			
		}
		catch(NullPointerException e)
		{		
			System.err.println("Exception is handled here");
		}
		finally
		{
		   System.out.println("Resources will be handled here!!");	
		   
		}
		System.out.println("Main method ended!!!");
	}
}
-------------------------------------------------------------
Note :- While working with finally block it is the responsibility of the user to close the resources manualy by writing finally block.

To avoid this problem from java 1.7 onwards try with resources came into picture.

07-Jun-23
----------
try with resources :
-----------------------
As we know if we open any resource as a part of try block then we should compulsory close the resource as a part of finally block till JDK 1.6.

The problems with this approach are 
	a) Programmer is responsible to close the resource inside the finally block so it increases the complexcity.

	b) It will increase the length of the code because compulsory we need to write the finally block in our program.
	
	c) We need to declare the resources outside of the try block otherwise it will become block level variable.


From JDK 1.7 onwards java software people has introduced a new concept called try with resources to automatically close the resources.

The main advantage of try with resources is whatever the resources we will open as a part of try block it will be automatically closed when the control reaches to end of the try block either normally or abnormally so as a user we need not to close the resources explicity hence the complexcity of the programming will be reduced.

Every resource class must implement AutoCloseable interface directly or indirectly available in java.lang package which contains an abstract method close().

Note :- The conclusion is with the help of try with resources we need not to close the resources in the finally block, the resources will be automatically closed at the time of executing the try block irrespective of Exception.
-------------------------------------------------------------

The following program contins 3 files :
------------------------------------------
NetworkResource.java
--------------------
package com.nit.try_resources;

public class NetworkResource implements AutoCloseable {

	@Override
	public void close() throws Exception 
	{
		System.out.println("Network Resource closed successfully.....");
	}

}

IOResource.java
---------------
package com.nit.try_resources;

import java.io.Closeable;
import java.io.IOException;

public class IOResource implements Closeable 
{
	@Override
	public void close() throws IOException 
	{
		System.out.println("IO Resource closed successfully.....");

	}

}

ResourceHandling.java
----------------------

package com.nit.try_resources;

public class ResourceHandling 
{
	public static void main(String[] args) throws Exception
	{
		System.out.println("Main method started!!!!");
		NetworkResource nw = new NetworkResource();		
		IOResource ir = new IOResource();
		
		try(nw;ir)
		{
			System.out.println("try block started");
			System.out.println(10/0);
		}
		catch (ArithmeticException e) 
		{
			System.out.println("catch block started");
			System.err.println(e.getMessage());
		}
        System.out.println("Main method ended!!!");
	}

}
--------------------------------------------------------------
TryWithResorce.java
-------------------
package com.ravi.try_with_resource_1;

import java.util.Scanner;

public class TryWithResource
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		try(sc)
		{			
			System.out.print("Enter Your Name :");
			String name = sc.nextLine();
			System.out.println("Your Name is :"+name);
			System.out.println(10/0);
		}
		catch(Exception e)
		{
			System.err.println("Divide BY zero problem");
			
		}
		System.out.println("Reached Destination");
	}
}
Note :- Scanner class must be closed so here by using try with resources we need not to close the Scanner class manualy because it implements java.io.Closeable interface.
--------------------------------------------------------------

-------------------------------------------------------------
Exception propagation :-
--------------------------
Whenever we call a method and if the the callee method contains any kind of exception and if callee method doesn't contain any kind of exception handling mechanism (try-catch) then JVM will propagate the exception to caller method for handling purpose. This is called Exception Propagation.

If the caller method does not contain any exception handling mechanism then JVM will terminate the method from the stack frame hence the remaining part of the method(m1 method) will not be executed even if we handle the exception in another caller method like main.

If any of the the caller method does not contain any exception handling mechanism then exception will be handled by JVM, JVM has default exception handler which will provide the exception message and terminates the program abnormally.
--------------------------------------------------------------
ExceptionPropagation.java
--------------------------
package com.ravi.advanced;
public class ExceptionPropagation 
{
	public static void main(String[] args)
	{
	    System.out.println("main started!!!");
	    try
		{
			m1();
		}
		catch(Exception e)
		{
			System.out.println("Handled in main");
		}
	    System.out.println("main Ended!!!");
	}
	
	public static void m1()
	{
		System.out.println("m1 started!!!");
		   m2();
	    System.out.println("m1 Ended!!!"); //This line will not be executed
	}
	
	public static void m2()
	{
		System.out.println(10/0);
	}
}
--------------------------------------------------------------
Nested try block :
--------------------
In java it is possible to define one try block inside another try block is called Nested try block as shown below

try     //outer try
{
    statement1;
      
      try  //inner try
      {
          statement2;
      }
      catch(X e) //inner catch
      {
      }
}
catch(X e) //Outer catch
{
}

Note :-
-------
The inner try block will only execute if we don't have any exception in the outer try block.

If we have an exception in the inner try block then the inner catch block will be executed, in the same way if we have an exception in the outer try block then outer catch block would be executed.

--------------------------------------------------------------
package com.ravi.basic;

public class NestedTryBlock {

	public static void main(String[] args) 
	{		
	      try  //outer try
	      {
	    	    String x = null;
	    	    System.out.println("It's length is :"+x.length());
	    	        
		    	  try  //inner try
		    	  {
		    		 String y = "Ravi"; 
		    		 int z = Integer.parseInt(y);
		    		 System.out.println("z value is :"+z);	    				    		  
		    	  }
		    	  catch(NumberFormatException e)
		    	  {
		    		System.err.println("Number is not in a proper format");  
		    	  }
	      }
	      catch(NullPointerException e)
	      {
	    	  System.err.println("Null pointer Problem"); 	    	 
	      }	      
	}
}
-------------------------------------------------------------
Defining the try-catch inside the catch block :
----------------------------------------------------
It is possible to define try-catch block inside the catch block but the execution of try-catch defined inside the catch block is only possible if the control enters inside the catch block.

TryWithCatchInsideCatch.java
----------------------------

package com.ravi.basic;

public class TryWithCatchInsideCatch 
{
	public static void main(String[] args)
	{
		try
		{
			String x = null;
			System.out.println(x.toUpperCase());			
		}
		catch(NullPointerException e)
		{
			System.err.println("Null Pointer Problem raised..");
			
			try
			{
				System.out.println(10/0);
			}
			catch(ArithmeticException e1)
			{
			  System.err.println("Divide by zero problem");	
			}
			finally
			{
				System.out.println("Resource Handler");
			}
		}
	}

}
--------------------------------------------------------------
08-Jun-23
---------
Working with return statement inside try-catch and finally block :
--------------------------------------------------------------
If we write try-catch block inside a method and that method is returning some value then we should write return statement in both the places i.e inside the try block as well as inside the catch block.

We can also write return statement inside the finally block only, if the finally block is present.
--------------------------------------------------------------
package com.ravi.advanced;
public class ReturnExample
{
    public static void main(String[] args)
    {
        System.out.println(methodReturningValue());
    }    
	
	
	
	static int methodReturningValue()
    {
        try
        {
            System.out.println("Try block");
            System.out.println(10/0); 
            return 15;  
            
        }
        catch (Exception e)
        {
            System.out.println("catch block");  
            return 15;  
           
        }
        finally
        {
        	System.out.println("Finally block");             
        	
        }		
	   
    }
}
--------------------------------------------------------------
*What is the difference between Checked Exception and Unchecked Exception?
-------------------------------------------------------------------------------------------
Checked Exception :
----------------------
In java some exceptions are very common exceptions are called Checked excption here compiler takes very much care and wanted the clearity regarding the exception by saying that by using this code you may face some problem at runtime and you did not report me how would you handle this situation at runtime are called Checked exception, so provide either try-catch or declare the method as throws.

Eg:
---
FileNotFoundException, IOException, InterruptedException,ClassNotFoundException, SQLException and so on

Unchecked Exception :-
--------------------------
The exceptions which are rarely occurred in java and for these kinds of exception compiler does not take very much care are called unchecked exception.

Unchecked exceptions are directly entertain by JVM because they are rarely occurred in java.

Eg:
---
ArithmeticException, ArrayIndexOutOfBoundsException, NullPointerException, NumberFormatException, ClassCastException, ArrayStoreException and so on.
------------------------------------------------------------------------------------------
When to provide try-catch or declare the method as throws :-
---------------------------------------------------------------------
We should provide try-catch if we want to handle the exception by own as well as if we want to provide user-defined messages to the client but on the other hand we should declare the method as throws when we are not interested to handle the exception and try to send it to the JVM for handling purpose. 

Note :- It is always better to use try catch so we can provide appropriate user defined messages to our client.
--------------------------------------------------------------
Why compiler takes very much care regarding the checked Exception ?
------------------------------------------------------------------------------
As we know Checked Exceptions are very common exception so in case of checked exception handling is compulsory because checked Exception depends upon other resources as shown below.

IOException  (we are depending upon System Keyboard )
FileNotFoundException(We are depending upon the file)
InterruptedException (Thread related problem)
ClassNotFoundException (class related problem)
SQLException (SQL related or database related problem)
--------------------------------------------------------------
09-Jun-23
---------
Types of exception in java :
-------------------------------
Exception can be divided into two types :

1) Predefined Exception OR Built-in Exception

2) Userdefined Exception OR Custom Exception

Predefined Exception :-
-------------------------
The Exceptions which are already defined by Java software people for some specific purposes are called predefined Exception or Built-in exception.
Ex :
----
IOException, ArithmeticException and so on


Userdefined Exception :-
---------------------------
The exceptions which are defined by user according to their own use and requirement are called User-defined Exception.

Ex:-
----
InvalidAgeException, GreaterMarksException

------------------------------------------------------------------
Steps to create userdefined exception :
------------------------------------------
In order to create user defined exception we should follow the following steps.

1) A userdefined exception class must extends either Exception(Checked Exception) Or RuntimeException(Unchecked Exception) as a super class.

    a) If our userdefined class extends RuntimeException that menas we are creating UncheckedException

    b) If our userdefined class extends Exception that menas we are creating checkedException and exception handling is compulsory here.

2) The userdefined class must contain No argument constructor as well as parameterized construtor(in case we want to pass some userdefined message).

   We should take No argument constructor if we don't want to send any message where as we should take parameterized constructor with super keyword if we want to send the message to the super class.
------------------------------------------------------------------
* What is difference between throw and throws :-
------------------------------------------------
throw :
--------
In case of predefined exception try block is responsible to create the exception object and throw the exception object to the nearest catch block but it works with predefined exception only.

If a user wants to throw an exception based on his own requirement and specification by using userdefined exception then we should write throw keyword to throw the user defined exception object explicitly. (throw new InvalidAgeException())

throws :- 
---------
In case of checked Exception if a user is not interested to handle the exception and wants  to throw the exception to JVM, wants to skip from the current situation then we should declare the method as throws.
---------------------------------------------------------------------------------
Note :-While working with userdefined exception if  we extend our userdefined exception class from RuntimeException i.e Unchecked Exception then we need not to put try-catch or declare the method as throws for "throw keyword statement". (Handling is not compulsory)

On the other hand, if we extend our userdefined exception class from Exception then compulsory we need to write "throw keyword statement"
in the protection of try-catch or we should declare the method as throws otherwise we will get a compilatioin error.
------------------------------------------------------------------
//Program to create userdefined Checked Exception
--------------------------------------------------
InvalidAgeException.java
--------------------------
package com.ravi.user_defined_exception;

//Checked Exception 
@SuppressWarnings("serial")
public class InvalidAgeException extends Exception 
{  	

   public InvalidAgeException()
   {
	   
   }
   
   public InvalidAgeException(String msg)
   {
	   super(msg);
   }
}

UserdefinedCheckedException.java
---------------------------------
package com.ravi.user_defined_exception;

import java.util.Scanner;

public class UserdefinedCheckedException 
{
	public static void main(String[] args) 
	{
		System.out.println("Main method started");
	  try
	  {
		  Scanner sc = new Scanner(System.in);
	      System.out.print("Enter your Age :");	
	      int age = sc.nextInt();
	      if(age < 18)
	      {
	    	  throw new InvalidAgeException("Age is invalid!!");
	      }
	      else
	      {
	    	  System.out.println("Welcome to vote");
	      }
	  }
	  catch(Exception e)
	  {
		  e.printStackTrace();
	  }
	  System.out.println("Main method ended");      

	}

}
------------------------------------------------------------------
//Program to create userdefined Un-Checked Exception

GreaterMarksException.java
----------------------------
package com.ravi.user_defined_exp;

//unchecked user-defined Exception
@SuppressWarnings("serial")
public class GreaterMarksException extends RuntimeException 
{
    public GreaterMarksException()
    {    	
    }
    
    public GreaterMarksException(String msg)
    {
    	super(msg);
    }
}

UserdefinedUncheckedException.java
------------------------------------
package com.ravi.user_defined_exp;

import java.util.Scanner;

public class UserdefinedUncheckedException {

	public static void main(String[] args) 
	{
		System.out.println("Main Started");
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter your Marks :");
		int marks = sc.nextInt();
		validateMarks(marks);
        sc.close();
        System.out.println("Main Ended");
	}
	
	public static void validateMarks(int marks)
	{
		try
		{
			if(marks > 100)
			{
				throw new GreaterMarksException("Invalid Marks ");
			}
			else
			{
				System.out.println("Your Marks is :"+marks);
			}
		}
		catch(GreaterMarksException e)
		{
			System.err.println("Your Marks is greater than 100");
		}
	}

}
------------------------------------------------------------------
Some important rules to follow :
---------------------------------
a) If the try block does not throw any checked exception then in the corrosponding catch block we can't throw checked exception.It will generate compilation error i.e "exception never thrown from the corrosponding try statement"

Example :-

try
{
  //try block is not throwing any checked Exception
}
catch(IOException e) //Error
{

}


b) If the try block does not throw any exception then in the corrosponding catch block we can write Exception , Throwable because both are the super classes for all types of Exception whether it is checked or unchecked
------------------------------------------------------------------
16-Jun-23
----------
Array in java :
---------------
An ordinary variable can hold only one value at a time.

Example:- int x = 10;

But if we want to hold multiple values with contiguous memory location then we should go with array concept.

*An array is a collection of homogeneous type of element. It can hold multiple values of same type. In Java due to upcasting concept, array can also hold hetrogeneous types of data.

Example :-

Object [] obj = {12,"Ravi",null, 90.56};   //Hetrogeneous

int []x = {12,78,45,34,90}; //Homogeneous

In Java array is an object so it is created as a part of HEAP memory which can hold primitive types as well as reference type. Since array is an object, it is created during runtime.

In order to find out the length of an array variable we can use length property or length variable of an array.

Array stores the element in index wise where the index will always starts from 0. 

In Java, there are two types of arrays:

1) Single OR One Dimensional Array.
2) 2D OR Multi-Dimensional Array.


In Java we can create single dimensional array by using following ways :-

    Example 1 :
    -------------
    int [] x = {12,23,34,45};

    Note :-We should use above approach when size of the array and values of the array are already known.

    Example 2 :
    -------------
    int [] y = new int[5];
    


    Example 3 :
    -------------
    int [] z = new int[]{10,20,30};
----------------------------------------------------------------
Technical Programs on Array :
----------------------------------
ArrayDemo1.java
--------------------
//Given an array of integers, return true if 15 appears as either the first or last element in the array. The array will be length 1 or more.

package com.ravi.array_basic;

public class ArrayDemo1 {

	public static void main(String[] args) 
	{
		int []x = {19,78,45,89,19};
		
        boolean b = firstLast(x);
        System.out.println("15 is available :"+b);
	}
	
	public static boolean firstLast(int[] nums) 
	{
		if (nums[0] == 15 || nums[nums.length-1] == 15) 
			return true;
		else 
			return false;
	}
}
---------------------------------------------------------------
ArrayDemo2.java
----------------
//Given an array of integers, return true if the array length is 1 or more,and the first element and the last elements both are equal.

package com.ravi.array_basic;

public class ArrayDemo2 
{
	public static void main(String[] args)
	{
		int []x = {12,12,90,89,56,12};
		boolean b = sameFirstLast(x);
		System.out.println(b);
	}

	public static boolean sameFirstLast(int[] nums)
	{
		if (nums.length >= 1 && nums[0] == nums[nums.length-1]) 
			return true;
		else
		   return false;
	}

}
----------------------------------------------------------------
ArrayDemo3.java
---------------
//Given 2 arrays of integers, a and b, return true if they have the same first element or they have the same last element. Both arrays will be length 1 or more.

package com.ravi.array_basic;

public class ArrayDemo3 
{
	public static void main(String[] args) 
	{
		int []x = {55,12,78,45,89,75};
		int []y = {56,12,78,45,89,75};
		boolean b = commonEnd(x, y);
		System.out.println(b);
	}

	public static boolean commonEnd(int[] a, int[] b) 
	{
		if (a[0] == b[0] || a[a.length-1] == b[b.length-1]) 
			return true;
		else
		    return false;
	}

}
---------------------------------------------------------------
ArrayDemo4.java
---------------
//Given an array of integers length 3, return the sum of all the elements. 

package com.ravi.array_basic;

public class ArrayDemo4 {

	public static void main(String[] args) 
	{
		int []x = {15,15,200};
		int total = sum3(x);
		System.out.println("Sum is :"+total);
	}
	
	public static int sum3(int[] nums) 
	{
		return nums[0] + nums[1] + nums[2];
	}


}
----------------------------------------------------------------
ArrayDemo5.java
---------------
//Given an array of integers length 3, return an array with the elements "rotated left" so {1, 2, 3} will become  {2, 3, 1}.

package com.ravi.array_basic;
import java.util.Arrays;

public class ArrayDemo5 
{
	public static void main(String[] args) 
	{
		int []x = {1,2,3};

		int []arr = rotateLeft3(x);
		
		System.out.println(Arrays.toString(arr));
	}
	
	public static int[] rotateLeft3(int[] nums) 
	{
       nums[0] = 2;
       nums[1] = 3;
       nums[2] = 1;
       return nums;
	}


}
Note :- Arrays claass has provided a predefined method called toString() through which we can converty our arrayu into String format and nooo we can print using s.o.p statement
----------------------------------------------------------------
ArrayDemo6.java
----------------

//Given an array of integers length 3, return a new array with the elements in reverse order, so {1, 2, 3} becomes {3, 2, 1}.

package com.ravi.array_basic;

import java.util.Arrays;

public class ArrayDemo6 
{
	public static void main(String[] args) 
	{
		int []x = {11,22,33};
		int []y = reverse3(x);
		System.out.println("Reverse is :"+Arrays.toString(y));
	}

	public static int[] reverse3(int[] nums) 
	{ 
		int[] myArray = new int[3];	 
	    myArray[0] = nums[2]; 
	    myArray[1] = nums[1]; 
	    myArray[2] = nums[0]; 
	    return myArray;
	}

}
----------------------------------------------------------------
ArrayDemo7.java
----------------
//Given an array of integers length 3, figure out which is larger, the first or last element in the array, and set all the other elements to be that value. Return the changed array.

package com.ravi.array_basic;

import java.util.Arrays;

public class ArrayDemo7 {

	public static void main(String[] args) 
	{
		int []x = {45,222,138};
		
		int []y = maxEnd3(x);
		System.out.println("Return larger value :"+Arrays.toString(y));
	}
	
	   public static int[] maxEnd3(int[] nums) 
	   {
		int larger = Math.max(nums[0], nums[2]);  //max is Math class static method
		System.out.println("larger value is :"+larger);
		nums[0] = larger;
		nums[1] = larger; 
		nums[2] = larger; 
		return nums;
	   }

}

----------------------------------------------------------------
ArrayDemo8.java
----------------
//Given an array of integers, return the sum of the first 2 elements in the array. If the array length is less than 2, just sum up the elements that exist, return 0 if the array is having length 0.

package com.ravi.array_basic;

public class ArrayDemo8 {

	public static void main(String[] args) 
	{
		int []x = {15,16};
		int sum = sum2(x);
		System.out.println("Sum is :"+sum);
	}

	public static int sum2(int[] nums) 
	{ 
		if (nums.length == 1)
		    return nums[0];
		
		if (nums.length == 0) 
			return 0;
		else
		    return nums[0] + nums[1];
	}

}
---------------------------------------------------------------
17-Jun-23
---------
//Given 2 integer arrays, a and b, each length is 3, return a new array length 2 containing their middle elements.

package com.ravi.array_basic;

import java.util.Arrays;

public class ArrayDemo9 
{
	public static void main(String[] args) 
	{
		int []x = {65,99,78};
		int []y = {15,98,99};
		
		int []arr = middleWay(x, y);
		System.out.println("Middle element is :"+Arrays.toString(arr));
	}
	
	public static int[] middleWay(int[] a, int[] b) 
	{
		int[] myArray = new int[]{a[1], b[1]};  
		return myArray;
	}


}
---------------------------------------------------------------
//Given an array of integers, return a new array length 2 containing the first and last elements from the original array. The original array will be length 1 or more.

package com.ravi.array_basic;

import java.util.Arrays;

public class ArrayDemo10 {

	public static void main(String[] args) 
	{
		int []x = {12};
		int []y = makeEnds(x);
		System.out.println("Array value is :"+Arrays.toString(y));
		
		int [] p= {12,89,78,34,99};
		int []q = makeEnds(p);
		System.out.println("Array value is :"+Arrays.toString(q));		
	}
	
	public static int[] makeEnds(int[] nums) 
	{ 
		int[] myArray = new int[2];
		
		if (nums.length == 1) 
		{
			myArray[0] = nums[0]; 
			myArray[1] = nums[0];
		} 
		else 
		{
			myArray[0] = nums[0];
			myArray[1] = nums[nums.length-1];
		}
		return myArray;
	}
}
---------------------------------------------------------------
//Given an integer array length 2,return true if it contains a number 2 or 3. 

package com.ravi.array_basic;

public class ArrayDemo11 {

	public static void main(String[] args) 
	{
		int []x = {2,5};
	    boolean b = has2Or3(x);
	    System.out.println("Array contains 2 or 3 :"+b);
	}
	
	public static boolean has2Or3(int[] nums) 
	{
		if (nums[0] == 2 || nums[0] == 3 || nums[1] == 2 || nums[1] == 3) 
			return true;
		else
		    return false;
	}

}
--------------------------------------------------------------
//Given an integer array length 2, 
//return true if it does not contain a number 2 or 3. 

package com.ravi.array_basic;

public class ArrayDemo12 {

	public static void main(String[] args) 
	{
		int []x = {13,24};
	    boolean b = has2OR3(x);
	    System.out.println("Array does not contain 2 or 3 :"+b);
	}
	
	 public static boolean has2OR3(int[] nums) 
	 {
		 if (nums[0] != 2 && nums[0] != 3 && nums[1] != 2 && nums[1] != 3) 
			 return true;
		 else
		     return false;
     }

}
---------------------------------------------------------------
Whenever we create an array object using new keyword, all the array index will be initialized with default values as shown in the program below.

package com.arvi.communication;

public class ArrayDefault {

	public static void main(String[] args) 
	{
		String []x = new String[10];
		
		for(String y : x)
		{
			System.out.println(y);
		}

	}

}
--------------------------------------------------------------
//Given an integer array, return a new array with double the length where its last element is the same as the original array, and all the other elements are containing 0. The original array will be length 1 or more.

package com.ravi.array_basic;

import java.util.Arrays;

public class ArrayDemo13 
{
   public static void main(String[] args)
   {
	   int []x = {11,12,100,89};
	   
       int []y = makeLast(x);
       System.out.println("Array is :"+Arrays.toString(y));
   }
   
   public static int[] makeLast(int[] nums)
   {
	   int len = nums.length;
	   int[] myArray = new int[2*len]; 
	   
	   myArray[myArray.length-1] = nums[len - 1] ;
	   return myArray;
   }
}
---------------------------------------------------------------
//Given an array of integers, swap the first and last elements in the array. Return the modified array. The array length will be at least 1.

package com.ravi.array_basic;

import java.util.Arrays;

public class ArrayDemo14 
{
 public static void main(String[] args)
  {
	int []arr = {12,89,90,67,34,66};
	
	int []newArray =  swapEnds(arr);
	
	System.out.println("New Array Elements are :"+Arrays.toString(newArray));
  }
 
 public static int[] swapEnds(int[] nums) 
 { 
   int temp = nums[0];
   nums[0] = nums[nums.length-1]; 
   nums[nums.length-1] = temp; 
   return nums;
 }

}

--------------------------------------------------------------
//Given an array of integers of odd length, return a new array length 3 containing the elements from the middle of the array.One element should be before middle and another one should be after middle. The original array length will be at least 3.

package com.ravi.array_basic;

import java.util.Arrays;

public class ArrayDemo15 {

	public static void main(String[] args) 
	{
		int []arr = {12,89,90,78,99};
		
		int []newArray =  midThree(arr);
		System.out.println("New Array Elements are :"+Arrays.toString(newArray));
	}
	public static int[] midThree(int[] nums) 
	{ 
		int[] myArray = new int[3];
		
	    int middle = nums.length / 2; 
	    
	    myArray[0] = nums[middle-1]; 
	    myArray[1] = nums[middle]; 
	    myArray[2] = nums[middle+1]; 
	    return myArray;
	}
}
--------------------------------------------------------------
Logical Based Program :
-----------------------
package com.ravi.array_demo;

public class Arr 
{
	public static void main(String[] args) 
	{
		String []y = new String[3];
		System.out.println(y[0]);    //Will provide default value i.e null
		
		
		int []x = {10,20,30,40,50};
		System.out.println(x);   //Will print object reference in String format
		
		System.out.println(java.util.Arrays.toString(x)); //Converting array elements into String
	}

}
---------------------------------------------------------------
//How to retrieve the values of an array by using for loop and for each loop and toString() method 

package com.ravi.array_demo;
import java.util.Arrays;
class Arr1 
{
	public static void main(String[] args) 
	{
		int []a ={12,45,78,90,87,9};

		Arrays.sort(a);

        System.out.println("The length of array is :"+a.length);

        System.out.println("Elements of an array using toString()...");
		System.out.println(Arrays.toString(a)); 
		
		System.out.println("Elements of an array using for loop...");
		
		for(int i=0;i<a.length ;i++)  
		{
			System.out.println(a[i]);
		}

         System.out.println("Elements of an array using for each loop");

		for(int x : a) 
		{
			System.out.println(x);
		}	

	}
}
--------------------------------------------------------------
//creation of an array object using new keyword
package com.ravi.array_demo;
class Arr2
{  
public static void main(String args[])
	{  
		int []x=new int[3];
		x[0]=11;
		x[1]=22;  
		x[2]=33; 		
		
		for(int y : x)
		System.out.println(y);

		System.out.println("......................");

		int []p=new int[]{12,89,90,99};

		for (int q : p)
		System.out.println(q);
	}
}  

---------------------------------------------------------------
//Program to calculate the student marks and find out the average
package com.ravi.array_demo;
import java.util.InputMismatchException;
import java.util.Scanner;
public class Arr3
{
	public static void main(String [] args) 
	{
		Scanner sc = new Scanner(System.in);
		try(sc)
		{
		System.out.print("How Many Subjects: ");		
		int noOfSubject = sc.nextInt();
		
		int []marks = new int[noOfSubject]; //creating array object dynamically
		
		//Initialize the array variable
		for(int i=0; i<marks.length; i++)
		{
			System.out.print("Enter Marks :");
			marks[i] = sc.nextInt();
		}

		//Adding the marks of the Student
		int total = 0;
		for(int x : marks)
			total = total + x;
		
		System.out.println("The total Marks is :"+total);
		
		double average = total/noOfSubject;
		
		System.out.println("Average is :"+average);
		}
		catch(InputMismatchException e)
		{
			e.printStackTrace();
		}
		
	}
}
---------------------------------------------------------------
//Program to find out the minimum value of an Array
package com.ravi.array_demo;
import java.util.*;
class Test
{  
	static void minValue(int arr[])   //arr  8  7  5  3   2
	{  
		int min = arr[0];  	          // min = 2

		for(int i=1;i<arr.length;i++)   //i = 5     length =5    [i < 5]
		{
			if(min > arr[i])                   // 
			   min=arr[i];  
        }
		
		System.out.println("The minimum value is :"+min);  
	}
}
 class Arr4
 { 
	public static void main(String args[])
		{  
			Scanner sc = new Scanner(System.in);
            System.out.print("How Many array Values: ");

			int n = sc.nextInt();   // n=5
			int []val =new  int[n];

            //Initializing the array variable
			for(int i=0; i<n; i++)   
			{
			System.out.print("Enter Value of an array :");
			val[i] = sc.nextInt();
			}

			Test.minValue(val); 
		}
}  
---------------------------------------------------------------
//Modifying the value of an array

Array works on pass by reference and we know that array is an object so if we modify the content of an array then original array will also modify.


package com.ravi.array_demo;

import java.util.Arrays;

class Demo
{  
	public static int [] changeValue(int arr[])      //arr = {9,2,5,7,6}
	{  
		arr[0] = 12;
		arr[1] = 15;
		return arr;
	}
}
 class Arr5
 { 
	public static void main(String args[])
		{  
			int a[]={9,2,5,7,6}; 

            System.out.println("Before Change...");
			System.out.println(Arrays.toString(a));
			
			int b[] = Demo.changeValue(a);             //b = {12,15,5,7,6} 
			
            System.out.println("After Change...");
            System.out.println(Arrays.toString(b));

			System.out.println("After Change original array will also modify");
			System.out.println(Arrays.toString(a));
		}
	}
	
This program contains a diagram 
---------------------------------------------------------------
19-Jun-23
---------
IQ

class Test 
{
	public static void main(String[] args) 
	{
		String []x = new String[3];
        System.out.println(x.length()); //We have property not method

        String y = "india";
		System.out.println(y.length); //we have method but not property
	}
}

---------------------------------------------------------------
Arr6.java
----------

package com.ravi.array_demo;
class Employee
{
  private  int empId;
  private String name;
  
  
	public Employee(int empId, String name) 
	{
		super();
		this.empId = empId;
		this.name = name;
	}


	@Override
	public String toString() {
		return "Employee [empId=" + empId + ", name=" + name + "]";
	}
	
	
  
  
}
public class Arr6
{
   public static void main(String args[])
	{
     //creating array of employee object  
    Employee [] obj = new Employee[3] ; 
    
     obj[0] = new Employee(101,"Ravi");
     obj[1] = new Employee(102,"Aryan");
     obj[2] = new Employee(103,"Elina"); 
	      
     System.out.println("Employee Data:");

	 for (Employee e1 : obj )
	 {
         System.out.println(e1);
		 System.out.println("..............................");
	 }     
  }
}
---------------------------------------------------------------
//Object array

package com.ravi.array_demo;
class Arr7
{  
    public static void main(String args[])
    {
        Object[] obj  = { "Ravi", new String("Hyd"), new java.util.Date(), false,null, 90.56, 'A' };
  
       for(Object o : obj)
		{
		   System.out.println(o);
		}  
    }
}
---------------------------------------------------------------
//Creating and Storing the student array object

package com.ravi.array_demo;

import java.util.Scanner;

class Student
{
	private Integer studentId;
	private String studentName;
	
	public Student(Integer studentId, String studentName)
	{
		super();
		this.studentId = studentId;
		this.studentName = studentName;
	}

	@Override
	public String toString() {
		return "Student [studentId=" + studentId + ", studentName=" + studentName + "]";
	}	
}

public class Arr8
{
	public static void main(String [] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("How many student objects ?:");
		int noOfObjects = sc.nextInt();
		
		Student []obj = new Student[noOfObjects];
		
		//Initialize Student Array object
		for(int i=0; i<obj.length; i++)
		{
		  System.out.print("Enter Student ID :");
		  int id = sc.nextInt();
		  System.out.print("Enter Student Name :");
		  String name = sc.nextLine();
		  name = sc.nextLine();
		  obj[i] = new Student(id, name);
		}
		
		System.out.println("Printing the Student Data...");
		for(Student st : obj)
			System.out.println(st);	
		
	}
}
--------------------------------------------------------------
//Program on Array of Object
package com.ravi.array_demo;
public class Arr9 
{
	public static void main(String[] args) 
	{
		//Array of Object
		Object x[] = new Object[6];

		x[0] = new StudentDemo();
		x[1] = new EmployeeDemo();
		x[2] = 12;  //integer Object
		x[3] = 12.90;  //Double Object
		x[4] = 'A';  //Character Object
		x[5] = false;  //Boolean Object

		for(Object obj : x)
		{
			System.out.println(obj);
		}
	}
}

class StudentDemo
{
}

class EmployeeDemo
{
}
--------------------------------------------------------------
//WAP to find the second largest number in an array

package com.ravi.array_demo;

class Arra10 
{
	public static void main(String[] args) 
	{
		int []arr = {9,5,2,8,4,7};            //{9,8,2,5,4,7}
		
		int temp = 0;                         //temp = 5

		for(int i=0; i<arr.length; i++)           // i = 1  length = 6
		{
			for(int j=i+1; j<arr.length; j++)    //j = 5   length = 6
			{
				if(arr[i] < arr[j])               //8 <  7
				{
                     temp = arr[i];
					 arr[i] = arr[j];
					 arr[j] = temp;
					
				}
			}
		}
		System.out.println("Second largest number is :"+arr[1]);
	}
}
--------------------------------------------------------------
//Finding the duplicate elements of an array

package com.ravi.array_demo;
public class Arr11 
{
	public static void main(String[] args) 
	{
		int []arr = {2,4,6,7,9,2,4};

		for(int i=0; i<arr.length; i++)         // i = 0    length =7
		{
			 for(int j=i+1; j<arr.length; j++)   //j = 1     length =7
			{
				 if(arr[i] == arr[j] && (i!=j))         
				{
				System.out.println("Duplicate element is :"+arr[j]);
				}
			}
		}
	}
}

--------------------------------------------------------------
package com.ravi.array_demo;

import java.util.Arrays;
public class Arr12
{
      public static int[] addElement(int[] arr, int element) 
      {
          int temp[] = new int[arr.length+1];  
       
          for (int i = 0; i < arr.length; i++) 
          {
              temp[i] = arr[i];
          }      
      
           temp[arr.length] = element;      
            return temp;
      }

   public static void main(String[] args) {
      // original array
      int arr[] = { 30, 50, 20, 40, 10};
      
      // new element to be added
      int element = 99;
      
      // display old array
      System.out.println("Original array: " + Arrays.toString(arr));
      
      // add element 
      arr = addElement(arr, element);
      
      // display new array
      System.out.println("New array: " + Arrays.toString(arr));
   }
}
      
--------------------------------------------------------------
package com.ravi.array_demo;

import java.util.Arrays;

public class Arr13
{
	public static int [] mergeArrayElements(int [] x, int [] y)
	{
        int length = x.length + y.length;
        int[] result = new int[length];
        int pos = 0;
        for (int element : x) {
            result[pos] = element;
            pos++;
        }
        for (int element : y) {
            result[pos] = element;
            pos++;
        }

        return result;
	}

    public static void main(String[] args) {
        int[] array1 = {1, 2, 3};
        int[] array2 = {4, 5, 6};

        int [] result = mergeArrayElements(array1, array2);
        
        System.out.println(Arrays.toString(result));
    }
}
---------------------------------------------------------------
20-Jun-23
----------
Working with Methods of Arrays class :
---------------------------------------------
Arrays is a predefined class in java available in java.util package. This class contains various static methods to work with array object. The following are the methods of Arrays class.

public static int binarySearch(data type[] arr, Object elementToBeSearched)
------------------------------------------------------------------------------- 
 It is a predefined method of Arrays class. This method uses a binary search algorithm to search the specified element in the array.
 We need to sort the array before using binarySerach method.

 Return type of this method is int and it will return the index position of the sepecified element.
---------------------------------------------------------------
 ArrayMethod1.java
 ------------------
package com.ravi.array_method;

import java.util.*;
public class ArrayMethod1 
{
	public static void main(String[] args) 
	{
		 int arr[] = {60,20,50,40,30,10};	//10 20 30 40 50 60	 
	       Arrays.sort(arr);
	        
	        int searchVal = 20;
	  
	        System.out.println(searchVal + " available at index position : "
	            + Arrays.binarySearch(arr, searchVal));
	}
}
---------------------------------------------------------------
public static boolean equals(Object[] array1,Object[] array2) :
-----------------------------------------------------------------------
  It is a predefined method of Arrays class. This method is used to check the given two arrays are equal or not. 

  We can say both arrays are equal if both arrays are null or both arrays are having the same length and each corresponding element is also same.
 
ArrayMethod2.java
------------------
package com.ravi.array_method;
import java.util.Arrays;

public class ArrayMethod2 
{
	public static void main(String[] args) 
	{
		int []arr1 = new int [] {1, 2, 3, 4}; 
		int []arr2 = new int [] {1, 2, 3, 4};  
		
		if(Arrays.equals(arr1, arr2))
		{
			System.out.println("Both Arrays are equal");
		}
		else
		{
			System.out.println("Both Arrays are not equal");
		}	
	}
}
--------------------------------------------------------------
public static int compare(data type[] array1 , data type[] array2)
 --------------------------------------------------------------------------
It is a predefined method of Arrays class. This compare() method will check whether array is lexicographically smaller or greater. The return type of this method is int.

lexicographical comparison means comparing two array objects element by element.

it will return 0 or +1 or -1
---------------------------------------------------------------
ArrayMethod3.java
-------------------
package com.ravi.array_method;

import java.util.Arrays;

public class ArrayMethod3 
{
   public static void main(String[] args)
   {

	    int arr1[]={100,210,300,400}; 
		int arr2[]={100,220,300,400}; 
		
		System.out.println(Arrays.compare(arr1,arr2));
   }
}
--------------------------------------------------------------
public static data type[] copyOf(data type[] arr, int newLength)
 ------------------------------------------------------------------------  
  It is a predefined method of Arrays class. This method is used to copy the existing element of an array to the newely created array.
  Here at the time of creating new array we need to specify the length.

ArrayMethod4.java
------------------
package com.ravi.array_method;

import java.util.Arrays;

public class ArrayMethod4
{
	
	public static void main(String[] args) 
	{
		    int[] arr = new int[] {10,20,30,40,50,60};
		    System.out.println(Arrays.toString(arr)); 		

			int[] new_arr = Arrays.copyOf(arr, 4); 
			System.out.println(Arrays.toString(new_arr));	
			
			int[] new_arr1 = Arrays.copyOf(arr, 10); 
			System.out.println(Arrays.toString(new_arr1));	
	}
}
 --------------------------------------------------------------
 package com.ravi.array_method;

public class ArrayMethod5 
{
	public static void main(String[] args)
	{
		int []x = new int[] {10,20,30};
		System.out.println(x.getClass().getName()); //[I
	}

}
---------------------------------------------------------------
Multi Dimensional Array
--------------------------
A multi-dimensional array is very much similar to a single dimensional array. It can have multiple rows and multiple columns unlike single dimensional array, which can have only one row index.

It represents data into tabular format in which data is stored into row and columns.

In order to implement 2D array we should use nested loop;

Multi-Dimensional Array Declaration :
datatype[ ][ ] arrayName;

Initialization of Array
datatype[ ][ ] arrayName = new int[rows][column]

int [][] val = new int[2][2];

OR

int [][] num = new int[][]{(1,2),(3,4)};

--------------------------------------------------------------
TwoDimensionalDemo1.java
-------------------------
package com.ravi.two_dimensional_array;

import java.util.Scanner;

public class TwoDimensionalDemo1 
{
	public static void main(String args[]) 
	{
       Scanner sc = new Scanner(System.in);
       System.out.println("Enter the number of rows and columns :");
	   int rows = sc.nextInt();   //rows = 3
       int cols = sc.nextInt();    //cols = 3

       int[][] numbers = new int[rows][cols];

      //Inserting the elements into 2D array
      for(int i=0; i<rows; i++)         //i = 0
	  {
           for(int j=0; j<cols; j++)      //j = 0
		  {
               numbers[i][j] = sc.nextInt();
           }
       }
       System.out.println("Printing the data :");

       for(int i=0; i<rows; i++) 
	   {
           for(int j=0; j<cols; j++) 
			 {
                   System.out.print(numbers[i][j]+" ");
             }
               System.out.println();
           }
   }

}
--------------------------------------------------------------
//Searching an element position from 2D array
package com.ravi.two_dimensional_array;

import java.util.Scanner;

public class TwoDimensionalDemo2 
{
	public static void main(String args[]) 
	{
       Scanner sc = new Scanner(System.in);
       System.out.println("Enter the number of rows and columns :");
	   int rows = sc.nextInt();
       int cols = sc.nextInt();

       int[][] numbers = new int[rows][cols];

       for(int i=0; i<rows; i++)
	  {
           for(int j=0; j<cols; j++) 
		  {
               numbers[i][j] = sc.nextInt();
           }
       }

   System.out.println("Enter the number you want to serach the position :");
	   int x = sc.nextInt();

       for(int i=0; i<rows; i++) 
	   {
           for(int j=0; j<cols; j++) 
			 {
                   if(numbers[i][j] == x)
					   {
                         System.out.println(x+" found at location (" + i + ", " + j + ")");
				       }
			  }
         }
   }

}
---------------------------------------------------------------
//Matrix to perform addition 
package com.ravi.two_dimensional_array;

public class TwoDimensionalDemo3 
{
	public static void main(String args[])
	{  
		int a[][]={{1,3,5},{2,4,6}};  //2 rows and 3 columns
		int b[][]={{5,7,9},{1,1,1}};  //2 rows and 3 columns
  
		//Matrix to perform addition  
		int sum[][]=new int[2][3];  
  
		//adding and printing addition of 2 matrices  
		for(int i=0;i<2;i++)
		{  
		    for(int j=0;j<3;j++)
			{  
		        sum[i][j] = a[i][j]+b[i][j];  
		        System.out.print(sum[i][j]+" ");  
		    }  
            System.out.println();
       }  
   }

}
---------------------------------------------------------------
We can print the 2D data by using 3 ways as shown in the program

package com.ravi.two_dimensional_array;

import java.util.Arrays;
import java.util.Scanner;

public class PrintingTwoDimensional 
{
	public static void main(String[] args)
	  {
	    Scanner sc = new Scanner(System.in);
	       System.out.println("Enter the number of rows and columns :");
		   int rows = sc.nextInt();   //rows = 3
	       int cols = sc.nextInt();    //cols = 3

	       int[][] numbers = new int[rows][cols];

	      //Inserting the elements into 2D array
	       for(int i=0; i<rows; i++)         //i = 0
		  {
	           for(int j=0; j<cols; j++)      //j = 1
			  {
	               numbers[i][j] = sc.nextInt();
	           }
	       }
	       System.out.println("Printing the data 1st Way :");
		   System.out.println(Arrays.deepToString(numbers));

	        System.out.println("Printing the data 2nd Way :");
	         for(int x []  : numbers )
		  {
			   System.out.println(Arrays.toString(x));
		  } 
	 
	      System.out.println("Printing the data 3rd Way :");
		  for(int [] y : numbers)
		  {
	          for(int k : y)
			  {
				  System.out.println(k);
			  }
		  }

	   }


}

Note :- In order to print 2D array, Java software people has provided a predefined method Arrays.deepToString() through which we can directly print 2D array
--------------------------------------------------------------
21-Jun-23
---------
String in java :-
-----------------
A string literal in Java is basically a sequence of characters. These characters can be anything like alphabets, numbers or symbols which are enclosed with double quotes. So we can say String is a collection of alpha-numeric  character.

How we can create String in Java :-
-----------------------------------
In java String can be created by using 3 ways :-

1) By using String Literal 

   String x = "Ravi";

2) By using new keyword 

   String y = new String("Hyderabad");

3) By using character array

   char z[] = {'H','E','L','L','O'};
--------------------------------------------------------------
In java Strings are immutable means unchanged so, whenever we create a String object in java it can't be modifiable.

Strings literals are created in a very special memory of HEAP called String Constant Pool(SCP) and it is not eligible for garbage collection.

String once created can't be modifiable.
-------------------------------------------------------------
Facts about String and memory :-
--------------------------------------
In java Whenever we create a new String object by using String literal, first of all JVM will verify whether the String we want to create is pre-existing (already available ) in the String constant pool or not.

If the String is pre-existing (already available) in the String Constant pool then JVM will not create any new String object, the same old existing String object would be refer by new reference variable as shown in the diagram.
--------------------------------------------------------------
WAP in Java that describes String objects created by using String literals are not eligible for Garbage Collector.

StringGCEligibility.java
-------------------------
package com.ravi.iq;

public class StringGCEligibility {

	public static void main(String[] args)  throws InterruptedException
	{
		String str1 = "india";
		System.out.println(System.identityHashCode(str1));
		
		str1 = null;
		System.gc(); //Call GC explicitly
		Thread.sleep(2000);
		
		String str2 = "india";
		System.out.println(System.identityHashCode(str2));

	}

}
Note :- In System class there is a predefined static method called identityHashCode(Object obj) which will return the 
hashCode of the Object. return type is int
--------------------------------------------------------------
*Why Strings are immutable :
---------------------------------
As we know a String object in the String constant pool can be refer by multiple reference variables, if any of the reference variable will modify the String Object value then it would be very difficult for the another reference variables pointing to same String object to get the original value, what they have defined earlier as shown in the diagram.
That is the reason Strings are immutable in java .
-------------------------------------------------------------
22-Jun-23
-----------
What is the difference bwteen the following two statements
--------------------------------------------------------------------

String x = "Naresh";   [Creating String by Literal]

String y = new String("Hyderabad"); [Creating String Object by new keyword]

-----------------------------------------------------------------------------------------
String x = "Naresh"; 

It will create one String object and one reference variable and String object will be created in the String constant pool.
--------------------------------------------------------------------------------------------
String y = new String("Hyderabad");

It will create two String objects one is inside the heap memory(non SCP area) which will be reffered by y reference variable and the same String object will be placed in the String constant pool if it is not available there.
Hence two String Objects and one reference variable will be created.

Program on String using hashCode :
----------------------------------
class Test 
{	
	public static void main(String[] args) 
	{
       String str1 = new String("Hyd");	 
	   
	   String str2 = "Hyd";

	   String str3 = new String("Hyd");	

	   System.out.println(str1.hashCode());

	   System.out.println(str2.hashCode());

	   System.out.println(str3.hashCode());
	}
}
----------------------------------------------------------
PROGRAMS :-
-----------
//Three Ways to create the String Object
class Test 
{
	public static void main(String[] args) 
	{
		String s1 = "Hello World";       //Literal
		System.out.println(s1);

		String s2 = new String("Hi"); //Using new Keyword
		System.out.println(s2);

		char s3[] = {'H','E','L','L','O'}; //Character Array 
		System.out.println(s3);		
	}
}
---------------------------------------------------------
//Immutability

class Test1 
{
	public static void main(String[] args) 
	{
        String x = new String("india"); //immutable
		x.toUpperCase();
		System.out.println(x); //will print india in small letter 
		
	}
}
----------------------------------------------------------
//Solution of immutability
class Test2 
{
	public static void main(String[] args) 
	{
		String x = new String("india");
		String y  = x.toUpperCase();
		System.out.println(x);
		System.out.println(y);
	}
}
----------------------------------------------------------
//String is collection of alpha-numeric character
class Test3 
{
	public static void main(String[] args) 
	{
		String x="B-61 Hyderabad";
		System.out.println(x);
		
		String y = "123@$5";
		System.out.println(y);

		String z = "67.90";
		System.out.println(z);

		String p = "A";        
		System.out.println(p);
	}
}
----------------------------------------------------------
Working with methods of String :-
--------------------------------------
String class has provided number of predefined methods to work with String which are as follows :-

1) public char charAt(int indexPosition) :-
--------------------------------------
It is a predefined method available in the String class. The main purpose of this method to extract or fetch or retrieve a single character from the given String. 

We need to pass the index position as a parameter to the method and based on the index position it will extract the character. The return type of this method is char.


  //Program on charAt()
class Test4 
{
	public static void main(String[] args) 
	{
	    String x = "Hello Hyderabad";

                char ch1 =  x.charAt(6);
		System.out.println(ch1); //H

		ch1 = x.charAt(4); 
		System.out.println(ch1); //o

		ch1 = x.charAt(9);
		System.out.println(ch1);//e 
	}
}
------------------------------------------------------------------
public String concat(String str) :-
--------------------------------------
It is a predefined method available in the String class. The main purpose of this method to concat or append two Strings. This can be also done by using concatenation operator '+'. 

This method takes String as a parameter and the return type of this method is String.

 //Program on concat()
class Test5 
{
	public static void main(String[] args) 
	{
		String s1 = "Data";
		String s2 = "base";
		String s3 = s1.concat(s2);  
		System.out.println("String after concatenation :"+s3);

        String s4 = "Tata";
		String s5 = "Nagar";
		String s6 = s4+s5;
		System.out.println("String after concatenation :"+s6);

        String s7 = "Naresh";
		System.out.println(s7.concat(" Technology"));		
	}
}
------------------------------------------------------------------
public boolean equals(Object s) :-
--------------------------------------
It is a predefined method available in the String class. The main purpose of this method to verify whether two Strings are equal or not based on the content.

If both the Strings are equal it will return true otherwise it will return false.It is case sensitive method.

It takes Object as a parameter because it is an overridden method.It is overridden from Object class.

//static Authentication using boolean equals(Object str)

class Test6 
{
	public static void main(String[] args)
	{
		String username = args[0]; //Command Line Argument

		if(username.equals("Ravi"))
		{
			System.out.println("Welcome Ravi");
		}
		else
		{
			System.out.println("Sorry! wrong username /Password");
		}
	}
}
-----------------------------------------------------------------
Program on equals() method using Predicate functional interface :
-----------------------------------------------------------------
import java.util.Scanner;
import java.util.function.Predicate;
class Demo 
{
	public  static void main(String [] args) 
	{
	  Scanner sc = new Scanner(System.in);
	  System.out.print("Enter your Name :");
	  String name = sc.next();

	  Predicate<String> p = str -> str.equals("Virat");
	  System.out.println("Are you Virat :"+p.test(name));
	}	 
}
-----------------------------------------------------------------
public boolean equalsIgnoreCase(String s) :-
--------------------------------------------------
It is a predefined method available in the String class. The main purpose of this method to Compare two Strings based on the content by ignoring the case.
This method takes String as a parameter and return type of this method is boolean. It comapres two Strings by ignoring the case so it is not a case sensitive method.

Hence for this method A and a both are same.

//Program on boolean equalsIgnoreCase(String s)
class Test7 
{
	public static void main(String[] args) 
	{		
		String username = args[0];

		if(username.equalsIgnoreCase("Raviinfotech"))
		{
			System.out.println("Welcome to Raviinfotech channel");
		}
		else
		{
			System.out.println("Sorry! wrong username /Password");
		}
	}
}
------------------------------------------------------------------
IQ :
---
What is the difference between == operator and equals(Object obj) methods while comparing the String?

equals(object obj) method of String class compares two strings based on the content where as == operator compares two Strings based on the reference i.e memory address.

class Test8 
{
	public static void main(String[] args) 
	{
		String s1="India";
		String s2="India";
		String s3=new String("India");

		 System.out.println(s1==s2); //true
		 System.out.println(s1==s3); //false

		  System.out.println(s1.equals(s2)); //true
		 System.out.println(s1.equals(s3));  //true 
	}
}

Note :- String class has overridden equals(Object obj) method from Object class because Object class equals(Object obj) method meant for memory address comparison but this overridden String class equals(Object obj) meant for content comparison.
----------------------------------------------------------------
23-Jun-23
---------
public int length() :-
----------------------
It is a predefined method available in the String class. The main purpose of this method to find out the length of the given String. The return type of this method is int. 

Note :-
-------
Length and Size always start from 1 where as index of the character String always starts from 0.

//Program on public int length()  
class Test9 
{
	public static void main(String[] args) 
	{		
		String x = "Naresh Tech";
        int len = x.length();       
		System.out.println("The length of "+x+" is :"+len);
	}
}
---------------------------------------------------------------
public String replace(char old, char new) :-
----------------------------------------------------
It is a predefined overloaded method available in the String class. The main purpose of this method to replace a character or a String with another character or String. The return type of this method is String. 

By using this method we can replace a single character or a complete String from the given String.

//replace() :-Replaces occurrences of a character with a new character
//public String replace(char old, char new)
class Test10
{
public static void main(String [] args) 
	{
       String x = "oxoxoxox";  
		System.out.println("String before replacement :"+x);

		System.out.println("String after replacement :"+x.replace('x','X'));

		String y="Manager";		
		System.out.println(y.replace("Man","Dam"));	
    }
}
---------------------------------------------------------------
public int compareTo(String s) :-
-------------------------------------
It is a predefined method available in the String class. The main purpose of this method two compare two String based on character by character, comparison of two Strings chracter by chracter based on the UNICODE values are called Lexicographical comparison or dictionary comparison or alphabetical comparison(String case). 

The return type of this method is int. It takes String as  a parameter.

If s1 and s2 are two valid Strings 

if s1==s2  -> 0

if s1>s2  -> +ve

if s1<s2   -> -ve
----------------------------------------------------------------
//public int compareTo(String s) 
class Test11
{
     public static void main(String [] args) 
     {
        String s1="Sachin";      //PQRS        S > R         
        String s2="Sachin";
        String s3="Ratan";  

	   System.out.println(s1.compareTo(s2)); //0 
	   System.out.println(s1.compareTo(s3)); //1     S > R
	   System.out.println(s3.compareTo(s1)); //-1     R < S

       String s4 = "apple"; 
	   String s5 = "Apple"; 
	   System.out.println(s4.compareTo(s5));  // 32  [97 to 65]
	   System.out.println(s5.compareTo(s4));  // -32 [65 to 97]

    }
}
----------------------------------------------------------------
public String substring(int startIndex) :-

public String substring(int startIndex, int endIndex) :-
-------------------------------------------------------------
It is a predefined method available in the String class. The main purpose of this method to extract the part of the specified string based on the index position.

In this method the startIndex starts from 0 whereas endIndex starts from 1.

Both index will be inclusive for printing the value

If end index will be less than start index then we will get an exception i.e StringIndexOutOfBoundsException  
substring(5,2);

If start index and end index both are equal, nothing will print

Nither start index nor end index will accept (-ve) value otherwise StringIndexOutOfBoundsException.

class Test12
{
	public static void main(String []  args) 
	{
        String x="HYDERABAD";		
		System.out.println(x.substring(2,7)); //DERAB

		System.out.println(x.substring(3)); //ERABAD

		System.out.println(x.substring(3,3)); 

         //java.lang.StringIndexOutOfBoundsException 
		 System.out.println(x.substring(6,3));

		//java.lang.StringIndexOutOfBoundsException 
		System.out.println(x.substring(6, -3));
	}
}
---------------------------------------------------------------
public boolean isEmpty() :-
------------------------------
It is a predefined method available in the String class. The main purpose of this method to check whether a String is empty or not. This method returns true if the String is empty that means length is 0, otherwise it will return false.

The return type of this method is boolean.

//public boolean isEmpty()

class Test13
{
	public static void main(String args[])
	{		
		String str1 = "Java by James Gosling";
		String str2 = "";

		System.out.println(str1.isEmpty()); 
		System.out.println(str2.isEmpty()); 	  
	}
}
----------------------------------------------------------------
24-Jun-23 
----------
public String intern()  :
---------------------------
It is a predefined method available in the String class. The main purpose of this method to return canonical representation for the string object that means String interning ensures that all strings having the same contents use the same memory location.

The return type of this method is String

class Test14 
{
	public  static void main(String [] args) 
	{
	   String s1 = new String("nit");
	   String s2 = new String("nit");

	     System.out.println(s1 == s2); //false
	     s1 = s1.intern();
		 s2 = s2.intern();
		 System.out.println(s1 == s2); //true


		     String s3 = "Hyd";
			 String s4 = new String("Hyd");
			 System.out.println(s3 == s4); //false
			 String s5 = s4.intern();
			 System.out.println(s3 == s5); //true

		     
	}	 
}

Note :- Java automatically interns the string literals but we can manually use the intern() method on String object created by new keyword so all the Strings which are having same content will get the same String and return the same memory address(Canonical representation for the String ).

Program contains diagram (24-June-23)
-----------------------------------------------------------------
//IQ
class Test15
{
	public static void main(String args[])
	{
	String x = "india";
	System.out.println("it's length is :"+x.length);//error  

	String [] y = new String[10];    
	System.out.println("it's length is :"+y.length());//error 	
	}
}
Note :
-------
String x = "india";
       x.length(); //valid


Array in Java :-
----------------
String y[] = new String[3];
       y.length; //valid

Note :-
-------
While working with String we have length() method to find out the length of the String. 

where as on the other hand while working with array we have length variable(property) to find out the length of an array.
-----------------------------------------------------------------
----------------------------------------------------------------
//public boolean startsWith(String prefix)
//public boolean endsWith(String suffix)

Both the methods are available in String class. 

startsWith() is used to verify that the given String is Starting with prefix String or not, if yes it will return true otherwise it will return false.

endsWith() is used to verify that the given String is ending with suffix String or not, if yes it will return true otherwise it will return false.

Both the methods are case-sensitive.

Both methods take String as a  parameter and return type is boolean.

//public boolean startsWith(String prefix)
//public boolean endsWith(String suffix)
class Test16
{
	 public static void main(String args[])
	{ 
		String s="Sachin Tendulkar";
		System.out.println(s.startsWith("Sa"));
		System.out.println(s.endsWith("r"));
	}
}
-----------------------------------------------------------------
public int indexOf(String str) :-
---------------------------------
It is a predefined method available in the String class. The main purpose of this method to find out the index position of the specified String in the existing String.

It will serach the index position of the first occurrance of the specified String as a parameter.

It takes String as a parameter and return type of this method is int.

//public int indexOf(String x)
class Test17
{
	 public static void main(String args[])
	{
		String  str = "India is my country and It is in Asia";
        int index = str.indexOf("is");
		System.out.println("First Occurrance of is :"+index); 
	}
}
-----------------------------------------------------------------
public int lastIndexOf(String x) :-
--------------------------------------
It is a predefined method available in the String class. The main purpose of this method to find out the last index position of the Specified String in the existing String.

It will serach the index position of the last occurrance of the String.

It takes String as a parameter and return type of this method is int.

//public int lastIndexOf(String x)
class Test18
{
	public static void main(String args[])
	 { 
         String s1="it is a nice city";    
		 int lastIndex = s1.lastIndexOf("it");
		System.out.println("Last occurrance of it, is :"+lastIndex+ "th position");
     }
}

-----------------------------------------------------------------
//public String toUpperCase() :- converts to upper case letter
class Test19
{
	public static void main(String args[])
	{
        String str = "india";
		System.out.println(str.toUpperCase());
    }
}
---------------------------------------------------------------
//public String toLowerCase()  converts to lower case.
class Test20
{
	public static void main(String args[])
	{
		String str = "INDIA";
		System.out.println(str.toLowerCase());  //india
	}
}

----------------------------------------------------------------
public String trim() :- 
-------------------------
It is a predefined method available in the String class. The main purpose of this method to remove the white spaces from the begning (heading) and end (trailing) from the String.

It will not remove any white space in the between the String. The return type of this method is String.

//program on trim()  
class Test21
{
public static void main(String args[])
	{
		String s1="   Tata    ";  
		System.out.println(s1+"Nagar"); //       Tata      Nagar     

         s1 = "          Hello       Data        ";
		System.out.println(s1.trim() +"Base"); //Hello      DataBase		

	}
}
-----------------------------------------------------------------ppublic String []  split (String delimiter)  :
-----------------------------------------------
It is a predefined method available in the String class. The main purpose of this method to split or break the given String based on specified delimiter(Criteria).

The return type of this method is String array because It returns the collection of String tokens or multiple Strings.

//public String []  split(String delimiter)

class Test22
{
public static void main(String args[])
	{
		String s1="Hyderabad is a nice city";  
		String [] words = s1.split(" "); //Space is there as a parameter(Delimiter)
		for(String str1 : words)
		{
			System.out.println(str1);
		}       
	  
        String s2="Hyderabad is a nice city";  
		String[] word = s2.split("a"); 
		for(String str1 : word)
		{
			System.out.println(str1);
		} 
	}
}  
------------------------------------------------------------
/* There is a predefined class called StringTokenizer available in java.util package, is also used to split the String */
---------------------------------------------------------------
25-Jun-23
----------
public char[]  toCharArray() :-
--------------------------------
It is a predefined method available in the String class. The main purpose of this method to convert the given string into a sequence of characters. The returned array length is equal to the length of the string.

This method does not take any parameter and return type is character array.
---------------------------------------------------------------//public char []   toCharArray()
class Test23
{
public static void main(String args[])
	{
		String str = "Java technology";
		char ch [] = str.toCharArray();

		for(char c : ch)
		{
			System.out.print(c+"  ");
		}
		System.out.println();
	}
}         
--------------------------------------------------------------
package com.ravi.comp;

public class StringToCharacter 
{
	public static void main(String[] args) 
	{
		String str = "ab";
		char ch1 = str.charAt(0);
		char ch2 = str.charAt(1);
		
		System.out.println(ch1 + ch2); //195	
	}
}
--------------------------------------------------------------
public byte [] getBytes() :-
-------------------------------
It is a predefined method available in the String class. The main purpose of this method encode the string into bytes. It converts the string into a sequence of bytes and returns an array of bytes. 

//public byte [] getBytes()
//encode the String into sequence of bytes

class Test24
{
public static void main(String args[])
	{
		String str = "ABCDEF";		
		byte [] b = str.getBytes();

		for(byte a : b)
		{
			System.out.println(a);  
		}
	}
}         
--------------------------------------------------------------
26-Jun-23
----------
StringBuffer :-
----------------
While working with String class the drawback is memory consumption is very high because it is immutable so whenever we want to perform some operation on the existing String Object, a new String object will be created.

In order to solve the problem of immutability as well as high memory consumption, java software people has introdued a separate class called StringBuffer available in java.lang packge from 1.0 onwards.

StringBuffer is a mutable class so we can modify the existing String hence automatically the memory consumption will be low but we have some performance issue because all the methods of StringBuffer class are synchronized so at a time only one thread can access the method of StringBuffer hence it is Thread-safe. In order to solve this performance issue problem java software people has introduced StringBuilder class from 1.5v onwards.

StringBuilder :-
-----------------
It is a predefined class available in java.lang packge. It is also mutable class. The only difference between StringBuffer and StringBuilder is, all the methods of StringBuffer are synchronized where as all the methods of StringBuilder are non-synchronized hence performance wise StringBuilder is more better than StringBuffer.

StringBuffer and StringBuilder both are sharing the same API hence methods name, paramater and return type are same.
-----------------------------------------------------------------------------------
IQ:
---
What is difference between String, StringBuffer and StringBuilder
(Answer is given in the diagram)
--------------------------------------------------------------
//String, StringBuffer and StringBuilder Objects comparison
public class Test25
{
public static void main(String args[])
	{
		StringBuilder sb1=new StringBuilder("Data"); //mutable
		sb1.append("Base");
		System.out.println(sb1);	

		StringBuffer sb2=new StringBuffer("Data"); //mutable
		sb2.append("Base");
		System.out.println(sb2);	

		String sb3 = new String("Data");  //immutable
	    sb3.concat("Base");
        System.out.println(sb3);	
	}
}

Note :- append() is a predefined method available in StringBuffer and StringBuilder class.
--------------------------------------------------------------
public int capacity() :
-------------------------
StringBuffer class contains capacity method() through which we can find out the initial capacity of StringBuffer class in the form of Character.

StringBuffer sb = new StringBuffer(); //default capacity is 16

new capacity = (current capacity * 2) + 2

new Capacity = (16 * 2) + 2 = 34
------------------------------------------------------------
//public int  capacity()   
//new capacity = ( current capacity*2)+2.
class Test26
{
public static void main(String args[])
	{        
		StringBuffer sb1 = new StringBuffer();
		System.out.println(sb1.capacity()); //16
		
	   StringBuffer sb2 = new StringBuffer("India");  //21
	   System.out.println(sb2.capacity()); 

        sb2.append("is great. It is in Asia"); //44
		System.out.println(sb2.capacity()); 	
		
	}
}
-------------------------------------------------------------
//public StringBuffer insert(int position, String str)
//Based on the index position we can insert the String
class Test27
{
public static void main(String args[])
	{	
		StringBuffer sb1=new StringBuffer("Hello");
		sb1.insert(1,"Java");
		System.out.println(sb1);  //HJavaello

		StringBuilder sb2=new StringBuilder("Hello");
		sb2.insert(1,"Java");
		System.out.println(sb2);  
	}
}
-------------------------------------------------------------
//public AbstractStringBuilder reverse()
//Used to reverse the given String
class Test28
{
	public static void main(String[] args) 
	{
		StringBuffer sb1=new StringBuffer("Hello");
		sb1.reverse();
		System.out.println(sb1);  

		StringBuilder sb2=new StringBuilder("Java");
		sb2.reverse();
		System.out.println(sb2);  		
		}
}
-------------------------------------------------------------

//Program to demonstrate the performance of StringBuffer and StringBuilder classes.  
class Test29
{
	public static void main(String []args) 
	{
         long startTime = System.currentTimeMillis();

		//StringBuffer class to perform some looping operation
		StringBuffer sb1 = new StringBuffer("Java");
		for(int i =1; i<=1000000; i++)
		{
			sb1.append(" Technology");
		}

        long endTime = System.currentTimeMillis();

		 System.out.println("Time taken by StringBuffer class is :"+(endTime - startTime+" ms"));

		 System.out.println("..........................");

		 startTime = System.currentTimeMillis();
		 //StringBuilder class to perform some looping operation
		StringBuilder sb2 = new StringBuilder("Java");
		for(int i =1; i<=1000000; i++)
		{
			sb2.append(" Technology");
		}
		
		endTime = System.currentTimeMillis();
		System.out.println("Time taken by StringBuilder class is :"+(endTime - startTime+" ms"));		
	}
}
Note :- System is a predefined class available in java.lang package and it contains a predefined static method currentTimeMillis() , the return type of this method is long, actually it returns the current time of the system in ms.
--------------------------------------------------------------
-------------------------------------------------------------
Constructor of String class :
-----------------------------
1) String str1 = new String();

2) String str2 = new String("India");

3) String str2 = new String(new StringBuffer());

4) String str2 = new String(new StringBuilder());

5) String str2 = new String(byte x[]);

6) String str2 = new String(char v[]);

-------------------------------------------------------------
Some operation on String methods :
---------------------------------
//WAP in java to reverse a String
import java.util.Scanner;
class Test1
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter a String to reverse :");
		String str = sc.nextLine();  //Ravi  (i=0  to 0  ---)
		
        for(int i=str.length()-1; i>=0; i--)
		{
			 System.out.print(str.charAt(i)); //ivaR
		}	
        System.out.println();
	}
}
------------------------------------------------------------
//WAP in java to reverse a String
import java.util.Scanner;
public class Test2 
{
    public static void main(String[] args) 
	{
        Scanner sc = new Scanner(System.in);
		System.out.println("Enter a String to reverse :");
		String input = sc.nextLine();

        StringBuilder sb = new StringBuilder();
        sb.append(input);
        System.out.println(sb.reverse());
    }
}
-------------------------------------------------------------
//Program to find out the duplicate characters in as well as count it in a String
import java.util.*;
public class Test3 
{
public static void main(String ...x)
{
  Scanner sc = new Scanner(System.in);
  System.out.println("Enter a String :");
  String str = sc.nextLine();

  int count = 0;
  char[] arr = str.toCharArray();    

  System.out.println("Duplicate Characters are:");
  for (int i = 0; i < str.length(); i++)      
  {
    for (int j = i + 1; j < str.length(); j++) 
	{
      if (arr[i] == arr[j]) 
		  {
             System.out.println(arr[j]);
             count++;
             break;
          }
     }
  }
   System.out.println("Total duplicate characters are :"+count);
 }
}
--------------------------------------------------------------
//Remove a specified character from the given String
import java.util.*;

public class Test4
{
  public static void main(String[] args) 
  {
    Scanner sc = new Scanner(System.in);
    System.out.println("Enter a String :");
    String str = sc.nextLine();

	System.out.println("Enter a character you want to remove :");
    char removeChar = sc.next().charAt(0);    //Method Chaining

    StringBuilder result = new StringBuilder();

    for (char c : str.toCharArray())  
		{
          if (c != removeChar)    
		  {
             result.append(c);   
          }
       }
    System.out.println(result);
  }
}
-------------------------------------------------------------
27-Jun-23
----------
//Program to check whether a String contains vowels or not?
import java.util.*;
public class Test5
{
  public static void main(String[] args) 
  {
    Scanner sc = new Scanner(System.in);
    System.out.println("Enter a String :");
    String str = sc.nextLine();

    boolean containsVowel = false;

    for (char c : str.toLowerCase().toCharArray())    
	{
      if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') 
	  {
        containsVowel = true;
        break;
      }
    }

    if (containsVowel) 
	{
      System.out.println("The string contains a vowel.");
    } 
	else 
	{
      System.out.println("The string does not contain a vowel.");
    }
  }
}
--------------------------------------------------------------
//How to sort a String data
import java.util.Scanner;
public class Test6
{
  public static void main(String[] args)
  {
    Scanner sc = new Scanner(System.in);
    System.out.println("Enter a String :");
    String str = sc.nextLine();

    char[] chars = str.toCharArray();    

    for (int i = 0; i < chars.length; i++)   
	{
      for (int j = i + 1; j < chars.length; j++)  
	  {
        if (chars[i] > chars[j])   
		{
          char temp = chars[i];
          chars[i] = chars[j];
          chars[j] = temp;
        }
      }
    }
    System.out.println(new String(chars));
  }
}
--------------------------------------------------------------
//count the occurrence of a given character in the existing String
import java.util.*;

public class Test7
{
public static void main(String[] args) 
{
    Scanner sc = new Scanner(System.in);
    System.out.println("Enter a String :");
    String str = sc.nextLine();

	System.out.println("Enter a character :");
    char target = sc.next().charAt(0);

    int count = 0;

    for (int i = 0; i < str.length(); i++)   
	{
            if (str.charAt(i) == target)   
			{
                count++;
            }
     }
        System.out.println("The character '" + target + "' appears " + count + " times in the string '" + str + "'");
    }
}
-------------------------------------------------------------
Character class in java :
------------------------
It is a predefined Wrapper class available in java.lang package. It contains the following methods to check whether a chracter is digit or not , in uppercase or not as well as in lowercase or not?

public static boolean isDigit(char ch);

public static boolean isUpperCase(char ch);

public static boolean isLowerCase(char ch);
-----------------------------------------------------------------
//Program to find out a String contains digit or not
//public static boolean isDigit(char ch) 

import java.util.*;
public class Test8
{
public static void main(String[] args) 
{
    Scanner sc = new Scanner(System.in);
    System.out.println("Enter a String :");
    String str = sc.nextLine();

    boolean containsDigits = false;

    for (int i = 0; i < str.length(); i++)   ///Ravi123
	{
      if (Character.isDigit(str.charAt(i))) 
	  {
        containsDigits = true;
        break;
      }
    }

    if (containsDigits) 
	{
      System.out.println("The string contains digits.");
    } 
	else 
    {
      System.out.println("The string does not contain digits.");
    }
  }
}
----------------------------------------------------------------
//program to count capital and small letter from the given String
//public static boolean isUpperCase(char ch)
//public static boolean isLowerCase(char ch)

import java.util.Scanner;
public class Test9
{
public static void main(String[] args) 
{
  Scanner sc = new Scanner(System.in);
  System.out.print("Enter a string: ");
  String str = sc.nextLine();

  int upperCase = 0, lowerCase = 0;    

    for (int i = 0; i < str.length(); i++) 
	{
      char ch = str.charAt(i);    //Hello
      if (Character.isUpperCase(ch)) 
	  {
        upperCase++;
      } 
	  else if (Character.isLowerCase(ch)) 
	  {
        lowerCase++;
       }
    }    
    System.out.println("Uppercase letters: " + upperCase);
    System.out.println("Lowercase letters: " + lowerCase);
  }
}
----------------------------------------------------------------
//Program to count the consonants and vowels in the given String
import java.util.Scanner;
public class Test10
{
public static void main(String[] args) 
{
  Scanner sc = new Scanner(System.in);
  System.out.print("Enter a string: ");
  String str = sc.nextLine();

    int vowels = 0, consonants = 0;

    for (int i = 0; i < str.length(); i++) 
	{
      char c = str.charAt(i);  

      if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||
          c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') 
	  {
        vowels++;
      } 
	  else if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) 
	  {
        consonants++;
      }
    }
    System.out.println("Vowels: " + vowels);
    System.out.println("Consonants: " + consonants);
  }
}
----------------------------------------------------------------
//check a String  is palindrome or not
import java.util.Scanner;

public class Test11
{
public static void main(String[] args) 
{
  Scanner sc = new Scanner(System.in);
  System.out.print("Enter a string: ");
  String str = sc.nextLine();

    boolean isPalindrome = true;

    for (int i = 0; i < str.length() / 2;   i++)    //madam  i=2   
	{
        if (str.charAt(i) != str.charAt(str.length() - i - 1))  
		{
           isPalindrome = false;
           break;
        }
    }

    if (isPalindrome) 
	{
      System.out.println(str + " is a palindrome.");
    } 
	else 
	{
      System.out.println(str + " is not a palindrome.");
    }
  }
}
----------------------------------------------------------------
Multithreading :
----------------
Uniprocessing :- 
----------------
In uniprocessing, only one process can occupy the memory So the \
major drawbacks are 

1) Memory is westage
2) Resources are westage
3) Cpu is idle

To avoid the above said problem, multitasking is intrroduced.

Multitasking is further divided into two categories 

a) Process based Multitasking
b) Thread based Multitasking


Process based Multitasking :
----------------------------
If a CPU is switching from one subtask(Thread) of one process to 
another subtask of another process then it is called Process based Multitasking.

Thread based Multitasking :
---------------------------
If a CPU is switching from one subtask(Thread) to another subtask within the same process then it is called Thread based Multitasking.

28-Jun-23
---------
Thread :-
----------
A thread is the basic unit of CPU which can run concurrently with another thread at the same time within the same process.

It is well known for independent execution. The main purpose of multithreading to boost the execution sequence.

A thread can run with another thread at the same time so our task will be completed as soon as possible.

In java whenever we define a main method then JVM internally create a  thread called main thread.

WAP in java to proof that main is a thread 
------------------------------------------------
package com.ravi.multiple_thread;

public class ThreadName {

	public static void main(String[] args)
	{
		   Thread currentThread = Thread.currentThread();
		    String name = currentThread.getName();
		    System.out.println("Current Thread Name is :"+name);
		   

	}

}

OR The same program we can re-write using method chaining concept

package com.ravi.multiple_thread;

public class ThreadName {

	public static void main(String[] args)
	{
		     String name = Thread.currentThread().getName();
		    System.out.println("Current Thread Name is :"+name);
		   

	}

}

Note :- Thread is a predefined class available in java.lang package and it contains currentThread() which is a static method of Thread class, by using this method we can find out the currently executing Thread at that particular line or place.
getName() is also the method of Thread class and return type of this method is String.
----------------------------------------------------------------
How to create a userdefined Thread in java ?
---------------------------------------------

As we know whenever we define the main method then JVM internally creates a thread called main thread.

The purpose of main thread to execute the entire main method so at the time of execution of main method a user can create  our own userdefined thread.

In order to create the userdefined Thread we can use one of the following two ways :-

1) By extending Thread class
2) By implementing Runnable interface

Note :- Thread is a predefined class available in java.lang package where as Runnable is a predefined interface available in java.lang Package.
----------------------------------------------------------------
public void start() :
----------------------
start() is a predefined method of Thread class and this method internally performs two tasks

1) It makes a request to opearting system to assign a new thread to perform concurrent execution.

2) It internally invokes the run() method as a part a separate Stack.

Note :- For every individual thread, JVM creates a separate runtime stack
----------------------------------------------------------------
The following program explains how to craete a userdefined Thread by extending Thread approach.

UserDefinedThread.java
-----------------------

package com.ravi.multiple_thread;

class MyThread extends Thread
{
	@Override
	public void run()
	{
      System.out.println("Child Thread is Running Here!!!!");		
	}
}

public class UserDefinedThread 
{
	public static void main(String[] args) throws InterruptedException 
	{
		System.out.println("Main Thread has started!!!!");
		MyThread mt = new MyThread();		
		mt.start(); //calling the run()		        
		System.out.println("Main Thread has ended!!!!!!");
	}
}
----------------------------------------------------------------
public boolean isAlive() :-
-----------------------------
It is a predefined method of Thread class through which we can find out whether a thread has started or not ?

As we know a new thread is created after calling start() method so if we use isAlive() method before start() method, it will return false but if the same isAlive() method if we invoke after the start() method, it will return true.

We can't restart a thread in java if we try to restart then It will generate an exception i.e java.lang.IllegalThreadStateException
----------------------------------------------------------------
package com.ravi.basic;

class Foo extends Thread
{
	@Override
	public void run()
	{
		System.out.println("Child thread is running...");
		System.out.println("It is running with separate stack");		
	}	
}
public class IsAlive 
{
	public static void main(String[] args)
	{
		System.out.println("Main Thread is started..");			
		Foo f = new Foo(); 		
		System.out.println("Thread has not started yet so :"+f.isAlive());	
		
		f.start(); //new Thread has created	
		
		System.out.println("Thread has  started  so :"+f.isAlive());
		
		f.start();  //restart a thread [java.lang.IllegalThreadStateException]
		
    }
}
---------------------------------------------------------------
29-Jun-23
---------
How to set and get the name of the Thread :
--------------------------------------------------
Whenever we create a Thread in java then by default JVM assigns the name of thread is Thread-0, Thread-1, Thread-2 and so on.

If, As a user we want to assign some user defined name of the Thread, then Thread class has provided a predefined method called setName(String name) to set the name of the Thread.

On the other hand we want to get the name of the Thread then Thread class has provided a predefined method called getName().

public void setName(String name)

public String getName()
----------------------------------------------------------------
package com.ravi.basic;
class Test extends Thread
{
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName();
		System.out.println(name +" thread is running Here!!!!");
	}
}
public class ThreadName 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test();
		Test t2 = new Test();
		t1.start();			
		t2.start();	
		System.out.println(Thread.currentThread().getName()+" thread is running.....");
	}
}
----------------------------------------------------------------
package com.ravi.basic;
class Test extends Thread
{
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName();
		System.out.println(name +" thread is running Here!!!!");
	}
}
public class ThreadName 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test();
		Test t2 = new Test();
		t1.start();			
		t2.start();	
		System.out.println(Thread.currentThread().getName()+" thread is running.....");
	}
}


Note :- Here as user we are not setting the name of the Thread, so by default JVM will assign the default name i.e Thread-0, Thread-1

The following program explains we can set our own userdefined name to the Thread :

package com.ravi.basic;
class Demo extends Thread
{
	@Override
	public void run()
	{
		System.out.println(Thread.currentThread().getName()+" thread is running.....");	
	}
}
public class ThreadName1 
{
	public static void main(String[] args) 
	{
		 Thread t = Thread.currentThread();
	     t.setName("Parent");//changing the main thread name
			     
	     Demo d1 = new Demo();
	     Demo d2 = new Demo();
	     
	     d1.setName("Child1");
	     d2.setName("Child2");	
	     
	     d1.start();
	     d2.start();  
	     
	          
	     System.out.println(Thread.currentThread().getName()+" thread is running...");
	}
}
----------------------------------------------------------------
//Progam where main method contains Exception 

package com.ravi.basic;

class Stuff extends Thread
{
	@Override
	public void run()
	{
		System.out.println("Child Thread is Running!!!!");
	}
	
}
public class ExceptionDemo {

	public static void main(String[] args) 
	{
		System.out.println("Main Thread Started");

		Stuff s = new Stuff(); s.start();
		Stuff s1 = new Stuff(); s1.start();
		
		System.out.println(10/0);
		System.out.println("Main Thread Ended");
	}
}

Note :- Here main Thread will be interrupted due to AE but still child thread will be executed.
----------------------------------------------------------------
Program on Thread loop :
------------------------
package com.ravi.basic;

class Sample extends Thread
{
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName(); 
	    
	    for(int i = 1; i<=10; i++)
	    {
	    	System.out.println("i value is :"+i+" by "+name+" thread" );
	    }	   
	}
}
public class ThreadLoop 
{	
	public static void main(String[] args) 
	{
	    System.out.println("Main thread started.....");
	    
	    String name = Thread.currentThread().getName();
	    
	    for(int i = 1; i<=10; i++)
	    {
	    	System.out.println("i value is :"+i+" by "+name+ " thread");	   
	    }	
	    
	    Sample s = new Sample();
	    s.start();//child thread is created here which is calling the run() method  
	   
	    int x =1;
	     do
	     {
	    	System.out.println("Hello");
	    	x++;
	     }
	     while(x<=10);    
	}
}
----------------------------------------------------------------
Thread.sleep(long milisecond) :
------------------------------------
The main purpose of sleep() method to put a Thread into temporarly waiting state, the waiting period of the Thread will depend upon the parameter we passed inside the sleep() method, It takes long milisecond as a parameter.

It is a static method so we can directly call sleep() method with the help of class name i.e Thread class.

It throws a checked exception i.e InterruptedException so we should write sleep() inside try-catch or declare the method as throws.
----------------------------------------------------------------
SleepDemo.java
--------------
package com.ravi.basic;

class Sleep extends Thread
{
   @Override
   public void run() 
   {
	   for(int i=1; i<=10; i++)
	   {
		   System.out.println(i);
		   try
		   {
			  Thread.sleep(1000);
		    } 
		   catch (InterruptedException e) 
		   {
			e.printStackTrace();
		   } 
	   }
	   
   }
}
public class SleepDemo 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Thread started...");
         Sleep s = new Sleep();
         s.start();
         
		System.out.println("Main Thread ended...");
	}
}
----------------------------------------------------------------
SleepDemo1.java
----------------
package com.ravi.basic;

class MyTest extends Thread 
{	
	@Override
	public void run() 
	{
		for (int i = 1; i <= 5; i++) 
		{	
	     try 
		 { 
			 Thread.sleep(1000); 
		 } 
		 catch(InterruptedException e) 
		 {
		 System.err.println("thread has interrupted"); 
		 }			
			System.out.println(i + " by " + Thread.currentThread().getName());
		}
	}
}
public class SleepDemo1 
{
	public static void main(String[] args) 
	{
		System.out.println(Thread.currentThread().getName() + " thread");

		MyTest t1 = new MyTest();
		MyTest t2 = new MyTest();

		t1.setName("Child1");
		t2.setName("Child2");
		
		t1.start();
		t2.start();	
	}
}

Note :- While writing the Thread.sleep() inside the run() method, we cannot write throws InterruptedException statement because  IF A SUPER CLASS METHOD DOES NOT THROW ANY KIND OF EXCEPTION THEN AT THE TIME OF OVERRIDING THE SUB CLASS METHOD SHOULD NOT THROW ANY KIND OF EXCEPTION
----------------------------------------------------------------
join() method of Thread class :
------------------------------------
The main purpose of join() method to put the parent thread into temporarly waiting state till the completion of child Thread.

It also throws checked exception i.e InterruptedException so better to use try catch or declare the method as throws.

It is an instance method so we can call this method with the help of Thread object reference.
----------------------------------------------------------------
package com.ravi.basic;

class Join extends Thread
{
	@Override
	public void run()
	{
		for(int i=1; i<=5; i++)
		{
			System.out.println(i + " By "+ Thread.currentThread().getName());
			try
			{
			Thread.sleep(1000);
			}
			catch(InterruptedException e)
			{
		      e.printStackTrace();		
			}
		}
	}
}

public class JoinDemo 
{
	public static void main(String[] args) throws InterruptedException 
	{
       System.out.println("Main Thread Started!!!!!");
       
       Join j1 = new Join();
       Join j2 = new Join();
       Join j3 = new Join();
       j1.setName("Account_Opening");
       j2.setName("Deposit");
       j3.setName("Withdraw");
       
       j1.start();        
       j1.join(); //main thread will halt here       
       j2.start();        
       j2.join();  //main thread will halt here        
       j3.start();       
       j3.join();  //main thread will halt here   
       
       System.out.println("Main thread completed!!!!");
       
	}
}
---------------------------------------------------------------
30-Jun-23
----------
How to create a Thread by using Runnable interface approach :
-------------------------------------------------------------------------
In this approach we need to pass the sub class object reference to the constructor of Thread class (Passing Object reference to the constructor)

package com.ravi.basic;

class Demo1 implements Runnable
{
	@Override
	public void run()	
	{		
		System.out.println("Child thread is running....");	
	}	
}
class RunnableDemo
{
	 public static void main(String[] args)
	 {
		System.out.println("Main Thread has started...");
		
		Demo1 d1 = new Demo1(); 
		Thread t1 = new Thread(d1);
		t1.start();		
		System.out.println("Main Thread has ended");
	
	 }
}
----------------------------------------------------------------In between extends Thread and implements Runnable, which one is better and why?

In between extends Thread and implements Runnable approach, implements Runnable is more better due to the following reasons

1) When we use extends Thread, all the methods and properties of Thread class is available to sub class so it is heavy weight but this is not the case while implementing Runnable interface.

2) As we know Java does not support multiple inheritance using classes so in the extends Thread approach we can't extend another class but if we use implments Runnable interface still we have chance to extend another class and we can also implement one or more interfaces.

3) implements Runnable is a better approach to create multiple threads on a single sub class object.
----------------------------------------------------------------
Anonymous inner class with Thread class :-
------------------------------------------
package com.ravi.anonymous;

public class AnonymousThread 
{
	public static void main(String[] args)
	{
	   //Anonymous inner class
	   Thread t1 = new Thread()
	   {
		 @Override
		 public void run()
		 {
			 System.out.println("Thread is running");
			 System.out.println(Thread.currentThread().getName());
		 }
	   };
	   
	   t1.start();
	}

}
---------------------------------------------------------------
Anonymous inner class with Thread class without reference

package com.ravi.anonymous;

public class AnonymousThreadWithoutRef {

	public static void main(String[] args) 
	{
		new Thread()
		{
			@Override
			public void run()
			{
				System.out.println("Thread is running");
				System.out.println(Thread.currentThread().getName());
			}
			
		}.start();

	}

}
----------------------------------------------------------------
Anonymous inner class with Runnable interface

package com.ravi.anonymous;

public class RunnableInnerApproach 
{
	public static void main(String[] args)
	{
		Runnable r1 = new Runnable()
		{
			@Override
			public void run() 
			{
				System.out.println("Thread is running");
				System.out.println(Thread.currentThread().getName());				
			}			
		};
        Thread t1 = new Thread(r1);
        t1.start();
	}

}
--------------------------------------------------------------
Anonymous inner class with Runnable interface using Lambda :-
-----------------------------------------------------------
package com.ravi.anonymous;

public class RunnableByLambda 
{
	public static void main(String[] args) 
	{
		Runnable r1 =   () ->
		{
			System.out.println("Thread is running");
			System.out.println(Thread.currentThread().getName());
		};
		
		Thread t1 = new Thread(r1);
		t1.start();
	}
}
----------------------------------------------------------------
Problem with multithreading :-
----------------------------------
Multithreading is very good to complete our task as soon as possible but in some situation, It provides some wrong data or wrong result.

In Data Race or Race condition, all the threads try to access the resource at the same time so the result will be corrupted.

In multithreading if we want to perform read operation and data is not updatable then multithreading is good but if the data is updatable data (modifiable data) then multithreading may produce some wrong result or wrong data as shown in the diagram.(30-June-23)
----------------------------------------------------------------
RailwayReservation.java
-----------------------
package com.ravi.anonymous;

class Customer implements Runnable
{
	int available = 1;	
	int wanted;
	
	public Customer(int wanted)
	{
	  this.wanted = wanted;	
	}
	
	@Override
	public void run() 
	{
		if(available >= wanted)
		{
		String name = Thread.currentThread().getName();	
		System.out.println(wanted + " berth reserved for :"+name);
		available = available - wanted;
		}
		else
		{
			System.out.println("Sorry! Berth is not available");
		}
	}
	
}

public class RailwayReservation 
{
	public static void main(String[] args) 
	{
		Customer c1 = new Customer(1);
		
		Thread t1 = new Thread(c1);
		t1.setName("Person1");
		
		Thread t2 = new Thread(c1);
		t2.setName("Person2");
		
		t1.start();  t2.start();
		
	}

}
---------------------------------------------------------------
Theatre.java
-------------
package com.ravi.advanced;

class MyThread implements Runnable
{
	private String str;
	public MyThread(String str)
	{
		this.str=str;
	}	
	
	@Override
	public void run()
	{
		for(int i=1; i<=10; i++)
		{
			System.out.println(str+ " : "+i);
			try
			{
				Thread.sleep(100);
			}
			catch (Exception e)
			{
			System.err.println(e);
			}
		}
	}
}
public class Theatre
{
	public static void main(String [] args)
	{
		MyThread obj1 = new MyThread("Cut the Ticket");
		MyThread obj2 = new MyThread("Allocate the Seat");

		Thread t1 = new Thread(obj1);
		Thread t2 = new Thread(obj2);

		t1.start();
		t2.start();
	}
}
----------------------------------------------------------------
Railway reservation by using Lambda :
-------------------------------------
package com.ravi.thread_prob;

public class RailwayReservationUsingLambda 
{
	private int available = 1;	
	private int wanted;

	public RailwayReservationUsingLambda(int wanted)
	{
        this.wanted = wanted;		
	}

	public static void main(String[] args) 
	{
		RailwayReservationUsingLambda rr = new RailwayReservationUsingLambda(1);
		
		Runnable r1 = ()->
		{
			String name = null;
			if(rr.available >= rr.wanted)
			{
				name = Thread.currentThread().getName();
				System.out.println(rr.wanted +" berth reserved for :"+name);
				rr.available = rr.available - rr.wanted;
			}
			else
			{
				System.out.println("Hello "+name+" Sorry !! Berth is not available");
			}
		};
        Thread t1 = new Thread(r1);
        Thread t2 = new Thread(r1);
        t1.setName("Person1");
        t2.setName("Person2");  t1.start(); t2.start();
	}

}

HW
---
Banking.java

OnlineMovieTicket.java
-----------------------
----------------------------------------------------------------
01-Jul-23
----------
Synchronization :
----------------
In order to solve the problem of multithreading java software people has introduced synchronization concept.

In order to acheive synchronization in java we have a keyword called "synchronized".

It is a technique through which we can control multiple threads but accepting only one thread at all the time.

Synchronization allows only one thread to enter inside the synchronized area for a single object.

Synchronization can be divided into two categories :-

1) Method level synchronization

2) Block level synchronization

Method level synchronization :-
-----------------------------------
In method level synchronization, the entire method gets synchronized so all the thread will wait at method level and only one thread will enter inside the synchronized area as shown in the diagram.(01-07-23)

Block level synchronization :-
---------------------------------
In block level synchronization the entire method does not get synchronized, only the part of the method gets synchronized so all the thread will enter inside the method but only one thread will enter inside the synchronized block as shown in the diagram 

Note :- In between method level synchronization and block level synchronization, block level synchronization is more preferable because all the threads can enter inside the method so only the PART OF THE METHOD GETS synchronized so only one thread will enter inside the synchronized block.
----------------------------------------------------------------
How synchronization controls multiple threads :
------------------------------------------------
Every Object has a lock(monitor) in java environment and this lock can be given to only one Thread at a time.

The thread who acquires the lock from the Object will enter inside the synchronized area, it will complete its task without any disturbance because at a time there will be only one thread inside the synchronized area(for single Object). This is known as Thread-safety in java.

The thread which is inside the synchronized area, after completion of its task while going back will release the lock so the other threads (which are waiting outside for the lock) will get a chance to enter inside the synchronized area by again taking the lock from the Object and submitting it to the synchronization mechanism.
This is how synchronization mechanism controls multiple Threads.

Note :- Synchronization logic can be done by senior programmers in the real time industry because due to poor synchronization there may be chance of getting deadlock.
--------------------------------------------------------------
Program on Method level synchronization :
-----------------------------------------
2 files :
---------
Table.java
----------
package com.ravi.syn_method;

public class Table 
{
	public synchronized void printTable(int num) 
	{
	  for(int i =1; i<=10; i++)
	  {		
	    try
	    {
	    	Thread.sleep(500);	
	    }
	    catch(Exception e)
	    {
	    	e.printStackTrace();
	    }
	    System.out.println(num+" X "+i+" = "+(num*i));
	  }
	}
}

SynchronizationMethod.java
---------------------------
package com.ravi.syn_method;

public class SynchronizationMethod 
{
	public static void main(String[] args) 
	{
		Table t1 = new Table(); //t1 has a lock
		
		
		Runnable r1 = ()-> t1.printTable(5);
		
		Runnable r2 = ()-> t1.printTable(10);
		
		Thread thread1 = new Thread(r1);
		Thread thread2 = new Thread(r2);
		thread1.start();  thread2.start();

	}

}
----------------------------------------------------------------
03-Jul-23
----------
Program on Block level synchronization :
----------------------------------------
BlockSynchronization.java
--------------------------
package com.ravi.advanced;

//Block level synchronization

class ThreadName
{
	public void printThreadName()
	{		
			//This area is accessible by all the threads  		
			String name = Thread.currentThread().getName();
			System.out.println("Thread inside the method is :"+name);
			
		   synchronized(this)  //synchronized Block
		   {  			   
			for(int i=1; i<=9; i++)
			{
				System.out.println("i value is :"+i+" by :"+name);
			}
			System.out.println(".............................");
		   }		
	}
}
public class BlockSynchronization 
{
	public static void main(String[] args)
	{
		ThreadName obj1 = new ThreadName(); 	
		
		Runnable r1 = () -> obj1.printThreadName();
		
		Thread t1 = new Thread(r1); t1.setName("Child1");
		Thread t2 = new Thread(r1); t2.setName("Child2");
		t1.start(); t2.start();				
	}
}
---------------------------------------------------------------
Problem with Object level synchronization :-
-------------------------------------------------
From the given diagram it is clear that there is no interference between t1 and t2 thread because they are passing throgh Object1 where as on the other hand there is no interferenec even in between t3 and t4 threads because they are also passing through Object2 (another object).

But there may be chance that with t1 Thread, t3 or t4 thread can enter inside the synchronized area at the same time, simillarly it is also possible that with t2 thread, t3 or t4 can enter inside the synchronized area so the conclusion is synchronization mechanism does not work with multiple Objects.
-----------------------------------------------------------------
ProblemWithObjectLevelSynchronization.java
-------------------------------------------
package com.ravi.advanced;
class PrintTable
{
	    public synchronized void printTable(int n)
	    {
	       for(int i=1; i<=10; i++)
	       {
	    	   System.out.println(n+" X "+i+" = "+(n*i));
	    	   try
	    	   {
	    		   Thread.sleep(500);
	    	   }
	    	   catch(Exception e)
	    	   {	    		   
	    	   }
	       }
	       System.out.println(".......................");
	    }	
}

public class ProblemWithObjectLevelSynchronization
{
	public static void main(String[] args) 
	{
		PrintTable pt1 = new PrintTable(); //lock1		
		PrintTable pt2 = new PrintTable(); //lock2
		
		Thread t1 = new Thread()  //Anonymous inner class concept
				{
			       @Override
			       public void run()
			       {
			    	   pt1.printTable(2);	//lock1
			       }			   
				};
		       	        
		        Thread t2 = new Thread()
				{
			       @Override
			       public void run()
			       {
			    	   pt1.printTable(3);	//lock1
			       }			   
				};
		                
		        Thread t3 = new Thread()
				{
			       @Override
			       public void run()
			       {
			    	   pt2.printTable(6);	//lock2
			       }			   
				};
		               
		        Thread t4 = new Thread()
				{
			       @Override
			       public void run()
			       {
			    	   pt2.printTable(9); //lock2
			       }			   
				};
				 t1.start();	t2.start();	 t3.start();  t4.start(); 
	}
}


Note :- From the above program it is clear that synchronization logic can't work with multiple Objects because Every Object has a lock in Java Environment.

In order to solve this problem "static synchronization" came into picture.

----------------------------------------------------------------
Static Synchronization :
---------------------------
If We declare a synchronized method as a static method then it is called static synchronization.

Now with static synchronization lock will be available at class level but not Object level.

To call the static synchronized method, object is not required so we can call the static method with the help of class name.

Unlike objects we can't create multiple classes for the same application.
-----------------------------------------------------------------
package com.ravi.advanced;
class MyTable     
{
	 public static synchronized void printTable(int n)  //static synchronization
	    {
	       for(int i=1; i<=10; i++)
	       {
	    	   try
	    	   {
	    		   Thread.sleep(100);
	    	   }
	    	   catch(InterruptedException e)
	    	   {
	    		  System.err.println("Thread is Interrupted...");
	    	   }
	    	   System.out.println(n+" X "+i+" = "+(n*i));
	       }
	       System.out.println("------------------------");
	    }
}
public class StaticSynchronization 
{
	public static void main(String[] args)
	{
			        Thread t1 = new Thread()
					{
				      @Override
				      public void run()
				      {
				    	 MyTable.printTable(5); 
				      }
					};		
					
					Thread t2 = new Thread()
					{
				      @Override
				      public void run()
				      {
				    	  MyTable.printTable(10);
				      }
					};										

					Runnable r3 = new Runnable() 
					{						
						@Override
						public void run() 
						{
							MyTable.printTable(15);							
						}
					};
					Thread t3 = new Thread(r3);
					
					t1.start();
					t2.start();	t3.start();
					
		}
}
----------------------------------------------------------------
04-Jul-23
---------
Thread Priority :
------------------
It is possible in java to assign priority to a Thread. Thread class has provided two predefined methods setPriority(int newPriority) and getPriority() to set and get the priority of the thread respectively.

In java we can set the priority of the Thread in number from 1- 10 only where 1 is the minimum priority and 10 is the maximum priority.

Whenever we create a thread in java by default its priority would be 5 that is normal priority.

The userdefined thread created as a part of main thread will acquire the same priority of main Thread.

Thread class has also provided 3 final static variables which are as follows :-

Thread.MIN_PRIORITY  :- 01

Thread.NORM_PRIORITY : 05

Thread.MAX_PRIORITY  :- 10

Note :- We can't set the priority of the Thread beyond the limit(1-10) so if we set the priority beyond the limit (1 to 10) then it will generate an exception java.lang.IllegalArgumentException
----------------------------------------------------------------
MainPriority.java
------------------
package com.ravi.advanced;

public class MainPriority 
{
	public static void main(String[] args) 
	{
		Thread t = Thread.currentThread();
						
		System.out.println("Main thread priority is :"+t.getPriority()); 
		
		Thread t1 = new Thread();
		System.out.println("User thread priority is :"+t1.getPriority()); 
	}

}
---------------------------------------------------------------
MainPriority1.java
-------------------
package com.ravi.advanced;

class ThreadP extends Thread
{
	@Override
	public void run()
	{
	  int priority = Thread.currentThread().getPriority(); 
	  
	  System.out.println("Child Thread priority is :"+priority);  
	  
	}
}
public class MainPriority1 
{
	public static void main(String[] args) 
	{
		Thread t = Thread.currentThread();
		t.setPriority(Thread.MAX_PRIORITY);
		
		//t.setPriority(11);  java.lang.IllegalArgumentException
		
		System.out.println("Main thread priority is :"+t.getPriority()); 		
		
		ThreadP t1 = new ThreadP();
		t1.start();		
	}
}
Note :- From the above program it is clear that child thread will always acquire the main thread priority.
----------------------------------------------------------------
package com.ravi.advanced;

class ThreadPrior1 extends Thread
{
	@Override
	public void run()
	{
		int count = 0;
		
		for(int i=1; i<=100000; i++)
		{
		  count++;	
		}
		
		System.out.println("running thread name is:"+Thread.currentThread().getName());
		System.out.println("running thread priority is:"+Thread.currentThread().getPriority());
	}	
	
	public static void main(String args[])
	{
		ThreadPrior1 m1 = new ThreadPrior1();
		ThreadPrior1 m2 = new ThreadPrior1();
		
		m1.setPriority(Thread.MIN_PRIORITY);//1
		m2.setPriority(Thread.MAX_PRIORITY);//10	
		
		m1.setName("Last");
		m2.setName("First");	
		
		m1.start();
		m2.start();
	}
}   
---------------------------------------------------------------
Thread life cycle in java :
-----------------------------
As we know a thread is well known for Independent execution and it contains a life cycle which internally contains 5 states (Phases). During the life cycle of a thread, It can pass from thses 5 states. At a time a thread can reside to only one state of the given 5 states.

1) New State (Born state)

2) Runnable state (Ready to Run state) [Thread Pool]

3) Running state

4) Waiting / Blocked state

5) Exit/Dead state


New State :-
-------------
Whenever we create a thread instance(Thread Object) a thread comes to new state OR born state. New state does not mean that the Thread has started yet only the object or instance of Thread has been created.

Runnable state :-
-------------------
Whenever we call start() on thread object, A thread moves to Runnable state i.e Ready to run state. Here Thread schedular is responsible to select/pick a particular Thread from Runnable state and sending that particular thread to Running state for execution.

Running state :-
-----------------
If a thread is in Running mode that means the thread is executing its own run() method. 

From Running state a thread can move to waiting state either by an order of thread schedular or user has written some method(wait(), join() or sleep()) to put the thread into temporarly waiting state.

From Running state the Thread may also move to Runnable state directly, if user has written Thread.yield() method explicitly.

Waiting state :-
------------------
A thread is in waiting state means it is waiting for it's time period to complete. Once the time period will be completed then it will re-enter inside the Runnable state to complete its remaining task.

Dead or Exit :
----------------
Once a thread has successfully completed its run method then the thread will move to dead state. Please remember once a thread is dead we can't restart a thread in java.
----------------------------------------------------------------
Thread.yield()
----------------
It is a static method of Thread class .

It will send a notification to thread schedular to stop the currently executing Thread and provide a chance to Threads which are in Runnable state to enter inside the running state having same priority or highest priority. Here The running Thread will directly move to Runnable state.

The Thread schedular can ignore this notification message given by currently executing Thread.

Here there is no gurantee that  after using yield() method the running Thread will move to Runnable state and from Runnable state the thread can move to Running state.

If the thread which is in runnable state is having low priority then the same running thread will continue its execution.
----------------------------------------------------------------
ThreadYieldMethod.java
-----------------------
package com.ravi.advanced;

public class ThreadYieldMethod 
{
	public static void main(String[] args) 
	{
		Runnable r1 = ()->
		{
			for(int i=1; i<=10; i++)
			{
				String name = Thread.currentThread().getName();

				System.out.println("i value is :"+i+" by thread :"+name);    
				
				 if(name.equals("Child1"))
					{
						Thread.yield();  //Give a chance to Child2 Thread
					}
			}
		};

		Thread t1 = new Thread(r1);
		Thread t2 = new Thread(r1);
		t1.setName("Child1"); t2.setName("Child2");
        
		t1.start();  t2.start();
	}
}
---------------------------------------------------------------
05-Jul-23
---------
Inter Thread Communication (ITC) :
-----------------------------------------
It is a mechanism to communicate two synchronized threads within the context to achieve a particular task.

In ITC we put a thread into wait mode by using wait() method and other thread will complete its corrosponding task, after completion of the task it will call notify() method so the waiting thread will get a notification to complete its remaining task.

ITC can be implemented by the following method of Object class.

1) public final void wait() throws InterruptedException

2) public native final void notify()

3) public native final void notifyAll()


public  final void wait() throws InterruptedException :-
-------------------------------------------------------------
It will put a thread into temporarly waiting state and it will release the lock.
It will wait till the another thread invokes notify() or notifyAll() for this object.

public native final void notify() :-
-------------------------------------
It will wake up the single thread that is waiting on the same object.

public native final void notifyAll() :-
----------------------------------------
It will wake up all the threads which are waiting on the same object.

*Note :- wait(), notify() and notifyAll() methods are defined in Object class but not in Thread class because these methods are related to lock(because we can use these methods from the synchronized area ONLY) and Object has a lock so, all these methods are defined inside Object class.


*What is the difference between sleep() and wait() 
----------------------------------------------------------
(Given in the diagram) 
-----------------------------------------------------------------
//Program that describes if we don't use ITC then the problem is ...
//Program that describes if we don't use ITC then the problem is ...

class Test implements Runnable
{
	int var=0;	
	@Override
	public void run()
	{
		for(int i=1; i<=10; i++)   
		{
			var = var + i;     //var = 6
			try
			{
				Thread.sleep(200);
			}
			catch (Exception e)
			{
			}		          
		}		
	}
}
class ITCProblem 
{
	public static void main(String[] args) 
	{
		Test t = new Test();
		Thread t1 = new Thread(t) ;		
		t1.start();
		try
		{
			Thread.sleep(200);
		}
		catch (Exception e)
		{
		}		
	    
		System.out.println(t.var);
	}
}
--------------------------------------------------------------
class SecondThread extends Thread 
{
	    int x = 0;
	    @Override
		public void run() 
		{
			//Child Thread is waiting here for the lock
			synchronized(this) 
			{
				for(int i=1;i<=100;i++)
				{
					x =  x + i;
				}
				notify();  //will give notification to waiting thread
			}
	 }
} 
public class InterThreadComm
{
public static void main(String [] args) 
{
		SecondThread b = new SecondThread();  
		b.start();
		synchronized(b)  //lock is taken by main thread
			{
				//suspended
				try 
				{
					System.out.println("Waiting for b to complete...");
					b.wait();   // after releasing the lock, waiting here 
					System.out.println("Main thread Awake");
				} 
				catch (InterruptedException e)
				{
				}
				System.out.println("Value is: " + b.x);
			}		
	}
}
----------------------------------------------------------------
//How to deposit and withdraw the amount with the co-ordination

class Customer
{  
     int balance=10000;    

	synchronized void withdraw(int amount)   //amount = 15000
	{  
		System.out.println("going to withdraw...");    
		if(balance < amount)
			{  
				System.out.println("Less balance; waiting for deposit...");  
					try
					{
						wait();
					}
					catch(Exception e){}  
			}  
		balance  = balance - amount;
		System.out.println("withdraw completed..."+balance+" is remaining balance"); 
	}    

	synchronized void deposit(int amount)  //amount =10000
		{  
			System.out.println("going to deposit...");  
			balance = balance + amount;  
			System.out.println("deposit completed... ");  
			notify();  
		}  
}   
class InterThreadBalance
{  
public static void main(String args[])
	{  
      Customer c=new Customer();    //lock is created here

		Thread t1 = new Thread()  //anonymous class concept
		{  
			@Override
			public void run()
			{
				c.withdraw(15000);
			}  
		};
		t1.start(); 		

		Thread t2 = new Thread()
		{  
			public void run()
			{
				c.deposit(10000);
			}  
		};
		
		t2.start();  
    }
} 

--------------------------------------------------------------
06-Jul-23
---------
Deadlock :
------------
It is a situation where two or more than two threads are in blocked state forever, here threads are waiting to acquire another thread resource without releasing it's own resource.

This situation happens when multiple threads demands same resource without releasing its own attached resource so as a result we get Deadlock situation and our execution of the program will go to an infinite state.

public class DeadlockExample
	{
  public static void main(String[] args) 
	 {
     String resource1 = "Ameerpet";  
     String resource2 = "Hyderabad";  

    // t1 tries to lock resource1 then resource2

    Thread t1 = new Thread() 
		{
	  @Override
      public void run() 
		  {
			  synchronized (resource1) 
				  {
			   System.out.println("Thread 1: locked resource 1");
			   try 
				   { 
				   Thread.sleep(1000);
				   } 
				   catch (Exception e) 
				   {}
				  
			   synchronized (resource2) //Inner synchronized block
			   {
				System.out.println("Thread 1: locked resource 2");
			   }
             }
      }
    };


    // t2 tries to lock resource2 then resource1
    Thread t2 = new Thread() 
		{
      @Override
      public void run() 
		  {
        synchronized (resource2) 
			{
          System.out.println("Thread 2: locked resource 2");
          try 
			  { 
			  Thread.sleep(1000);
			  } 
			  catch (Exception e) 
			{}

          synchronized (resource1) //Inner synchronized block
		  {
            System.out.println("Thread 2: locked resource 1");
          }
        }
      }
    };    
    t1.start();
    t2.start();
  }
}
---------------------------------------------------------------
06-Jul-23
----------
Remaining methods of Object class :
-----------------------------------
Object cloning in java :
----------------------------
Object cloning is the process of creating an exact copy of an existing object in the memory.

Object cloning can be done by the following process :

1) Creating Shallow copy 

2) Creating Deep copy

3) Using clone() method of java.lang.Object class

4) Passing Object reference to the Constructor


Shallow Copy :
-----------------
In shallow copy, we create a new reference variable which will point to same old existing object so if we make any changes through any of the reference variable then original object content will be modified.

Here we have one object and multiple reference variables.

ShallowCopy.java
--------------------
package com.ravi.clone_method;

class Student
{
	int id;
	String name;
	
	@Override
	public String toString() 
	{
		return "Id is :" + id + "\nName is :" + name ;
	}
	
}
public class ShallowCopy 
{
	public static void main(String[] args) 
	{
		Student s1 = new Student();
		s1.id = 111;
		s1.name = "Ravi";
        
		System.out.println(s1);
		System.out.println("After Shallow Copy");
		
		Student s2 = s1; //shallow copy
		s2.id = 222;
		s2.name = "Shankar";
		
		System.out.println(s1);
		System.out.println(s2);
	}

}
----------------------------------------------------------------
Deep Copy :
--------------
In deep copy, We create a copy of object in a different memory location. This is called a Deep copy. Here objects are created in two different memory locations so if we modify the content of one object it will not reflect another object.

DeepCopy.java
-------------
package com.ravi.clone_method;

class Employee
{
	int id;
	String name;
	
	@Override
	public String toString() 
	{
		return "Employee [id=" + id + ", name=" + name + "]";
	}	
}

public class DeepCopy 
{
	public static void main(String[] args)
	{
		Employee e1 = new Employee();
		e1.id = 111;
		e1.name = "Ravi";
		
		Employee e2 = new Employee();
		e2.id = e1.id;
		e2.name = e1.name;
		
		System.out.println(e1 +" : "+e2);
		
		e2.id = 222;
		e2.name = "shankar";
		System.out.println(e1 +" : "+e2);
	}

}
---------------------------------------------------------------

protected native Object clone() throws CloneNotSupportedException
----------------------------------------------------------------
Object cloning in Java is the process of creating an exact copy of the original object. In other words, it is a way of creating a new object by copying all the data and attributes from the original object. 

The clone method of Object class creates an exact copy of an object

In order to use clone() method , a class must implement Clonable interface because we can perform cloning operation on Cloneable objects only.

We can say an objeect is a Cloneable object if the corrosponding class  implements Cloneable interface.

It throws a checked Exception i.e CloneNotSupportedException

---------------------------------------------------------------
package com.ravi.clone_method;

class Customer implements Cloneable
{
	int id;
	String name;	
	
	@Override
	protected Object clone() throws CloneNotSupportedException 
	{
		return super.clone();
	}

	@Override
	public String toString()
	{
		return "Customer [id=" + id + ", name=" + name + "]";
	}	
}

public class CloneMethod 
{
	public static void main(String[] args) throws CloneNotSupportedException 
    {
		Customer c1 = new Customer();	
		c1.id = 111;
		c1.name = "Ravi";
		
		Customer c2 = (Customer) c1.clone(); //downcasting
		System.out.println(c1 +" : "+c2);
		
		
		c2.id = 333;
		c2.name = "shankar";
		System.out.println(c1 +" : "+c2);
		
		System.out.println(c1.hashCode());
		System.out.println(c2.hashCode()); 
	}
}
----------------------------------------------------------------
protected void finalize() throws Throwable  :
---------------------------------------------------
It is a predefined method of Object class.

Garbage Collector automatically call this method just before an object is eligible for garbage collection to perform clean-up activity.

Here clean-up activity means closing the resources associated with that object like file connection, database connection, network connection and so on we can say resource de-allocation.

Note :- JVM calls finalize method only one per object.

Student.java
-----------

package com.ravi.finalize_method;

public class Student 
{
    int id;
    String name;
    
    public Student(int id, String name)
    {
    	this.id= id;
    	this.name = name;
    }    
    
	@Override
	public String toString() 
	{
		return "Id is :"+id+"\nName is :"+name;
	}

	@Override
	protected void finalize() 
	{
      System.out.println("JVM call this finalize method...");		
	}


	public static void main(String[] args) throws InterruptedException 
	{
      Student s1 = new Student(111,"Ravi");
      System.out.println(s1.hashCode());
      System.out.println(s1);
      
      s1 = null;
      System.gc(); //Explicitly calling Garbage Collector
      Thread.sleep(3000);
      System.out.println(s1);
	}
}
---------------------------------------------------------------
07-Jul-23
---------
Input Output in java :
-------------------------
In order to perform input and output operation in java, Java software people has provided a package called java.io

By using this package java.io, we can read the data from client, we can create the file and we can perform read/write operation to the file and so on.

How to take the input from the user using java.io package :
---------------------------------------------------------------
java.io package has provided the following two classes to accept the input from the user.

1) DataInputStream (Deprecated now)

2) BufferedReader

How to create the Object for the classes :
-----------------------------------------------
DataInputStream :-
----------------------
DataInputStream d = new DataInputStream(System.in);

BufferedReader :
-------------------
It provides more faster technique because it internally stores the data in a buffer and it is always recomended to read the data from the buffer.

InputStreamReader isr = new InputStreamReader(System.in);
BufferedReader br = new BufferedRedaer(isr);

                              OR
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

Working with methods :
---------------------------
1) public int read() :- Used to read a single character from the source. It returns the UNICODE value of the character. If the data is not available then it will return -1.
				 
				 
2) public String readLine() :- Used to read multiple characters or a complete line from the source(Keyboard or File). It returns String value.
---------------------------------------------------------------
//WAP in java to read your name from the keyboard

import java.io.*;
public class  ReadName
{
	public static void main(String[] args) throws IOException 
	{
      //DataInputStream dis = new DataInputStream(System.in);

	  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	  System.out.print("Enter your Name :");
	  String name = br.readLine();
	  System.out.println("Your name is :"+name);
	}
}
--------------------------------------------------------------
//WAP to read your age from the keyboard
import java.io.*;
class ReadInteger 
{
	public static void main(String[] args) 
	{
		try
		{
			BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
			System.out.print("Enter your Age :");
			String ag = br.readLine();

            //Converting String to integer
			int age = Integer.parseInt(ag);
            System.out.println("Your Age is :"+age);
            if(age>18)
			{
				System.out.println("Go for a movie");
			}
			else
			{
				System.out.println("You are minor ..try after some year");
			}
			
		}
		catch (IOException e)
		{
			e.printStackTrace();
		}
			
	}
}
---------------------------------------------------------------
//WAP in java to read a float value(salary) from the keyboard
import java.io.*;
class ReadSalary 
{
	public static void main(String[] args) throws IOException
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		System.out.print("Please enter your Salary :");
		String sal = br.readLine();

        //Converting String to float value
		float salary = Float.parseFloat(sal);

		System.out.println("Your salary is :"+salary);

	}
}
-------------------------------------------------------------
//WAP in java to read a character i.e gender from the keyboard
import java.io.*;
class ReadCharacter 
{
	public static void main(String[] args) throws IOException
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		System.out.print("Enter your Gender :");

		 char ch = (char) br.read();
		 System.out.println("Your Gender is :"+ch);

		
	}
}
--------------------------------------------------------------
//WAP in java to read employee data
import java.io.*;
class EmpDataDemo
{
public static void main(String [] args) throws IOException
{
	 BufferedReader br = new BufferedReader
	(new InputStreamReader(System.in));

	System.out.print("Enter id: ");
	int id = Integer.parseInt(br.readLine());  

	System.out.print("Enter sex (M/F): ");	
	 char gen = br.readLine().charAt(0); //Male \n
	           
	  
	System.out.print("Enter name: ");
	String name = br.readLine();

	System.out.println("Id = "+id);
	System.out.println("Sex = "+gen);
	System.out.println("Name = "+name);
	}
}





/*
Enter Id : 111 \n       readLine();
   
Enter M/F : Male \n    read() -> It will read only single character i.e M

Enter Name : ale

*/

---------------------------------------------------------------
08-Jul-23
----------
File Handling in java :
-------------------------
What is the need of File Handling ?
-----------------------------------
 As we know variables are used to store some meaningful value in our program but once the execution of the program is over, now we can't get those values so to hold those values permanently in our memory we use files.

Files are stored in the secondary storage devices so we can use/read the data stored in the file anytime according to our requirement. 

In order to work with File system java software people has provided number of predefined classes like File, FileInputStream, FileOutputStream and so on. All these classes are available in java.io package. We can read and write the data in the form of Stream.
---------------------------------------------------------------
08-Jul-23
----------
Streams in java :
--------------------
A Stream is nothing but flow of data or flow of characters to both the end.
Stream is divided into two categories

1) byte oriented Stream :- 
    ------------------------
It used to handle characters, images, audio and video file in binary format.  

2) character oriented Stream :-
--------------------------------
It is used to handle the data in the form of characters or text.

Now byte oriented or binary Stream can be categorized as "input stream" and "output stream". input streams are used to read or receive the data where as output streams are used to write or send the data.

Again Character oriented Stream is divided into Reader and Writer. Reader is used to read() the data from the file where as Writer is used to write the data to the file.

All Streams are represented by classes in java.io package. InputStream is the super class for all kind of input operation where as OutputStream is the super class for all kind of output Operation for byte oriented stream.

Where as Reader is the super class for all kind reading operation where as Writer is the super class for all kind of writing operation in character oriented Stream.
---------------------------------------------------------------
File :-
-----
It is a predefined class in java.io package through which we can create file and directory. By using this class we can verify whether the file is existing or not.

File f = new File("abc.txt");

The above statement will not create any file, It actually create the file object and perform one of the following two task.
   a) If abc.txt does not exist, It will not create it
   b) if abc.txt does exist, the new file object will be refer to the referenec variable f

Now if the file does not exist and to create the file we should use createNewFile() method as shown below.

File f = new File("Hello.txt");
      f.createNewFile();

File class has also provided a method called exists() through which we can verify the corrosponding file is available or not. The return type of this method is boolean.

Note :- The return type of both the methods i.e exists() and createNewFile() are boolean.
----------------------------------------------------------------
import java.io.*;  
public class File0 
	{
		public static void main(String[] args) 
		{
			try 
				{
					File f = new File("D:\\new\\Batch19.txt");

                    if(f.exists())
					{
						System.out.println("File is existing");
					}
					else
					{
						System.out.println("File is not existing");
					}

					if (f.createNewFile())
					   {
						 System.out.println("File created: " + f.getName());
                       }
					   else  
						{
                             System.out.println("File is already existing....");
                         }								  
                  }
				  catch (IOException e)
                 {
					System.err.println(e);
				} 
		}
}

Note :- File class is also containing getName() method to get the name of the file.
----------------------------------------------------------------
FileOutputStream :-
--------------------
It is a predefined class available in java.io package. The main purpose of this class to create a new file and write the data to the file. Whenever we want to write the data into the file using FileOutputStream class then data must be available into the form of byte because It is byte-oriented class.

Note :- String class has provided a method called getBytes() through which we can read the String data in byte format and the return type of this method is byte[].(byte array)

Eg:-
		String x = "India is Great";
		byte b [] = x.getBytes();

Note :- try with resources are used to automatically close our resources.
----------------------------------------------------------------
import java.io.*;
public class File1
{
     public static void main(String args[]) 
     {
        try(FileOutputStream fout = new FileOutputStream("D:\\new\\ABC.txt"))
         {
         String s = "India is a Great country";
		 byte b[] = s.getBytes();
		 fout.write(b);

		 System.out.println("Success....");
		 }
		 catch(Exception e)
		 {
			 e.printStackTrace();
		 }
     }
}

In binary Stream, whenever we want to write the data, the data must be available in byte format, If we want to print the data
on the console(Monitor) the data must be converted into char.
----------------------------------------------------------------
10-Jul-23
--------
CreateAndWrite.java
--------------------
import java.io.*;
public class CreateAndWrite 
{
	public static void main(String[] args) throws IOException
	{
		FileOutputStream f = new FileOutputStream("D:/new/Batch19.txt");
		try(f)
		{
			String str = "Hello India";
			 byte []b = str.getBytes();
			f.write(b);
			System.out.println("File Created ......");
		}
		catch(Exception e)
		{
          e.printStackTrace();
		}
	}
}
----------------------------------------------------------------------
FileInputStream :
--------------------
It is a predefined class available in java.io package. The main purpose of this class to read the content/data from the existing file.
Using this class we can read the data into UNICODE values by using read() method so the data must be converted into char, to print on the console.
--------------------------------------------------------------------
//Reading tha data from the file
import java.io.*;
class File2
{
     public static void main(String s[]) 
     {         
		 try( FileInputStream fin = new FileInputStream("D:\\new\\Batch19.txt"))
		 {
          while(true)
           {
             int  i = fin.read();
              if(i == -1)
                   break;
              System.out.print((char)i);			 
           }     
		 }
		 catch(IOException e)
		 {
			  e.printStackTrace();
		 }         
     }
}
--------------------------------------------------------------------Limitation of FileInputStream class :
-----------------------------------------
As we know FileInputStream class is used to read the content from the file but it can read the data from a single file only that means if we want to read the data from two files at the same time then we should use a separate Stream called SequenceInputStream.

SequenceInputStream :
-------------------------
It is a predefined class available in java.io package. This class is used to read the data from two files at the same time.
--------------------------------------------------------------------
//Proram to read the data from two files at the same time
import java.io.*;
class File4
{
     public static void main(String args[]) throws IOException
     {
         FileInputStream f1 = new FileInputStream("File1.java");
         FileInputStream f2 = new FileInputStream("File2.java");

         SequenceInputStream s = new SequenceInputStream(f1,f2);

		 try(f1; f2; s)
		 {
         int i;
         while(true)
		 {
			  i = s.read();
			   if(i==-1)
				  break;
			  System.out.print((char)i);		 
		 }     
		 }
		 catch(IOException e)
		 {
			 e.printStackTrace();
		 }
     } 
}
-------------------------------------------------------------------
//Reading the data from two files and writing the data to a single file
import java.io.*;
class File5
{
	public static void main(String x[]) throws IOException
	{
		   FileInputStream f1 = new FileInputStream("File3.java");
           FileInputStream f2 = new FileInputStream("File4.java");

           FileOutputStream fout = new FileOutputStream("D:\\new\\Naresh.txt");

           SequenceInputStream s = new SequenceInputStream(f1,f2);

           int i;
		   try(f1; f2; fout; s)
		   {
           while(true)
           {
			   i = s.read();
			   if(i==-1)
				    break;
               System.out.print((char)i);
               fout.write((byte)i);
           }
		   }
		   catch(IOException e)
		   {
			   e.printStackTrace();
		   }
		   System.out.println("File Created Successfully");
     }
}
--------------------------------------------------------------------
Limitation of FileOutputStream :-
-----------------------------------
It is used to write the data to a single file only. It is not suitable if we want to write the data more then one file at a time. In order to write the data more than one file we should use a seperate Stream called ByteArrayOutputStream.

ByteArrayOutputStream :-
---------------------------
It is a predefined class available in java.io package. By using this class we can write the data to multiple files. ByteArrayOutputStream class provides a method called writeTo(), through which we can write the data to multiple files.
--------------------------------------------------------------------
//Program to write the data on multiple files.
import java.io.*;
class File6
{
     public static void main(String args[]) throws IOException
     {
			FileInputStream fin = new FileInputStream("File1.java");

			FileOutputStream f1 = new FileOutputStream("D:\\new\\a.txt");  
			FileOutputStream f2 = new FileOutputStream("D:\\new\\b.txt");
			FileOutputStream f3 = new FileOutputStream("D:\\new\\c.txt"); 			
			
			ByteArrayOutputStream bout = new 
			ByteArrayOutputStream(); 

			try(fin; f1; f2; f3; bout)
		    {
           int i;
			while((i = fin.read()) != -1)
           {
               bout.write((byte)i); //writing tha data to ByteArrayOutputStream
           }
           bout.writeTo(f1);
           bout.writeTo(f2);
		   bout.writeTo(f3);
		   
           bout.flush();  //clear the buffer for reusing of ByteArrayOutputStream
           System.out.println("Success");
			}
			catch(IOException e)
		    {
				e.printStackTrace();
		    }
     }
}

-------------------------------------------------------------------
11-Jul-23
----------
//Working with images
import java.io.*;
class File7 
{
	public static void main(String[] args) throws IOException
	{
		 FileInputStream fin = new FileInputStream("D:\\image\\Sunset.jpg");

         FileOutputStream f1 = new FileOutputStream("D:\\new\\a.jpg");
         FileOutputStream f2 = new FileOutputStream("D:\\new\\b.jpg");
		 FileOutputStream f3 = new FileOutputStream("D:\\new\\c.jpg");

         ByteArrayOutputStream bout = new ByteArrayOutputStream();

         try(fin; f1; f2; f3; bout)
		 {
         int i;
         while((i = fin.read()) != -1)
         {
               bout.write((byte)i);
         }
         bout.writeTo(f1);
         bout.writeTo(f2);
		 bout.writeTo(f3);
         System.out.println("success...");
		 bout.flush();
         }
		 catch(IOException e)
		{
			 e.printStackTrace();
		}
	}
}
--------------------------------------------------------------------
BufferedOutputStream :-
--------------------------
It is a predefined class available in java.io package.

Whenever we use the class FileOutputStream the data will be available on the Stream but not in the buffer so there may be chance of miss memory management, It is always preferable that the data should be in the buffer.

By using this BufferedOutputStrean now the data is in the buffer so the execution will become more faster.
----------------------------------------------------------------------
//Program to put the data in the buffer for fast execution
import java.io.*;
class File8
{
      public static void main(String args[]) throws IOException
      {
           FileOutputStream fout = new FileOutputStream("D:\\new\\Hyd.txt");

           BufferedOutputStream bout = new BufferedOutputStream(fout);
          
		   try(fout ; bout)
		   {
           String s = "Hyderabad is a nice city. It is in India";
           byte b[] = s.getBytes();
           bout.write(b);
		   System.out.print("success..."); 
		  }
		  catch(IOException e)
		  {
			  e.printStackTrace();
		  }
      }
}
---------------------------------------------------------------------
BufferedInputStream :-
-------------------------
It is a predefined class available in java.io package. Whenever we use FileInputStream to read the data/content from the file the data will be available on the Stream but not in the buffer so there may be a chance of miss memory management so we should take the data into the buffer by using BufferedInputStream class so overall the execution will become faster.
----------------------------------------------------------------------
//BufferedInputStream
import java.io.*;
class File9
{
      public static void main(String args[]) throws IOException
      {
           FileInputStream fin = new FileInputStream("D:\\new\\Hyd.txt");
           BufferedInputStream bin = new BufferedInputStream(fin);
		   try(fin ; bin)
		   {
           int i;
           while((i = bin.read()) != -1)
           {
                System.out.print((char)i); 
           }
           }
		   catch(IOException e)
		  {
			   e.printStackTrace();
		  }
		  System.out.println();
      }
}
----------------------------------------------------------------------
Writing and Reading the primitive data to the files :-  
----------------------------------------------------------
It is possible to write the primitive data(byte,short,int, long, float, double, char and boolean) to the file. In order to write primitive data to the file we should use a predefined class available in java.io package called DataOutputStream. It provides various methods like writeByte(), writeShort(), writeInt() and so on to write the data to the file.

If we want to read the primitive data from the file we can use a predefined class available in java.io package called DataInputStream, this class provides various methods like readByte(), readShort(),
readInt() and so on.

Note :- For writing String into a file we have writeBytes() and to read the String data from the file we have readLine() method.

[DataInputStream class is deprecated now, so compilation warning ]
----------------------------------------------------------------------
//DataOutputStream and DataInputStream
import java.io.*;
class File10
{
      public static void main(String args[]) throws IOException
      {
          FileOutputStream fout = new FileOutputStream("D:\\new\\Primitive.txt");

          DataOutputStream dout = new DataOutputStream(fout);
		  try(fout ; dout)
		  {
          dout.writeBoolean(true);
          dout.writeChar('A');
          dout.writeByte(Byte.MAX_VALUE);
          dout.writeShort(Short.MAX_VALUE);
          dout.writeInt(Integer.MAX_VALUE); 
          dout.writeLong(Long.MAX_VALUE);
          dout.writeFloat(Float.MAX_VALUE); 
          dout.writeDouble(Math.PI);//PI is a final static variable
		  dout.writeBytes("Hello India...");
          dout.flush();//For reuse purpose
          }
		  catch(IOException e)
		  {
			  e.printStackTrace();
		  }
		  System.out.println("Reading the Primitive data from the files!!!");
          
		  FileInputStream fin = new FileInputStream("D:\\new\\Primitive.txt");
          DataInputStream din = new DataInputStream(fin);
		  try(fin ; din)
		  {
          boolean f = din.readBoolean();
          char c = din.readChar();
          byte b = din.readByte();
          short s = din.readShort();
          int i = din.readInt();
          long l = din.readLong();
          float ft = din.readFloat();
          double d = din.readDouble();
		   String x=  din.readLine();//for reading String (deprecated)

          System.out.println(f +"\n"+c+"\n"+b+"\n"+s+"\n"+i+"\n"+l+"\n"+ft+"\n"+d+"\n"+x);
		  }
		  catch(IOException e)
		  {
			  e.printStackTrace();
		  }
      }
}
----------------------------------------------------------------------
* Serialization and De-serialization :
---------------------------------------
It is a technique through which we can store the object data in a file. Storing the object data into a file is called Serialization on the other hand Reading the object data from a file is called De-serialization.

In order to perform serialization, a class must implements Serializable interfcae, predefined marker interface in java.io package.

Java.io package has also provided a predfined class called ObjectOutputStream to perform serialization i.e writing Object data to a file using writeObject() method.

where as ObjectInputStream is also a predefined class available in java.io package through which we can read the Object data from a file using readObject(). The return type of readObject() is Object.
-----------------------------------------------------------------
3 files :
----------
Employee.java
-------------
import java.io.*;
import java.util.Date;
public class Employee implements Serializable
{
	private  int id;
	private  String name;
	private float sal;
	private Date doj;

	public Employee(int i, String n, float s, Date d)
	{
		id=i;
		name=n;
		sal=s;
		doj=d;
	}

	public void display()
	{
		System.out.println(id+"\t"+name+"\t"+sal+"\t"+doj);
	}

	public static Employee getData() throws IOException  
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		System.out.print("Enter emp id :");
		int id = Integer.parseInt(br.readLine());

		System.out.print("Enter Name :");
		String name=br.readLine();

		System.out.print("Enter Salary :");
		float sal=Float.parseFloat(br.readLine());

		Date d = new Date();	
		
		Employee e = new Employee(id,name,sal,d);
		return e;		
	}
}





StoreObj.java
--------------
//ObjectOutputStream is used to store objects to a file

import java.io.*;
import java.util.*;
class  StoreObj
{
	public static void main(String[] args) throws IOException
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		FileOutputStream fos = new FileOutputStream("D:\\new\\ObjectEmployee.txt");

		ObjectOutputStream oos = new ObjectOutputStream(fos);

		try(br ; fos; oos)
		{
			System.out.print("How many objects you want to write?");
			int n =Integer.parseInt(br.readLine());     //n = 3 
			
			for(int i=0; i<n; i++)                           
			{
				Employee e1 = Employee.getData();
				oos.writeObject(e1);
			}
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
		
	}
}


GetObj.java
------------
//ObjectInputStream is used to read objects from a file (de-serialization)

import java.io.*;
class GetObj
{
	public static void main(String[] args)  throws IOException
	{
		FileInputStream fis = new FileInputStream("D:\\new\\ObjectEmployee.txt");

		ObjectInputStream ois = new ObjectInputStream(fis);

		try(fis; ois)
		{
			Employee e;
			while((e = (Employee) ois.readObject()) !=null)
			{
				e.display();
			}
		}
		catch (Exception ee) 
		{
			System.out.println("End of file reached :"+ee);
		}
		
	}
}
-----------------------------------------------------------------
Program on serialization and De-serialization
---------------------------------------------
3 files
--------
Bank.java
----------
package com.ravi.ser_deser;

import java.io.Serializable;
import java.util.Scanner;

public class Bank implements Serializable
{
	private Integer ifscCode;
	private transient String bankName;
	private String bankAddress;
	
	public Bank(Integer ifscCode, String bankName, String bankAddress) 
	{
		super();
		this.ifscCode = ifscCode;
		this.bankName = bankName;
		this.bankAddress = bankAddress;
	}

	@Override
	public String toString() 
	{
		return "Bank [ifscCode=" + ifscCode + ", bankName=" + bankName + ", bankAddress=" + bankAddress + "]";
	}
	
    public static Bank getBankObject()
    {
    	Scanner sc = new Scanner(System.in);
        System.out.print("Enter Bank IFSC code :");
        int code = sc.nextInt();
        System.out.print("Enter Bank Name :");
        String name = sc.nextLine();
        name = sc.nextLine();
        System.out.print("Enter Bank Address :");
        String addr = sc.nextLine();
        
       	return new Bank(code, name, addr);
    }
	
	
}






BankSerialization.java
-----------------------
package com.ravi.ser_deser;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.util.Scanner;

public class BankSerialization 
{
	public static void main(String[] args) throws IOException
	{
		FileOutputStream fout = new FileOutputStream("D:\\new\\Bank.txt");
		ObjectOutputStream oos = new ObjectOutputStream(fout);
		Scanner sc = new Scanner(System.in);
		try(fout; oos; sc)
		{
			System.out.print("How many Objects you want to write :");
			int numberOfObjects = sc.nextInt();
			
			for(int i=1; i<=numberOfObjects; i++)
			{
				Bank bankObject = Bank.getBankObject();
				oos.writeObject(bankObject);
			}
			
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
		System.out.println("Object stored in the file successfully!!!!");
	}

}


BankDeserialization.java
-------------------------

package com.ravi.ser_deser;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;

public class BankDeserialization 
{
   public static void main(String[] args) throws IOException 
   {
	   FileInputStream fin = new FileInputStream("D:\\new\\Bank.txt");
	   ObjectInputStream ois = new ObjectInputStream(fin);
	   
	   try(fin; ois)
	   {
		   Bank b;
		   
		   while((b =(Bank)ois.readObject()) != null)
		   {
			   System.out.println(b);
		   }
		   
	   }
	   catch(Exception e)
	   {
		   System.err.println("End of file reached :"+e);
	   }
	
   }
}

Note :- If we declare any filed with transient keyword at the time 
        of serialization then that particular field will not be 
	serialized and it will just provide the default value.

	Example :- 
	private transient Integer ifscCode;

	Now this ifscCode field will provide null value
-------------------------------------------------------------------
Working With Character Oriented Stream :
-------------------------------------------------
FileWriter class :
------------------
It is a predefined class available in java.io package, Using this class we can directly write String (collection of characters) to the file.

Actually It is a character oriented Stream where as if we work with FileOutputStream class, It is byte oriented Stream.

//FileWriter
import java.io.*;
class File11
{
    public static void main(String args[]) throws IOException
    {
         FileWriter fw = new FileWriter("D:\\new\\HelloIndia.txt");
		 BufferedWriter bw = new  BufferedWriter(fw);

		 try(fw; bw)
		 {
         bw.write("Hello India, It is a great country.");
         System.out.print("Success....");
		 }
		 catch(IOException e)
		  {
			  e.printStackTrace();
		  }
    }
}
--------------------------------------------------------------------
//FileWriter
import java.io.*;
class File12
{
    public static void main(String args[]) throws IOException
    {
		FileWriter fw = new FileWriter("D:\\new\\Data.txt");
		BufferedWriter bw = new  BufferedWriter(fw);

        try(fw;bw)
		{        
		 char c[ ] =  {'H','E','L','L','O', ' ',' ','W','O','R','L','D'};
		 
         bw.write(c);
         System.out.println("Success....");
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
    }
}
--------------------------------------------------------------------
FileReader class :
--------------------
It is a predefined class available in java.io package, It is a character oriented Stream. The main purpose of this class to read the data in the character format directly from the file.
---------------------------------------------------------------------
//FileReader
import java.io.*;
class File13
{
    public static void main(String args[]) throws IOException
    {
         FileReader fr = new FileReader(args[0]); //Command Line Arg
		 BufferedReader br = new BufferedReader(fr);
		 try(fr ; br)
		 {
         while(true)
         {
              int i = br.read();
              if(i == -1)
                   break;
              System.out.print((char)i);
         }
		 }
		 catch(IOException e)
		 {
			  e.printStackTrace();
		 }         
    }
}

---------------------------------------------------------------------
import java.io.*;
class File14
{
  public static void main(String[] args) throws IOException
	{
       FileReader fr = new FileReader("D:\\new\\Sunset.jpg");
	   FileWriter  fw = new FileWriter("D:\\Sunset.jpg");
	   
		try(fr;fw)
		{
		     int i;
		    while((i=fr.read())!= -1)
			{
				fw.write(i);
			}
		}
		catch(Exception e)
		{
		}
    }
}


Note :- Here we are trying to write the image file using FileWriter class which is not possible because image internally contains binary data and FileWriter is used to write character Stream.
---------------------------------------------------------------------
PrintWriter :
--------------
It is a predefined class available in java.io package. The main purpose of this class to write the primitive data into text format.

Methods :
-----------
printf() :- It is a predefined method of PrintWriter class which takes two parameter 
a) Specification of the data so we can print the data according to specification(Formatted String)
b) Parameter to print the actual data.
---------------------------------------------------------------------
//PrintWriter 
import java.io.*;
class File15
{
  public static void main(String[] args) throws IOException
	{
	  PrintWriter writeData = new PrintWriter("D:\\new\\Roll.txt");
      try(writeData)
	 {      
      int roll = 15;
      //Writing primitive data into text format
      writeData.printf("My roll number is : %d ", roll);    
    }
    catch(Exception e) 
	{
      e.printStackTrace();
    }
  }
}
---------------------------------------------------------------------
14-Jul-23
---------

Collections framework is nothing but handling individual Objects(Collection Interface) and Group of objects(Map interface). We know only object can move from one network to another network.

A collections framework is a class library to handle group of Objects.

It is implemented by using java.util package.

It provides an architecture to store and manipulate group of objects.

All the operations that we can perform on data such as searching, sorting, insertion and deletion can be done by using collections framework because It is the data structure of Java.

The simple meaning of collections is single unit of Objects.

It provides the following sub interfaces :

1) List (Accept duplicate elements)
2) Set (Not accepting duplicate elements)
3) Queue (Storing and Fetching the elements based on some order i.e FIFO)
---------------------------------------------------------------------
The following are the commonly used methods available in Collection(I)
----------------------------------------------------------------------
a) public boolean add(Object element) :- It is used to add an item/element in the collection.

b) public boolean addAll(Collection c) :- It is used to insert the specified collection elements in the existing collection(For merging the Collection)

c) public boolean remove(Object element) :- It is used to delete an element from the collection.

d) public boolean removeAll(Collection c) :- It is used to delete all the elements from the existing collection.

e) public boolean retainAll(Collection c) :- It is used to retain all the elements from existing element.

f) public int size() :- It is used to find out the size of the Collection.

g) public void clear() :- It is used to clear all the elements at once from the Collection.
--------------------------------------------------------------------
15-Jul-23
----------
List interface :
----------------
a) It is the sub interface of Collection interface 

b) It can accept duplicate elements

c) We can perform sorting Operation on List interface manually.

d) It stores the elements on the basis of index just like an array.

Methods of List interface :
------------------------------
1) public boolean isEmpty() :- Verify whether List is empty or not

2) public void clear() :- Will clear all the elements

3) public int size() :- To get the size of the Collections

4) public void add(int index, Object o) :- Insert the element based on the index position.

5) public boolean addAll(int index, Collection c) :- Insert the Collection based on the index position

6) public Object get(int index) :- To retrieve the element based on the index position

7) public Object set(int index, Object o) :- To override or replace the element    based on the index position

8) public object remove(int index) :- remove the element based on the index position

9) public boolean remove(Object element) :-  remove the element based on the object element

10) public int indexOf() :- index position of the element

11) public int lastIndex() :- last index position of the element

12) public Iterator iterator() :- To fetch or iterate or retrieve the elements from Collection in forward direction only.

13) public ListIterator listIterator() :- To fetch or iterate or retrieve the elements from Collection in forward and backward direction
--------------------------------------------------------------------
How many ways we can fetch/retrieve the Collection Objects :
---------------------------------------------------------------------
There are 7 ways through which we can fetch or retrieve the Collection Objects

1) By using Enumeration interface 

2) By using Ordinary for loop

3) By using  for each loop

4) By using Iterator interface

*5) By using ListIterator interface

*6) By using  forEach(Consumer cons) method

*7) By using Method Reference (::)

Note :- Among all these 7 ways Enumeration, Iterator and ListIterator are cursor.

------------------------------------------------------------------------------------
Enumeration :
----------------
It is a predefined interface available in java.util package from JDK 1.0 onwards.

We can use Enumeration interface to fetch or retrieve the Objects one by one from the Collection

We can create Enumeration object by using elements() method of the respective Collection class.

public Enumeration elements();

Enumeration interface contains two method :
---------------------------------------------------
1) public boolean hasMoreElements() :- It will return true if the Collection is having more elements.

2) public Object nextElement() :- It will return collection object so return type is Object.
------------------------------------------------------------------------------------
Iterator interface :
----------------------
It is a predefined interface available in java.util package available from 1.2 version.

It is used to fetch/retrieve the elements from the Collection in forward direction only.

public Iterator iterator();

Example :
-----------
 Iterator itr = v.iterator();

Now, Iterator interface has provided two methods 


public boolean hasNext() :- 

It will verify the element is available in the next position or not, if available it will return true otherwise it will return false.


public Object next() :- It will return the collection object.
------------------------------------------------------------------------------------
ListIterator interface :
-------------------------
It is a predefined interface available in java.util package and it is the sub interface of Iterator.

It is used to retrieve the Collection object in both the direction i.e in forward direction as well as in backward direction.

public ListIterator listIterator();

Example :
-----------
ListIterator lit =   v.listIterator();

1) public boolean hasNext() :- 
It will verify the element is available in the next position or not, if available it will return true otherwise it will return false.

2) public Object next() :- It will return the next position collection object.

3) public boolean hasPrevious() :- 
It will verify the element is available in the previous position or not, if available it will return true otherwise it will return false.


4) public Object previous () :- It will return the previous position collection object.

Note :- Apart from these 4 methods we have add(), set() and remove() method.
------------------------------------------------------------------------------------
By using forEach() method :
--------------------------------
From java 1.8 onwards every collection class provides a method forEach() method, this method takes Consumer functional interface as a  parameter
 as shown in the follwing program.

ForEachMethod.java
-------------------
package com.ravi.fetching_collection_object;

import java.util.Vector;
import java.util.function.Consumer;

public class ForEachMethod {

	public static void main(String[] args)
	{
		Vector<String> v = new Vector<String>();
		v.add("Hyderabad");
		v.add("Vijaywada");
		v.add("Chennai");
		v.add("Bangalore");
		v.add("Ameerpet");
      
                //Anonymous inner class
		Consumer<String> cons = new Consumer<String>() 
		{
			@Override
			public void accept(String t)
			{
				System.out.println(t);		
			}			
		};

		 v.forEach(cons);
	}

}
------------------------------------------------------------------------------------
By using Method reference :
---------------------------------
Now we can also use Method Reference (::) to print the value from the Collection as shown below

v.forEach(System.out::println);

Note :- The following program exaplains that thare are total 7 ways to fetch the Collection object from Collections


ObjectRetrieval.java
---------------------

package com.ravi.fetching_collection_object;

import java.util.Collections;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.Vector;

public class ObjectRetrieval 
{
	public static void main(String[] args) 
	{
		Vector<String> v = new Vector<String>();
		v.add("Hyderabad");
		v.add("Vijaywada");
		v.add("Chennai");
		v.add("Bangalore");
		Collections.sort(v); //sorting
		
		System.out.println("Fetching the String Object using Enumeration :");
	    Enumeration<String> ele = v.elements();
	    while(ele.hasMoreElements())
	    {
	    	System.out.println(ele.nextElement());
	    }
	    
	    System.out.println("Fetching the String Object using Ordinary for loop :");
	    
	    for(int i =0; i<v.size(); i++)
	    {
	    	System.out.println(v.get(i));
	    }
		
	    System.out.println("Fetching the String Object using for each loop :");
	    for(String city : v)
	    {
	    	System.out.println(city);
	    }
	    System.out.println("Fetching the String Object using Iterator interface:");
	     
	    Iterator<String> itr = v.iterator();
	    
	    while(itr.hasNext())
	    {
	    	System.out.println(itr.next());
	    }
	    
	    System.out.println("Fetching the String Object using ListIterator interface:");
	    
	         ListIterator<String> listItr = v.listIterator();
	         System.out.println("FORWARD DIRECTION");
	         
	         while(listItr.hasNext())
	         {
	        	 System.out.println(listItr.next());
	         }
	         
	         System.out.println("BACKWARD DIRECTION");
             while(listItr.hasPrevious())
             {
            	 System.out.println(listItr.previous());
             }
             
         System.out.println("Fetching the String Object using ForEach Method");
         
         v.forEach( x-> System.out.println(x.toUpperCase()));
         
         
         System.out.println("Fetching the String Object using Method Reference");
         
          v.forEach(System.out::println);   //Method reference       
         
	}    
}
-------------------------------------------------------------------
17-Jul-23
---------

ArrayList :
----------
public class ArrayList<E>  extends AbstractList<E> implements List<E>, Serializable, Clonable, RandomAccess

It is a predefined class available in java.util package under List interface.

It accepts duplicate elements and null values.

It is dynamically growable array.

It stores the elements on index basis so it is simillar to an array.

Initial capacity of ArrayList is 10.The new capacity of Arraylist can be calculated by using the  formula
new capacity = (current capacity * 3/2) + 1

*All the methods declared inside an ArrayList is not synchronized so multiple thread can access the method of ArrayList. 

It is highly suitable for fetching or retriving operation when duplicates are allowed and Thread-safety is not required.

It implements List,Serializable, Clonable, RandomAccess interfcaes

Constructor of ArrayList :
----------------------------
In ArrayList we have 3 types of Constructor:
Constructor of ArrayList :
----------------------------
We have 3 types of Constructor in ArrayList

1) ArrayList al1 = new ArrayList();
   Will create ArrayList object with default capacity 10.

2) ArrayList al2 = new ArrayList(int initialCapacity);
   Will create an ArrayList object with specified Capacity

3) ArrayList al3 = new ArrayList(Collection c)
   We can copy any Collection interface implemented class data to the current object 
   reference (Coping one Collection data to another) ------------------------------------------------------------------------------------
Note :- Collections  is a predefined class in java.util where as Collection is an interface in java.util.
-------------------------------------------------------------------
package com.ravi.arraylist;

import java.util.*;
public class ArrayListDemo
{
	public static void main(String... a)
	{
		ArrayList<String> arl = new ArrayList<>();//Generic type		
		arl.add("Apple");   
		arl.add("Orange");
		arl.add("Grapes");
		arl.add("Mango");
		arl.add("Guava");
		arl.add("Mango");

		System.out.println("Contents :"+arl); //toString()  [Apple,....]

		arl.remove(2); //based on the index position
		arl.remove("Guava"); //based on the Object

		System.out.println("Contents After Removing :"+arl);
		System.out.println("Size of the ArrayList:"+arl.size());

		Collections.sort(arl); 
		
	    arl.forEach(x -> System.out.println(x));	
	}
}
------------------------------------------------------------------
How to work with Custom object
-------------------------------
2 files 

Student.java
-------------
package com.ravi.arraylist;

import java.util.Date;

public class Student 
{
  private Integer studentRoll;
  private String studentName;
  private Double studentFees;
  private Date dateOfAdmission; //HAS-A Relation
  
  
public Student(Integer studentRoll, String studentName, Double studentFees, Date dateOfAdmission) {
	super();
	this.studentRoll = studentRoll;
	this.studentName = studentName;
	this.studentFees = studentFees;
	this.dateOfAdmission = dateOfAdmission;
}


@Override
public String toString() {
	return "Student [studentRoll=" + studentRoll + ", studentName=" + studentName + ", studentFees=" + studentFees
			+ ", dateOfAdmission=" + dateOfAdmission + "]";
}


public Integer getStudentRoll() {
	return studentRoll;
}


public void setStudentRoll(Integer studentRoll) {
	this.studentRoll = studentRoll;
}


public String getStudentName() {
	return studentName;
}


public void setStudentName(String studentName) {
	this.studentName = studentName;
}


public Double getStudentFees() {
	return studentFees;
}


public void setStudentFees(Double studentFees) {
	this.studentFees = studentFees;
}


public Date getDateOfAdmission() {
	return dateOfAdmission;
}


public void setDateOfAdmission(Date dateOfAdmission) {
	this.dateOfAdmission = dateOfAdmission;
}  
}

ArrayListDemo1.java
---------------------
package com.ravi.arraylist;

import java.util.ArrayList;
import java.util.Date;

public class ArrayListDemo1 
{
	public static void main(String[] args) 
	{
		ArrayList<Student> al = new ArrayList<>();
		Date d = new Date();
		al.add(new Student(101, "Virat", 12000.78, d));
		al.add(new Student(102, "Dhoni", 13000.78, d));
		al.add(new Student(103, "Rohit", 14000.78, d));
		al.add(new Student(104, "Rahul", 15000.78, d));
		
		al.forEach(st -> System.out.println(st));
		
	}
}
-------------------------------------------------------------------
package com.ravi.arraylist;

//Program to merge and retain of two collection 
import java.util.*;
public class ArrayListDemo2
	{
		public static void main(String args[]) 
		{ 
		  ArrayList<String> al1=new ArrayList<String>();
		  al1.add("Ravi");
		  al1.add("Rahul");
		  al1.add("Rohit");		  
		  
		  ArrayList<String> al2=new ArrayList<String>();
		  al2.add("Pallavi");
		  al2.add("Sweta");
		  al2.add("Puja");		  

		  al1.addAll(al2);  

        al1.forEach(x -> System.out.println(x.toUpperCase()));

        System.out.println(".................................");

		  ArrayList<String> al3=new ArrayList<String>();
		  al3.add("Ravi");
		  al3.add("Rahul");
		  al3.add("Rohit");		  
		  
		  ArrayList<String> al4=new ArrayList<String>();
		  al4.add("Pallavi");
		  al4.add("Rahul");
		  al4.add("Raj");
		  
		  al3.retainAll(al4);  

        al3.forEach(x -> System.out.println(x));		  
   }
}
-------------------------------------------------------------------
//Program to fetch the elements in forward and backward direction using 
//ListIterator interface

package com.ravi.arraylist;

import java.util.*;
public class ArrayListDemo3
{
public static void main(String args[])
	{
	    //Arrays class is having static method asList()
		List<String> list= Arrays.asList("Ravi","Rahul","Sweta","Ananya","Bina");
		
		Collections.sort(list);
		Collections.reverse(list);

		ListIterator<String> itr=list.listIterator();

		System.out.println("traversing elements in forward direction...");
		while(itr.hasNext())
		 {
			System.out.println(itr.next());
		 }

		System.out.println("traversing elements in backward direction...");
		while(itr.hasPrevious())
		 {
		System.out.println(itr.previous());
		 }
	}
}
------------------------------------------------------------------
18-Jul-23
---------
//Serialization and De-serialization on ArrayList Object
package com.ravi.arraylist;

import java.io.*;  
import java.util.*;  
public class ArrayListDemo4
	 {  
      public static void main(String [] args)  throws IOException
       {  
         ArrayList<String> al=new ArrayList<String>();  
         al.add("Nagpur");    
         al.add("Vijaywada");    
         al.add("Hyderabad");
		 al.add("Jamshedpur");       
        
				//Serialization  
				FileOutputStream fos=new FileOutputStream("D:\\new\\City.txt");
				ObjectOutputStream oos=new ObjectOutputStream(fos); 
				
				
				 //Deserialization  
				FileInputStream fis=new FileInputStream("D:\\new\\City.txt");				
				ObjectInputStream ois=new ObjectInputStream(fis); 

				try (fos; oos; fis; ois) 
                {  
				 oos.writeObject(al);  	//Serialization

	            ArrayList<String> list = (ArrayList<String>)ois.readObject();
				System.out.println(list);    
              }
			  catch(Exception e)  
			  {  
				  System.err.println(e);  
			  }
		  
     }  
  }         
-------------------------------------------------------------------
public void ensureCapacity(int resize) :-
---------------------------------------------
It is a predefined method of ArrayList class, by using this method we can resize the capacity of ArrayList Object.

Here by specifying the parameter we get resize the capacity of ArrayList object as well as depending upon the parameter it will hold the specified element as a parameter.

package com.ravi.arraylist;

import java.util.ArrayList;

public class ArrayListDemo5
{
	public static void main(String[] args) 
	{
		ArrayList<String> city= new ArrayList<String>();//default capacity is 10
		city.ensureCapacity(3);//resized the arraylist to store 3 elements.

		city.add("Hyderabad");
		city.add("Mumbai");
		city.add("Delhi");

		city.add("Kolkata");
		System.out.println("ArrayList: " + city);		
	 }
}
-------------------------------------------------------------------
package com.ravi.arraylist;

//Program on ArrayList that contains null values as well as we can pass the element based on the index position
import java.util.*;
public class ArrayListDemo6
{
	public static void main(String[] args) 
	{
		ArrayList<Object> al = new ArrayList<Object>(); //Generic type
		al.add(12);
		al.add("Ravi");
		al.add(12);		
		al.add(3,"Hyderabad"); //add(int index, Object o)method of List interface
		al.add(1,"Naresh");
		al.add(null);
		al.add(11);
		System.out.println(al);
	}
}
-------------------------------------------------------------------

Note :
-------
The time complexcity of ArrayList to insert or delete an element from the middle is O(n) [Big O of n] because n number of elements will be shifted from one place to another place, on the other hand the time complexcity to search/Fetch an element of ArrayList is O(1) because we need to search the element based on the index position.

So the conclusion is ArrayList is a very good choice to retrieve elements from the collcetion but it would be wrost choice if we want to insert or delete an element using ArrayList and that is the reason it implements RandomAccess interface.

To solve the above said problem LinkedList has been introduced.

-------------------------------------------------------------------

LinkedList :
------------
public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, Serializable

It is a predefined class available in java.util package under List interface.

It is ordered by index position like ArrayList except the elements (nodes) are doubly linked to one another. This linkage provide us new method for adding and removing the elements from the middle of LinkedList.

*The important thing is, LikedList may iterate more slowely than ArrayList but LinkedList is a good choice when we want to insert or delete the elements frequently in the list.

From jdk 1.5 onwards LinkedList class has been enhanced to support basic queue operation by implementing Deque<E> interface.

Constructor:
-------------
It has 2 constructors 

1) LinkedList list1 = new LinkedList();
    It will create a LinkedList object with 0 capacity.

2) LinkedList list2 = new LinkedList(Collection c);
    Interconversion between the collection

Methods of LinkedList class:
-------------------------------
1) void addFirst(Object o)
2) void addLast(Object o)

3) Object getFirst()
4) Object getLast()

5) Object removeFirst()
6) Object removeLast()

Note :- It stores the elements in non-contiguous memory location.           
	   
	   The time complexcity for insertion and deletion is  O(1)

	   The time complexcity for seraching O(n)
-------------------------------------------------------------------
package com.ravi.linked_list;

import java.util.LinkedList;
import java.util.List;
public class LinkedListDemo
{
 public static void main(String args[])
 { 
      List<Object> list=new LinkedList<>();
	  list.add("Ravi");
	  list.add("Vijay");
	  list.add("Ravi");
	  list.add(null);
	  list.add(42);
	  
	  System.out.println("0th Position Element is :"+list.get(0));

	 list.forEach(x -> System.out.println(x));
  }
}
-------------------------------------------------------------------
package com.ravi.linked_list;

import java.util.*;
public class LinkedListDemo1
{
      public static void main(String args[])
      {
           LinkedList<String> list= new LinkedList<>(); //generic
           list.add("Item 2");//2
           list.add("Item 3");//3
           list.add("Item 4");//4
           list.add("Item 5");//5
           list.add("Item 6");//6
           list.add("Item 7");//7
           list.add("Item 9"); //10

           list.add(0,"Item 0");//0
           list.add(1,"Item 1"); //1

           list.add(8,"Item 8");//8
		   list.add(9,"Item 10");//9
            System.out.println(list);
			
             list.remove("Item 5"); 
            System.out.println(list);
          
            list.removeLast();
            System.out.println(list);
         
			list.removeFirst();
            System.out.println(list);
          
           list.set(0,"Ajay"); //set() will replace the existing value
           list.set(1,"Vijay");
           list.set(2,"Anand");
           list.set(3,"Aman");
           list.set(4,"Suresh"); 
           list.set(5,"Ganesh");
           list.set(6,"Ramesh");
           list.forEach(x -> System.out.println(x)); 
			
      } 
}
------------------------------------------------------------------
19-Jul-23
----------
package com.ravi.linked_list;

//Methods of LinkedList class
import java.util.LinkedList;
public class LinkedListDemo2
{
    public static void main(String[] argv) 
    {
          LinkedList<String> list = new LinkedList<>();
          list.addFirst("Ravi");
          list.add("Rahul"); 
          list.addLast("Anand");			
          System.out.println(list.getFirst()); 
          System.out.println(list.getLast()); 
          list.removeFirst();
          list.removeLast(); 
          System.out.println(list);
    }
}
-------------------------------------------------------------------
----------------------------------------------
ListIterator interface has provided some more methods apart from reading the elements from forward direction and backward direction using cursor.

1) public boolean hasNext() 

2) public Object next()

3) public boolean hasPrevious()

4) public Object previous()

5) public void remove()

6) public void add(Object newElement)

7) public void set(Object newElement)
-------------------------------------------------------------------
package com.ravi.linked_list;
//ListIterator methods
import java.util.*;
public class LinkedListDemo3 
{
	public static void main(String[] args) 
	{
		LinkedList<String> city = new LinkedList<> ();
         city.add("Kolkata");
		 city.add("Bangalore");
		 city.add("Hyderabad");
		 city.add("Pune");
		 System.out.println(city);   

		ListIterator<String> lt = city.listIterator();

       while(lt.hasNext())
		  {
			String x =  lt.next();

			if(x.equals("Kolkata"))
			{
                 lt.remove();
			}
			else if(x.equals("Hyderabad"))
			{
                 lt.add("Ameerpet");
			}
			else if(x.equals("Pune"))
			{
                 lt.set("Mumbai");
			}
		}
		city.forEach(System.out::println);
	}
}

-------------------------------------------------------------------
package com.ravi.linked_list;

//Insertion, deletion, displaying and exit

import java.util.LinkedList;
import java.util.Scanner;

public class LinkedListDemo4
{
 public static void main(String[] args)
	{
      LinkedList<Integer> linkedList = new LinkedList<>();
      Scanner scanner = new Scanner(System.in);

      while (true) 
		{
          System.out.println("Linked List: " + linkedList);
          System.out.println("1. Insert Element");
          System.out.println("2. Delete Element");
			System.out.println("3. Display Element");
          System.out.println("4. Exit");
          System.out.print("Enter your choice: ");

          int choice = scanner.nextInt();
          switch (choice) 
			{
              case 1:
                  System.out.print("Enter the element to insert: ");
                  int elementToAdd = scanner.nextInt();
                  linkedList.add(elementToAdd);
                  break;
              case 2:
                  if (linkedList.isEmpty()) 
					{
                      System.out.println("Linked list is empty. Nothing to delete.");
                  } 
					else 
					{
                      System.out.print("Enter the element to delete: ");
                      int elementToDelete = scanner.nextInt();
                      //Converting the primitive to Wrapper object
         boolean removed = linkedList.remove(Integer.valueOf(elementToDelete));
                      if (removed) 
						{
                          System.out.println("Element " + elementToDelete + " deleted from the linked list.");
                      } 
						else
						{
                          System.out.println("Element not found in the linked list.");
                      }
                  }
                  break;
				case 3:
					System.out.println("Elements in the linked list.");
                   System.out.println(linkedList);
				     break;
              case 4:
                  System.out.println("Exiting the program.");
                  scanner.close();
                  System.exit(0);
              default:
                  System.out.println("Invalid choice. Please try again.");
          }
      }
  }
}
------------------------------------------------------------------
Vector :
--------
public class Vector<E> extends AbstractList<E>  implements List<E>, Serializable, Clonable, RandomAccess

Vector is a predefined class available in java.util package under List interface. 

Vector is always from java means it is available from jdk 1.0 version.

Vector and Hashtable, these two classes are available from jdk 1.0, remaining Collection classes were added from 1.2 version. That is the reason Vector and Hashtable are called legacy(old) classes.

The main difference between Vector and ArrayList is, ArrayList methods are not synchronized so multiple threads can access the method of ArrayList where as on the other hand most the methods are synchronized in Vector so performance wise Vector is slow.

*We should go with ArrayList when Threadsafety is not required on the other hand we should go with Vector when we need ThreadSafety for reterival operation.

It also stores the elements on index basis.It is dynamically growable with initial capacity 10. The next capacity will be 20 i.e double of the first capacity.

new capacity = current capacity * 2;

Just like ArrayList it also implements List, Serializable, Clonable, RandomAccess interfaces.

Constructors in Vector :
-------------------------
We have 4 types of Constructor in Vector

1) Vector v1 = new Vector();        
     It will create the vector object with default capacity is 10        
    
2) Vector v2 = new Vector(int initialCapacity);     
     Will create the vector object with specified capacity.

3) Vector v3 = new Vector(int initialCapacity, int incrementalCapacity);     
     Eg :-     Vector v = new Vector(1000,5);

     Initially It will create the Vector Object with initial capacity 1000 and then when  the capacity will be full then increment by 5 so the next capacity would be 1005, 1010 and so on.

 4) Vector v4 = new Vector(Collection c);
      Interconversion between the Collection.
-------------------------------------------------------------------
//Vector Program on capacity

package com.ravi.vector;

import java.util.*;
public class VectorDemo1
{
	public static void main(String[] args) 
	{
		Vector<Integer> v = new Vector<>(100,10);  //initial capacity is 100
		System.out.println("Initial capacity is :"+v.capacity());

      for(int i =0; i<100; i++)
		{
           v.add(i);
		}

System.out.println("After adding 100 elements  capacity is :"+v.capacity());
v.add(101);		
System.out.println("After adding 101th elements  capacity is :"+v.capacity());

		System.out.println(v);
	}
}
-------------------------------------------------------------------
//Fetching the element of Vector based on index position

package com.ravi.vector;

import java.util.Vector;
public class VectorDemo2
	{ 
	  public static void main(String[] args)
		{   
			Vector<Integer> v = new Vector<>();
			
			for(int i=1; i<=100; i++)
			{
				
              v.add(i);
			}

			System.out.println("Fetching the elements of Vector :");

			for(int i=0; i<v.size(); i++)
			{
				if(i%5==0)
				{
					System.out.println();
				}
				System.out.print(v.get(i)+"\t");
			}			
	     }
	}

-------------------------------------------------------------------
package com.ravi.vector;

import java.util.*;
public class VectorDemo3
{
	public static void main(String args[])
	{
		Vector<Integer> v = new Vector<>();
		
		int x[]={22,20,10,40,15,58};
   
        //Adding array values to Vector
		for(int i=0; i<x.length; i++)
		{
			v.add(x[i]);
		}		
		Collections.sort(v);
		System.out.println("Maximum element is :"+Collections.max(v));
		System.out.println("Minimum element is :"+Collections.min(v));
		System.out.println("Vector Elements :");
		v.forEach(y -> System.out.println(y));
	}
}
-------------------------------------------------------------------
//Program to describe that ArrayList is better then Vector in performance

package com.ravi.vector;

import java.util.*;
public class VectorDemo4 
{
	public static void main(String[] args) 
	{
		//starting time for Vector
		long startTime = System.currentTimeMillis();

       Vector<Integer> v = new Vector<>();
		 for(int i=0; i<1000000; i++)
		{
			 v.add(i);
		}
		long endTime = System.currentTimeMillis();

		System.out.println("Time taken by vector :"+(endTime - startTime)+" ms");

		//starting time for ArrayList
		 startTime = System.currentTimeMillis();

       ArrayList<Integer> al = new ArrayList<Integer>();
		 for(int i=0; i<1000000; i++)
		{
			 al.add(i);
		}
		 endTime = System.currentTimeMillis();

		System.out.println("Time taken by ArrayList :"+(endTime - startTime)+" ms");
	}
}
-------------------------------------------------------------------
20-Jul-23
----------
Stack :
------
public class Stack<E> extends Vector<E>

It is a predefined class available in java.util package. It is the sub class of Vector class. 

It is a linear data structure that is used to store the Objects in LIFO (Last In first out) order.

Inserting an element into a Stack is known as push operation  where as extracting an element from the stack is known as pop operation.

It throws an exception called EmptyStackException, if Stack is empty and we want to fetch the element.

It has only one constructor as shown below

Stack s = new Stack();

------------------------------------------------------------------------------------
Methods :
----------
push(Object o) :- To insert an element

pop() :- To remove and return the element from the top of the Stack

peek() :- Will fetch the element from top of the Stack without removing

empty() :- Verifies whether the stack is empty or not (return type is boolean)

search(Object o) :- It will search a particular element in the Stack and it returns OffSet position. If the element is not present in the Stack it will return -1
-------------------------------------------------------------------
//Program to insert and fetch the elements from stack
import java.util.*;
public class Stack1
{
      public static void main(String args[])
      {
            Stack<Integer> s = new Stack<>();
            try
            {
                  s.push(12);
                  s.push(15);
				  s.push(22);
				  s.push(33);
				  s.push(49);				  
				  System.out.println("After insertion elements are :"+s); 

                  System.out.println("Fetching the elements using pop method");
                  System.out.println(s.pop());
                  System.out.println(s.pop()); 
                  System.out.println(s.pop());  
                  System.out.println(s.pop());  
                  System.out.println(s.pop());
				  
				  	
	 				 				  
				  System.out.println("After deletion elements are :"+s); //[]
				  System.out.println("Is the Stack empty ? :"+s.empty());
              }
			catch(EmptyStackException e)
			{
			   e.printStackTrace();
			} 
      }
}
-------------------------------------------------------------------
//add(Object obj) is the method of Collection
import java.util.*;
public class Stack2
{
      public static void main(String args[])
      {
            Stack<Integer> st1 = new Stack<>();
            st1.add(10);
            st1.add(20);      
            st1.forEach(x -> System.out.println(x));

            Stack<String> st2 = new Stack<>();
            st2.add("Java");  
            st2.add("is");
            st2.add("programming");
            st2.add("language"); 
            st2.forEach(x -> System.out.println(x));

            Stack<Character> st3 = new Stack<>();
            st3.add('A');  
            st3.add('B');
            st3.forEach(x -> System.out.println(x));

            Stack<Double> st4 = new Stack<>();
            st4.add(10.5);
            st4.add(20.5);               
            st4.forEach(x -> System.out.println(x));          
      }  
}
-------------------------------------------------------------------
import java.util.Stack;  
public class Stack3
{  
	public static void main(String[] args)   
		{  
			Stack<String> stk= new Stack<>();  
			stk.push("Apple");  
			stk.push("Grapes");  
			stk.push("Mango");  
			stk.push("Orange");  
			System.out.println("Stack: " + stk);  
			
			String fruit = stk.peek(); 			
			System.out.println("Element at top: " + fruit);  
			System.out.println("Stack elements are : " + stk); 
		}  
}  

-------------------------------------------------------------------
//Searching an element in the Stack
import java.util.Stack;  
public class Stack4
{  
	public static void main(String[] args)   
		{  
			Stack<String> stk= new Stack<>();  
			stk.push("Apple");  
			stk.push("Grapes");  
			stk.push("Mango"); 						
			System.out.println("Offset Position is : " + stk.search("Mango")); //1			
			System.out.println("Offser Position is : " + stk.search("Banana")); //-1
		    System.out.println("Is stack empty ? "+stk.empty());	//false
			
			System.out.println("Index Position is : " + stk.indexOf("Mango")); //2
		}  
}  
-------------------------------------------------------------------
Set interface :
----------------
Set interface doesn't allow any duplicate elements, here our best friend is equals(Object obj) method of object class which compares two objects and if both the objects are identical then it will accept only one object.

Set interface uses almost all the methods of Collection interface.
-------------------------------------------------------------------
HashSet :- (UNSORTED, UNORDERED, NO DUPLICATES)
------------
public class HashSet extends AbstractSet implements Set, Clonabale, Serializable

It is a predefined class available in java.util package under Set interface.

It is an unsorted and unordered set.  

It accepts hetrogeneous kind of data.

*It uses the hashcode of the object being inserted into the Collection. Using this hashcode it finds the bucket location.

It doesn't contain any duplicate elements as well as It does not maintain any order while iterating the elements from the collection.

It can accept null value.

HashSet is used for fast searching operation.

--------------------------------------------------------------------------------------
It contains 4 types of constructor 

1) HashSet hs1 = new HashSet();
    It will create the HashSet Object with default capacity is 16. The default load fator or Fill Ratio is 0.75   (75% of HashSet is filled up then new HashSet Object will be created having double capacity)

2) HashSet hs2 = new HashSet(int initialCapacity);
    will create the HashSet object with specified capacity


3) HashSet hs3 = new HashSet(int initialCapacity, float loadFactor);
    we can specify our own initialCapacity and loadFactor(by default load factor is 0.75%)

4) HashSet hs = new HashSet(Collection c);
    Interconversion of Collection
 ------------------------------------------------------------------
//Unsorted, Unordered and no duplicates
import java.util.*;
public class HashSetDemo 
{
 public static void main(String args[])
 { 
	 HashSet<Integer> hs = new HashSet<>();
		hs.add(67);
		hs.add(89);
		hs.add(33);
		hs.add(45);
		hs.add(12);
		hs.add(35);		
		hs.forEach(str-> System.out.println(str));
	}
}
------------------------------------------------------------------
import java.util.*;
class Main
   {
       public static void main(String [] args)
       {
		 ArrayList<Integer> al = new ArrayList<>();
                 al.add(12);
		 al.add(9);
		 al.add(1);
		 al.add(12);

         HashSet<Integer> hs = new HashSet<>(al);         
		 System.out.println(hs);

        }
}
-------------------------------------------------------------------

What is hashcode and what is the use of hashCode ?
---------------------------------------------------
It is a unique number generated by JVM and it is used to differentiate two objects.


Can two Objects have same hashCode number ?
-------------------------------------------
Yes, if hashcode method is overridden with state(data) but hashcode of two object never be same if hashCode() method is not overridden from Object class

hashCode() method returns either state wise hashcode or refrence wise hashcode depending upon hashcode method Overriding

System.identityHashCode() method always returns reference wise hashcode.

-------------------------------------------------------------------
import java.util.*;
class Main
   {
       public static void main(String [] args)
       {
		 String str = "india";
		 System.out.println(str.hashCode());

		 String str1 = new String("india");
		 System.out.println(str1.hashCode());


        }
}

-> Both the hashcode are Same because hashCode() method is 
   overridden in String class.
 ------------------------------------------------------------------
import java.util.*;
public class HashSetDemo1
{
      public static void main(String[] argv) 
      {
      HashSet<String> hs=new HashSet<>();	  
	  hs.add("Ravi");
	  hs.add("Vijay");
	  hs.add("Ravi");
	  hs.add("Ajay");
	  hs.add("Palavi");
	  hs.add("Sweta");
	  hs.add(null);
	  hs.add(null);
	  hs.forEach(str -> System.out.println(str));

      }
}

Note :- From the above program it is clear that while iterating the 
        elements through HashSet order is un-predictable
-------------------------------------------------------------------
import java.util.*;
public class HashSetDemo2 
{
	public static void main(String[] args) 
	{
		 boolean[] ba = new boolean[6]; 

            Set s = new HashSet();
            ba[0] = s.add("a");
            ba[1] = s.add(42);
            ba[2] = s.add("b");
            ba[3] = s.add("a"); 
            ba[4] = s.add("new Object()");
			ba[5] = s.add(new Object());

            for(int x = 0; x<ba.length; x++)      
                 System.out.println(ba[x]+"    "); 

		if(s.contains(42)) //Searching a particular object in the Set
			{
				System.out.println("Object 42 is available ...");
			}
			else
			{
				System.out.println("42 is not available ...");
			}
			
         System.out.println("Fetching the elements of HashSet");            
			s.forEach(str -> System.out.println(str)); 
	}
}

Note :- 
1) From the above program it is clear that Collection interface 
   add() method return type boolean.

2) contains(Object obj) is a predefined method of Collection interface to check whether the object is available or not

--------------------------------------------------------------------
import java.util.HashSet;
import java.util.Scanner;

public class HashSetDemo3
{
    public static void main(String[] args) {
        HashSet<String> hashSet = new HashSet<>();
        Scanner scanner = new Scanner(System.in);

        while (true) 
		{
            System.out.println("Options:");
            System.out.println("1. Add element");
            System.out.println("2. Delete element");
            System.out.println("3. Display HashSet");
            System.out.println("4. Exit");

            System.out.print("Enter your choice (1/2/3/4): ");
            int choice = scanner.nextInt();

            switch (choice) 
			{
                case 1:
                    System.out.print("Enter the element to add: ");
                    String elementToAdd = scanner.next();
                    if (hashSet.add(elementToAdd)) 
					{
                        System.out.println("Element added successfully.");
                    } 
					else
					{
                        System.out.println("Element already exists in the HashSet.");
                    }
                    break;
                    case 2:
                    System.out.print("Enter the element to delete: ");
                    String elementToDelete = scanner.next();
                    if (hashSet.remove(elementToDelete)) 
					{
                        System.out.println("Element deleted successfully.");
                    } 
					else 
					{
                        System.out.println("Element not found in the HashSet.");
                    }
                    break;
                    case 3:
                    System.out.println("Elements in the HashSet:");
                    for (String element : hashSet) {
                        System.out.println(element);
                    }
                    break;
                    case 4:
                    System.out.println("Exiting the program.");
                    scanner.close();
                    System.exit(0);
                    default:
                    System.out.println("Invalid choice. Please try again.");
            }

            System.out.println(); 
        }
    }
}
--------------------------------------------------------------------
LinkedHashSet :
------------------
public class LinkedHashSet extends HashSet implements Set, Clonable, Serializable

It is a predefined class in java.util package under Set interface. 

It is the sub class of HashSet class.

It is an orderd version of HashSet that maintains a doubly linked list across all the elements.

We should use LinkedHashSet class when we want to maintain an order.

When we iterate the elements through HashSet the order will be unpredictable, while when we iterate the elments through LinkedHashSet then the order will be same as they were inserted in the collection.

It accepts hetrogeneous and null value is allowed.

It has same constructor as HashSet class.
--------------------------------------------------------------------
import java.util.*;
public class LinkedHashSetDemo
{
 public static void main(String args[])
	{ 
		  LinkedHashSet<String> lhs=new LinkedHashSet<>();
		  lhs.add("Ravi");
		  lhs.add("Vijay");
		  lhs.add("Ravi");
		  lhs.add("Ajay");
		  lhs.add("Pawan");
		  lhs.add("Shiva");
		  lhs.add(null);
		  lhs.add("Ganesh");
          
		  lhs.forEach(str -> System.out.println(str));	   
	}
}
--------------------------------------------------------------------
import java.util.LinkedHashSet;

public class LinkedHashSetDemo1 
{
    public static void main(String[] args) 
	{
       LinkedHashSet<Integer> linkedHashSet = new LinkedHashSet<>();

        linkedHashSet.add(10);
        linkedHashSet.add(5);
        linkedHashSet.add(15);
        linkedHashSet.add(20);
        linkedHashSet.add(5); 

        System.out.println("LinkedHashSet elements: " + linkedHashSet);

        System.out.println("LinkedHashSet size: " + linkedHashSet.size());

        int elementToCheck = 15;
        if (linkedHashSet.contains(elementToCheck)) 
		{
            System.out.println(elementToCheck + " is present in the LinkedHashSet.");
        } 
		else 
		{
            System.out.println(elementToCheck + " is not present in the LinkedHashSet.");
        }

        int elementToRemove = 10;
        linkedHashSet.remove(elementToRemove);
        System.out.println("After removing " + elementToRemove + ", LinkedHashSet elements: " + linkedHashSet);

              linkedHashSet.clear();
        System.out.println("After clearing, LinkedHashSet elements: " + linkedHashSet); 
    }
}
--------------------------------------------------------------------
SortedSet interface :
------------------------
1) It is the sub interface of Set interface

2) If we don't want duplicate elements and want to store the elements based on some sorting order i.e default natural sorting order then we should go with SortedSet(I)

3) default natural sorting means, if it is number then ascending order and if it is String then dictionary order or Alphabetical order.

4) We have two interfaces Comparable(available in java.lang package) and Comparator (available in java.util package) to compare two objects.

*What is the difference between Comparable and Comparator interface :
--------------------------------------------------------------------
Program on Comparable interface to compare Employee Object data 
---------------------------------------------------------------
2 Files 
-------
Employee.java
---------------
package com.ravi.comparable;
//BLC
public class Employee implements Comparable<Employee>
{
  private Integer employeeNumber;
  private String employeeName;
  private Double employeeSalary;
  
	public Employee(Integer employeeNumber, String employeeName, Double employeeSalary) 
	{
		super();
		this.employeeNumber = employeeNumber;
		this.employeeName = employeeName;
		this.employeeSalary = employeeSalary;
	}

	@Override
	public String toString() {
		return "Employee [employeeNumber=" + employeeNumber + ", employeeName=" + employeeName + ", employeeSalary="
				+ employeeSalary + "]";
	}

	//Sorting based on the Employee ID
	@Override
	public int compareTo(Employee emp) 
	{
		return this.employeeNumber - emp.employeeNumber;
	}
  
  
}

EmployeeComparable.java
------------------------
package com.ravi.comparable;

import java.util.ArrayList;
import java.util.Collections;

public class EmployeeComparable 
{
	public static void main(String[] args) 
	{
		ArrayList<Employee> emp = new ArrayList<Employee>();
		emp.add(new Employee(222, "John", 17000.90));
		emp.add(new Employee(444, "Aryan", 18000.90));
		emp.add(new Employee(111, "Zuber", 19000.90));
		emp.add(new Employee(333, "Rahul", 15000.90));
		
		Collections.sort(emp);
		
		emp.forEach(e -> System.out.println(e));
	}

}

--------------------------------------------------------------------
Limitation of Comparable interface :
-----------------------------------------
1) We need to modify the original source code (BLC class), If the source code is not available then it is not possible to perform  sorting operation.

2) We can provide only one sorting logic if we want to provide mutiple sorting logic then it is not possible.

To avoid the above said problems we introduced Comparator interface available in java.util package.
--------------------------------------------------------------------
Program on Comparator interface :
----------------------------------
2 files :
----------
Product.java
-------------
package com.ravi.comparator_demo;
//BLC
public class Product 
{
  private Integer productId;
  private String productName;
  private Double productPrice;
  
	public Product(Integer productId, String productName, Double productPrice)
	{
		super();
		this.productId = productId;
		this.productName = productName;
		this.productPrice = productPrice;
	}

	public Integer getProductId() {
		return productId;
	}

	public void setProductId(Integer productId) {
		this.productId = productId;
	}

	public String getProductName() {
		return productName;
	}

	public void setProductName(String productName) {
		this.productName = productName;
	}

	public Double getProductPrice() {
		return productPrice;
	}

	public void setProductPrice(Double productPrice) {
		this.productPrice = productPrice;
	}

	@Override
	public String toString() {
		return "Product [productId=" + productId + ", productName=" + productName + ", productPrice=" + productPrice
				+ "]";
	}
	
	
	
	
	  
  
}

ProductComparator.java
------------------------
package com.ravi.comparator_demo;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class ProductComparator 
{
	public static void main(String[] args) 
	{
		ArrayList<Product> al = new ArrayList<>();
		al.add(new Product(222,"Camera",80000.78));
		al.add(new Product(111,"Laptop",85000.78));
		al.add(new Product(333,"Mobile",55000.78));
		al.add(new Product(444,"LED",44000.78));

		//Sorting the Product data based on the id
		Comparator<Product> cmpId = (p1, p2)-> p1.getProductId() - p2.getProductId();				
				
		Collections.sort(al, cmpId);
		System.out.println("SORTING PRODUCT DATA BASED ON ID");
		al.forEach(x -> System.out.println(x));
		
		Comparator<Product> cmpName = (p1,p2) -> p1.getProductName().compareTo(p2.getProductName());
		
		Collections.sort(al, cmpName);
		System.out.println("SORTING PRODUCT DATA BASED ON NAME");
		al.forEach(System.out::println);
	

	}

}
--------------------------------------------------------------------
-> By using Comparator interface we can provide user-defined sorting logic.

StringDescending.java
-----------------------
package com.ravi.comparator_demo;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class StringDescending 
{
	public static void main(String[] args) 
	{
		ArrayList<String> al = new ArrayList<>();
		al.add("B.Tech");
		al.add("B.Sc");
		al.add("M.tech");
		al.add("BCA");
		al.add("MCA");
	    
		Comparator<String> cmpDec = (s1, s2)->
		{
			return  - s1.compareTo(s2);
		};
		
		Collections.sort(al, cmpDec);
		al.forEach(x -> System.out.println(x));
	}
}
--------------------------------------------------------------------

TreeSet :
----------
public class TreeSet<E> extends AbstractSet<E> implements NavigableSet, Clonable, Serializable

It is a predefined class available in java.util package under Set interface.

TreeSet, TreeMap  and PriorityQueue are the three sorted collection in the entire Collection Framework so these classes never accepting hetrogeneous kind of the data.

It will sort the elements in natural sorting order i.e ascending order in case of number, and alphabetical order or Dictionary order in the case of String. In order to sort the elements It uses Comparator  interface.

It does not accept duplicate and null value(java.lang.NullPointerException).

It does not accept hetrogeneous type of data if we try to insert it will throw a runtime exception i.e java.lang.ClassCastException

TreeSet implements NavigableSet.

NavigableSet extends SortedSet.

It contains 4 types of constructor :
----------------------------------------
1) TreeSet t1 = new TreeSet();
     create an empty TreeSet object, elements will be inserted in a natural sorting order.

2) TreeSet t2 = new TreeSet(Comparator c);
    Customized sorting order

3)  TreeSet t3 = new TreeSet(Collection c);

4) TreeSet t4 = new TreeSet(SortedSet s);

--------------------------------------------------------------------

import java.util.*;
public class TreeSetDemo 
{
	public static void main(String[] args) 
	{
		SortedSet<Integer> t1 = new TreeSet<>();
		t1.add(4);
		t1.add(7);
		t1.add(2);
		t1.add(1);
		t1.add(9);		
		System.out.println(t1);

		NavigableSet<String> t2 = new TreeSet<>();
		t2.add("Orange");
		t2.add("Mango");
		t2.add("Banana");
		t2.add("Grapes");
		t2.add("Apple");		
		System.out.println(t2);		
	}
}
--------------------------------------------------------------------
Iterator descendingIterator() :- It is a predefined method of TreeSet class through which we can fetch the elements in descending order. The return type of this method is Iterator interface.
--------------------------------------------------------------------
default void forEachRemaining(Consumer<? super T> action)  :-
-------------------------------------------------------------
As we know to fetch the data from Iterator cursor we need while loop support and along with loop we need the support of of two methods hasNext() and next(), But now from Java 8 onwards Iterator interface has provided forEachRemaining() method to concise our code.
--------------------------------------------------------------------
import java.util.*;
public class TreeSetDemo1
{
	public static void main(String[] args) 
	{
		TreeSet<String> t1 = new TreeSet<>();
		t1.add("Orange");
		t1.add("Mango");
		t1.add("Pear");
		t1.add("Banana");
		t1.add("Apple");	
		System.out.println("In Ascending order");
		t1.forEach(i -> System.out.println(i));

		TreeSet<String> t2 = new TreeSet<>();
		t2.add("Orange");
		t2.add("Mango");
		t2.add("Pear");
		t2.add("Banana");
		t2.add("Apple");

                System.out.println("In Descending order");
		Iterator<String> itr2 = t2.descendingIterator();  //for descending order

         itr2.forEachRemaining(x -> System.out.println(x));


		
	}
}

-------------------------------------------------------------------
import java.util.*;
public class TreeSetDemo2
{
	public static void main(String[] args) 
	{
		Set<String> t = new TreeSet<>();  
		t.add("6"); 
		t.add("5");
		t.add("4");
		t.add("2");
		t.add("9");	
		Iterator<String> iterator = t.iterator();
		iterator.forEachRemaining(x -> System.out.println(x));
		//From 1.8 to replace hasNext() and next() method
	}
}
--------------------------------------------------------------------
//customized sorting order
import java.util.*;

public class TreeSetDemo3 
	{
	public static void main(String[] args)
	{
		Set<Character> t = new TreeSet<>();  
		t.add('A'); 
		t.add('C');
		t.add('B');
		t.add('E');
		t.add('D');	
		Iterator<Character> iterator = t.iterator();
		iterator.forEachRemaining(x -> System.out.println(x)); //From 1.8 to replace hasNext() and next() method
			
	}
}

-------------------------------------------------------------------
//Working with customized sorting order using Comparator as a parameter
import java.util.*;
public class  TreeSetDemo4
{
	public static void main(String[] args) 
	{
		System.out.println("Sorting name -> Ascending Order");
					
		TreeSet<Employee> ts1 = new TreeSet<Employee>(new FirstComparator());
		ts1.add(new Employee(101, "Zaheer", 24));
		ts1.add(new Employee(201, "Aryan", 27));
		ts1.add(new Employee(301, "Pooja", 26));		
		ts1.forEach(i -> System.out.println(i));

        System.out.println("----------------------------------------");
		System.out.println("Sorting name -> Descending Order");
		
		TreeSet<Employee> ts2
			= new TreeSet<>(new SecondComparator());		
		ts2.add(new Employee(101, "Zaheer", 24));
		ts2.add(new Employee(201, "Aryan", 27));
		ts2.add(new Employee(301, "Pooja", 26));
        ts2.forEach(i -> System.out.println(i));	
		
        System.out.println("----------------------------------------");
		System.out.println("Sorting Age -> Ascending Order");
		
		TreeSet<Employee> ts3
			= new TreeSet<>(new ThirdComparator());
		ts3.add(new Employee(101, "Zaheer", 24));
		ts3.add(new Employee(201, "Aryan", 27));
		ts3.add(new Employee(301, "Pooja", 26));
        ts3.forEach(i -> System.out.println(i));		

		System.out.println("----------------------------------------");
		System.out.println("Sorting Age ->  Descending Order");
		TreeSet<Employee> ts4
			= new TreeSet<>(new FourthComparator());

		ts4.add(new Employee(101, "Zaheer", 24));
		ts4.add(new Employee(201, "Aryan", 27));
		ts4.add(new Employee(301, "Pooja", 26));
        ts4.forEach(i -> System.out.println(i));
	}
}

// for sorting name in ascending order
class FirstComparator implements Comparator<Employee> 
{
	@Override 
	public int compare(Employee e1, Employee e2)
	{
		return e1.name.compareTo(e2.name);
	}
}
// for sorting name in descending order
class SecondComparator implements Comparator<Employee>
{
	@Override 
	public int compare(Employee e1, Employee e2)
	{
		return - (e1.name).compareTo(e2.name);
	}
}
// for sorting age in ascending order
class ThirdComparator implements Comparator<Employee> 
{
	@Override 
	public int compare(Employee e1, Employee e2)
	{
		return e1.age - e2.age;
	}
}
// for sorting age in descending order
class FourthComparator implements Comparator<Employee> 
{
	@Override
	public int compare(Employee e1, Employee e2)
	{
		return - (e1.age - e2.age);
	}
}
// Employee class
class Employee 
	{
	 Integer id;
	 String name;
	 Integer age;

	public Employee(int id, String name, int age)
	{
		this.id = id;
		this.name = name;
		this.age = age;
	}

	@Override 
	public String toString()
	{
		return " " + this.id + " " + this.name + " "+ this.age;
	}
	
}

HW :- Convert the above said program into Lambda
---------------------------------------------------------------------
Methods of SortedSet(I) :
-------------------------
Methods of SortedSet interface :
--------------------------------------
public E first() :- Will fetch first element

public E last() :- Will fetch last element

public SortedSet headSet(int range) :- Will fetch the values which are less than specified range

public SortedSet tailSet(int range) :- Will fetch the values which are equal or greater than the specified range.

public SortedSet subSet(int startRange, int endRange) :- Will fetch the range of values where startRange is inclusive and endRange
is exclusive
----------------------------------------------------------------------
import java.util.*;
public class SortedSetMethodDemo
{
       public static void main(String[] args) 
       {
            TreeSet<Integer> times = new TreeSet<>();
            times.add(1205);
            times.add(1505);
            times.add(1545);
			times.add(1600);
            times.add(1830);
            times.add(2010);
            times.add(2100);
            
            SortedSet<Integer> sub = new TreeSet<>();
            
			sub =  times.subSet(1545,2100); 
            System.out.println("Using subSet() :-"+sub);//[1545, 1600,1830,2010]
            System.out.println(sub.first());
            System.out.println(sub.last());   
			
		    sub = times.headSet(1545); 
			System.out.println("Using headSet() :-"+sub); //[1205, 1505]

		     sub =  times.tailSet(1545); 
			System.out.println("Using tailSet() :-"+sub); //[1545 to 2100] 
       }
}
----------------------------------------------------------------------
NavigableSet(I) :
-----------------
With the help of SortedSet interface method we can find out the range of values but we can't navigate among those elements.

Now to frequently navigate among those range of elements, Java software people introduced new interface called NavigableSet from 1.6V

import java.util.*;

public class NavigableSetDemo 
{   
    public static void main(String[] args)
    {
        NavigableSet<Integer> ns = new TreeSet<>(); 
        ns.add(1);
        ns.add(2);
        ns.add(3);
        ns.add(4);
        ns.add(5);
        ns.add(6);

		System.out.println("lower(3): " + ns.lower(3));//Just below than the specified element or null

        System.out.println("floor(3): " + ns.floor(3)); //Equal or less or null

        System.out.println("higher(3): " + ns.higher(3));//Just greater than specified element or null

        System.out.println("ceiling(3): " + ns.ceiling(3));//Equal or greater or null  
        		
    }
}
---------------------------------------------------------------------
27-Jul-23
----------
Map interface :
-----------------
As we know Collection interface is used to hold single Or individual object but Map interface will hold group of objects in the form key and value pair.

Map interface is not the part the Collection.

Before Map interface We had Dictionary(abstract class) class and it is implemented Hashtable class in JDK 1.0V

Map interface works with key and value pair introduced from 1.2V.

Here key and value both are objects.

Here key must be unique and value may be duplicate.

Each key and value pair is creating one Entry.(Entry is nothing but the combination of key and value pair)

interface Map
{
   
     interface Entry
      {
      }
}

How to represent this entry interface (Map.Entry) [Map$Entry]

--------------------------------------------------------------------
Map Hierarchy :
---------------
[Diagram 27-July]
--------------------------------------------------------------------
Methods of Map interface :
-------------------------------
1) Object put(Object key, Object value) :- To insert one entry in the Map collection. It will return the old object value if the key is already available.

2) void putAll(Map m) :- Merging of two Map collection

3) int size() :- To count the pair of key and value or Entry

4) void clear() :- Used to clear the Map

5) boolean isEmpty() :- To verify Map is empty or not?

6) boolean containsKey(Object key) :- To Search a particular key

7) boolean containsValue(Object value) :- To Search a particular value

8) Object get(Object key) :- The corrosponding value of key, if the key is not present then it will return null.

9) Object getOrDefault(Object key, Object defaultValue) :- To avoid null value this method has been introduced, here we can pass some defaultValue to avoid the null value.

10) remove(Object key) :- One complete entry will be removed.

11) putIfAbsent(Object key, Object value) :- It will insert an entry if and only if key is not present , if the key is already available then it will not insert the Entry to the Map Collection


Collection views Methods :
------------------------------
public Set keySet() :- Will return only keys (Set of keys)

Collection values() :- Will return all values.

Set<Map.Entry> entrySet() :- It will return key and value pair in the form of Entry.

          a) getKey()    b) getValue()   c) setValue()
-------------------------------------------------------------------
28-Jul-23
---------

How HashMap works internally :
------------------------------
a) While working with HashSet or HashMap every object must be compared because duplicate objects are not allowed.

b) Whenever we add any new key to verify whether key is unique or duplicates, HashMap internally uses hashCode(), == operator and equals method.

c) While adding the key object in the HashMap, first of all it will invoke the hashCode() method to retrieve the corrosponding key hashcode value.
    Example :- hm.put(key,value);
               then internally key.hashCode();

d) If the newly added key and existing key hashCode value both are same, then only == operator is used for comparing those keys by using reference or memory address, if both keys references are same then existing key value will be replaced with new key value.

        If the reference of both keys are different then equals(Object obj) method is invoked to compare those keys by using state(data).

	If the equals(Object obj) method returns true (content wise both keys are same), this new key is duplicate then existing key value will be replaced.

	If equals(Object obj) method returns false, this new key is unique, new entry (key-value) will be inserted.

	Note :- equals(Object obj) method is invoked only when two 
	keys are having same hashcode as well as their references are different.

e) Actually by calling hashcode method we are not comparing the objects, we are just storing the objects in a group so the currently adding key object will be compared with its HASHCODE GROUP objects, but not with all the keys which are available in the Map.

f) The main purpose of storing objects into the corrosponding group to decrease the number of comparison so the efficiency of the program will increase.

g) To insert an entry in the HashMap, HashMap internally uses Hashtable data structure

h) Now, for storing same hashcode object into a single group, hash table data structure internally uses one more data structure called Bucket.

i) The Hash table data structure internally uses Node class array object.

j) The bucket data structure internally uses LinkedList data structure, It is a single linked list again implemented by Node class only.

k) A bucket is group of entries of same hash code keys.

l) Performance wise LinkedList is not good to serach so from java 8 onwards LinkedList is changed to Binary tree to decrease the number of comparison within the same bucket hashcode if the number of entries are greater than 8.
--------------------------------------------------------------------

HashMap :-  [Unsorted, Unordered, No Duplicate keys]
------------
public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Serializable, Clonable 

It is a predefined class available in java.util package under Map interface.

It gives us unsorted and Unordered map. when we need a map and we don't care about the order while iterating the elements through it then we should use HashMap.

It inserts the element based on the hashCode of the Object key using hashing technique [hasing alogorithhm]

It does not accept duplicate keys but value may be duplicate.

It accepts only one null key(because duplicate keys are not allowed) but multiple null values are allowed.

HashMap is not synchronized.

Time complexcity of search, insert and delete will be O(1)

We should use HashMap to perform searching opeartion.

It contains 4 types of constructor 

1) HashMap hm1 = new HashMap();
    It will create the HashMap Object with default capacity is 16. The default load fator or Fill Ratio is 0.75   (75% of HashMap is filled up then new HashMap Object will be created having double capacity)

2) HashMap hm2 = new HashMap(int initialCapacity);
    will create the HashMap object with specified capacity


3) HashMap hm3 = new HashMap(int initialCapacity, float loadFactor);
    we can specify our own initialCapacity and loadFactor(by default load factor is 0.75%)

4)HashMap hm4 = new HashMap(Map m);
    Interconversion of Map Collection

--------------------------------------------------------------------
import java.util.*;
public class HashMapDemo 
{
      public static void main(String[] a) 
      {
           Map<String,String> map = new HashMap<>();
		   map.put("Ravi", "12345");  //Ravi is key and 12345 is value
		   map.put("Rahul", "12345");
		   map.put("Aswin", "5678");
		   map.put(null, "6390");
		   map.put("Ravi","1529");

		   System.out.println(map); //{}

           System.out.println(map.get(null));  //6390
		   System.out.println(map.get("Virat"));  //null becoz key is not available
		   map.forEach((k, v) -> System.out.println("Key = " + k + ", Value = " + v)); 
		   
		                 
      }
}
-------------------------------------------------------------------
//Program to search a particular key and value in the Map collection
import java.util.*;
public class HashMapDemo1
{
	public static void main(String args[]) 
	{
		HashMap<Integer,String> hm = new HashMap<>();			 
		hm.put(1, "JSE");  
		hm.put(2, "JEE");
		hm.put(3, "JME"); 
		hm.put(4,"JavaFX");
		hm.put(5,null);
		hm.put(6,null);
		System.out.println(hm);

		System.out.println("Initial map elements: " + hm); 
		System.out.println("key 2 is present or not :"+hm.containsKey(2));   

		System.out.println("JME is present or not :"+hm.containsValue("JME")); 

		System.out.println("Size of Map : " + hm.size()); 
		hm.clear(); 	
		System.out.println("Map elements after clear: " + hm);	//{}
	  }    
}
--------------------------------------------------------------------
//Collection view methods [keySet(),  values(),  entrySet()]
import java.util.*;
public class HashMapDemo2
{
public static void main(String args[]) 
	{
			Map<Integer,String> map = new HashMap<>(); 
			map.put(1, "C");
			map.put(2, "C++");
			map.put(3, "Java");
			map.put(4, ".net");
		
			map.forEach((k,v)->System.out.println("Key :"+k+" Value :"+v) );           
			           
			System.out.println("Return Old Object value :"+map.put(4,"Python"));  
		
			for(Map.Entry m : map.entrySet())
			 {  
				 System.out.println(m.getKey()+" = "+m.getValue());  
			}  
	}    
}
--------------------------------------------------------------------
import java.util.*;
public class HashMapDemo3
{
public static void main(String args[]) 
  {
		HashMap<Integer,String> map = new HashMap<>(10,8.5f);
		map.put(1, "Java");
		map.put(2, "is");
		map.put(3, "best");
		map.remove(3);  //will remove the complete Entry
		String val=(String)map.get(3);
		System.out.println("Value for key 3 is: " + val);
		map.forEach((k,v)->System.out.println(k +" : "+v));
   }    
}
-------------------------------------------------------------------
//To merge two Map Collection
import java.util.*;
public class HashMapDemo4
{
public static void main(String args[]) 
	{
		HashMap<Integer,String> newmap1 = new HashMap<>();

		HashMap<Integer,String> newmap2 = new HashMap<>();	  

		newmap1.put(1, "SCJP");
		newmap1.put(2, "is");
		newmap1.put(3, "best");
			  
		System.out.println("Values in newmap1: "+ newmap1);

		newmap2.put(4, "Exam");

		newmap2.putAll(newmap1);

		newmap2.forEach((k,v)->System.out.println(k+" : "+v));		
   }    
}
--------------------------------------------------------------------
import java.util.*;
public class HashMapDemo5 
{
     public static void main(String[] argv) 
     {
          Map<String,String> map = new HashMap<>(9, 0.85f);
          map.put("key", "value");
          map.put("key2", "value2");
          map.put("key3", "value3");
		  map.put("key7","value7");


		   Set keys = map.keySet();//keySet return type is Set
		   System.out.println(keys ); //[]

          Collection val = map.values(); //values return type is collection
          System.out.println(val);
         
		  map.forEach((k,v)-> System.out.println(k+" : "+v));
		  
          	  
      }
}
--------------------------------------------------------------------
//getOrDefault() method
import java.util.*;
public class  HashMapDemo6
{
	public static void main(String[] args) 
	{
		Map<String, String> map = new HashMap<>();
		map.put("A", "1");
		map.put("B", "2");
		map.put("C", "3");
        //if the key is not present, it will return default value .It is used to avoid null
		String value = map.getOrDefault("D","Key is not available");
		System.out.println(value);
		System.out.println(map); 
	}
}
--------------------------------------------------------------------
//interconversion of two HashMap
import java.util.*;
public class HashMapDemo7
	{
	public static void main(String args[])
	{		
		HashMap<Integer, String> hm1 = new HashMap<>();

		hm1.put(1, "Ravi");
		hm1.put(2, "Rahul");
		hm1.put(3, "Rajen");

		HashMap<Integer, String> hm2	= new HashMap<>(hm1);

		System.out.println("Mapping of HashMap hm1 are : "	+ hm1);
	
		System.out.println("Mapping of HashMap hm2 are : " + hm2);
	}
}
--------------------------------------------------------------------
import java.util.*;
class Employee
{
	int eid;
	String ename;
	Employee(int eid, String ename)
	{
		this.eid = eid;
		this.ename = ename;
	}

    @Override
	public boolean equals(Object obj)  //obj = e2
	{		
		Employee e2 = (Employee) obj;
        
		//Storing first Object (e1) contents to variables
		int eid1 = this.eid;       // here this is referring to e1 Object
		String name1 = this.ename;

        //Storing second Object (e2) contents to variables
		int eid2 = e2.eid;
		String name2 = e2.ename;

		if(eid1 == eid2 && name1.equals(name2))
		{
			return true;
		}
		else
		{
			return false;
		}
	}
}
public class HashMapDemo8
{
	public static void main(String[] args) 
	{
		Employee e1 = new Employee(101,"Aryan");
		Employee e2 = new Employee(102,"Pooja");
		Employee e3 = new Employee(101,"Aryan");
		Employee e4 = e2;

		HashMap<Employee,String> hm = new HashMap<>();
		hm.put(e1,"Ameerpet");
		hm.put(e2,"S.R Nagar");
		hm.put(e3,"Begumpet");
		hm.put(e4,"Panjagutta");

		hm.forEach((k,v)-> System.out.println(k+" : "+v));
	}
}
-------------------------------------------------------------------
equals() and hashCode() method contract :
-----------------------------------------
Both the methods are working together to find out the duplicate objects in the Map.

*If equals() method invoked on two objects and it returns true then hashcode of both the objects must be same.
--------------------------------------------------------------------
LinkedHashMap :
------------------
public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V>

It is a predefined class available in java.util package under Map interface.

It is the sub class of HashMap class.

It maintains insertion order. It contains a doubly linked with the elements or nodes so It will iterate more slowly in comparison to HashMap.

It uses Hashtable and LinkedList data structure.

If We want to fetch the elements in the same order as they were inserted then we should go with LinkedHashMap.

It accepts one null key and multiple null values.

It is not synchronized.

It has also 4 constructors same as HashMap

1) LinkedHashMap hm1 = new LinkedHashMap();
    will create a  LinkedHashMap with default capacity 16 and load factor 0.75

2) LinkedHashMap hm1 = new LinkedHashMap(iny initialCapacity);

3) LinkedHashMap hm1 = new LinkedHashMap(iny initialCapacity, float loadFactor);


4) LinkedHashMap hm1 = new LinkedHashMap(Map m);
--------------------------------------------------------------------
import java.util.*;
public class LinkedHashMapDemo 
{
	public static void main(String[] args) 
	{
		LinkedHashMap<Integer,String> l = new LinkedHashMap<>();
		l.put(1,"abc");
		l.put(3,"xyz");
		l.put(2,"pqr");
		l.put(4,"def");
		l.put(null,"ghi");
		System.out.println(l);
	}
}
-------------------------------------------------------------------
import java.util.LinkedHashMap;
import java.util.Map;

public class LinkedHashMapDemo1 
{
      public static void main(String[] a) 
      {
           Map<String,String> map = new LinkedHashMap<>();
           map.put("Ravi", "1234");
		   map.put("Rahul", "1234");
		   map.put("Aswin", "1456");
		   map.put("Samir", "1239");
           
		   map.forEach((k,v)->System.out.println(k+" : "+v));
      }
}
--------------------------------------------------------------------
Hashtable :
------------
public class Hashtable<K,V> extends Dictionary<K,V> implements Map<K,V>, Clonable, Serializable

It is predefined class available in java.util package under Map interface.

Like Vector, Hashtable is also form the birth of java so called legacy class.

It is the sub class of Dictionary class which is an abstract class.

The major difference between HashMap and Hashtable is, HashMap can have null values as well as a null key where as Hashtable does not contain anything as a null. if we try to add null value JVM will throw an exception i.e NullPointerException.

The initial default capacity of Hashtable class is 11 where as loadFactor is 0.75.

Like Vector, Hashtable methods are also synchronized So it provides ThreadSafety

It has also same constructor as we have in HashMap.(4 constructors)

1) Hashtable hs1 = new Hashtable();
    It will create the Hashtable Object with default capacity as 11 as well as load factor is 0.75

2) Hashtable hs2 = new Hashtable(int initialCapacity);
    will create the Hashtable  object with specified capacity


3) Hashtable hs3 = new Hashtable(int initialCapacity, float loadFactor);
    we can specify our own initialCapacity and loadFactor

4) Hashtable hs = new Hashtable(Map c);
    Interconversion of Map Collection  
-------------------------------------------------------------------
import java.util.*;  
public class HashtableDemo
	{  
	 public static void main(String args[])
		{  
		  Hashtable<Integer,String> map=new Hashtable<>(); 
		  map.put(1, "Java");
		  map.put(2, "is");
		  map.put(3, "best");		
		  map.put(4,"language");
		  
		  //map.put(5,null);  Invalid

		  System.out.println(map);

		  System.out.println(".......................");

		  for(Map.Entry m : map.entrySet())
			 {  
				 System.out.println(m.getKey()+" = "+m.getValue());  
			}  
        }  
}  
/* Map is an interface and Entry is also an interface defined inside Map interface to create an entry

interface Map
{
	 interface Entry
	 {
		  //key and value pair
	 }
}
*/
--------------------------------------------------------------------
import java.util.*;  
public class HashtableDemo1
{  
   public static void main(String args[])
	{  
    Hashtable<Integer,String> map=new Hashtable<>();          
     map.put(1,"Priyanka");    
     map.put(2,"Ruby");   
     map.put(3,"Vibha");    
     map.put(4,"Kanchan");
	
	 map.putIfAbsent(5,"Bina");  
	 map.putIfAbsent(24,"Pooja");
	 map.putIfAbsent(26,"Ankita");     
    
     map.putIfAbsent(1,"Sneha");  
     System.out.println("Updated Map: "+map); 
 }  
}  
--------------------------------------------------------------------
Properties class:
-----------------
Properties class is used to maintain the data in the key-value form. It takes both key and value as a string. Properties class is a subclass of Hashtable. It provides the methods to store properties in a properties file and to get the properties from the properties file. System.getProperties() returns the all system properties.

Here we need to create a file with extension .properties

db.properties
-------------
 driver = oracle.jdbc.driver.OracleDriver
 user = system
 password = tiger
--------------------------------------------------------------------------------------

import java.util.*;  
import java.io.*;  
public class PropertiesExample1 
{  
public static void main(String[] args)throws Exception
 {  
    FileReader reader=new FileReader("db.properties");  
      
    Properties p=new Properties();  
    p.load(reader);  
      
    System.out.println(p.getProperty("user"));  
    System.out.println(p.getProperty("password"));  
 }  
}  

-----------------------------------------------------------------------------------
import java.util.*;  
import java.io.*;  
public class PropertiesExample2 
{  
public static void main(String[] args)throws Exception
{  
	Properties p=System.getProperties();  
	Set set=p.entrySet();  
	
	Iterator itr=set.iterator();  
	while(itr.hasNext())
    {  
		Map.Entry entry=(Map.Entry)itr.next();  
		System.out.println(entry.getKey()+" = "+entry.getValue());  
	}  
  
}  }

------------------------------------------------------------------
SortedMap(I)
---------------
It is a predefined interface available in java.util package under Map interface.

We should use SortedMap interface when we want to insert the key element based on some sorting order i.e the default natural sorting order.
------------------------------------------------------------------------------------------
TreeMap :
----------
public class TreeMap<K,V> extends AbstractMap<K,V> implements NavigableMap<K,V> , Clonable, Serializable

It is a predefined class avaialble in java.util package under Map interface.

It is a sorted map that means it will sort the elements by natural sorting order based on the key using Comparator interface.

It will accept homogeneous keys (comparable keys as an Object) only because it will sort the entry of TreeMap based on the key.

It does not accept null key but null value we can take.

TreeMap implements NavigableMap and NavigableMap extends SortedMap. SortedMap extends Map interface.

TreeMap contains 4 types of Constructors :

1) TreeMap tm1 = new TreeMap(); //creates an empty TreeMap

2)  TreeMap tm2 = new TreeMap(Comparator cmp); //user defined soting logic

3)  TreeMap tm3 = new TreeMap(Map m);

4)  TreeMap tm4 = new TreeMap(SortedMap m);
--------------------------------------------------------------------
import java.util.*;
public class TreeMapDemo 
{
	public static void main(String[] args) 
	{
		TreeMap t = new TreeMap(); 
		t.put(4,"Ravi");
		t.put(7,"Aswin");
		t.put(2,"Ananya");
		t.put(1,"Dinesh");
		t.put(9,"Ravi");	
		t.put(3,"Ankita");
		t.put(5,null);
		
		System.out.println(t);
	}
}
----------------------------------------------------------------
import java.util.*;                        
public class TreeMapDemo1 
{
      public static void main(String args[]) 
      {
            TreeMap map = new TreeMap();
            map.put("one","1");
            map.put("two",null);
            map.put("three","3");
			map.put("four",4);

            displayMap(map);  

	map.forEach((k, v) -> System.out.println("Key = " + k + ", Value = " + v));
	 	       
      }
      static void displayMap(TreeMap map) 
      {
           Collection c = map.entrySet();   //Set<Map.Entry>

           Iterator i = c.iterator();
           i.forEachRemaining(x -> System.out.println(x));
      }
}
-------------------------------------------------------------------
//firstKey()  lastKey()  headMap()  tailMap()  subMap()

import java.util.*;
public class TreeMapDemo2
{
    public static void main(String[] argv) 
    {
        Map map = new TreeMap();
        map.put("key2", "value2");
        map.put("key3", "value3");
        map.put("key1", "value1");

        System.out.println(map);

        SortedMap x = (SortedMap) map;
        System.out.println("First key is :"+x.firstKey());
        System.out.println("Last Key is :"+x.lastKey()); 
     }
}
-------------------------------------------------------------------
//customized sorting order
import java.io.*;
import java.util.*;

public class TreeMapDemo3 
	{
	public static void main(String[] args)
	{
		System.out.println("Sorting name -> Ascending Order");
					
		TreeMap<Employee,String> tm1 = new TreeMap<Employee,String>(new FirstComparator());

		tm1.put(new Employee(101, "Zaheer", 24),"Hyderabad");
		tm1.put(new Employee(201, "Aryan", 27),"Jamshedpur");
		tm1.put(new Employee(301, "Pooja", 26),"Mumbai");
		
		System.out.println(tm1);

	  System.out.println("----------------------------------------");

		System.out.println("Sorting name -> Descending Order");
		
		TreeMap<Employee,String> tm2 = new TreeMap<Employee,String>(new SecondComparator());

		tm2.put(new Employee(101, "Zaheer", 24),"Hyderabad");
		tm2.put(new Employee(201, "Aryan", 27),"Jamshedpur");
		tm2.put(new Employee(301, "Pooja", 26),"Mumbai");

		System.out.println(tm2);

        System.out.println("----------------------------------------");
		System.out.println("Sorting Age -> Ascending Order");

		TreeMap<Employee,String> tm3 = new TreeMap<Employee,String>(new ThirdComparator());
		tm3.put(new Employee(101, "Zaheer", 24),"Hyderabad");
		tm3.put(new Employee(201, "Aryan", 27),"Jamshedpur");
		tm3.put(new Employee(301, "Pooja", 26),"Mumbai");

		System.out.println(tm3);

		System.out.println("----------------------------------------");
		System.out.println("Sorting Age ->  Descending Order");
		TreeMap<Employee,String> tm4 = new TreeMap<Employee,String>(new FourthComparator());

		tm4.put(new Employee(101, "Zaheer", 24),"Hyderabad");
		tm4.put(new Employee(201, "Aryan", 27),"Jamshedpur");
		tm4.put(new Employee(301, "Pooja", 26),"Mumbai");
		
		 System.out.println(tm4);
	}
}

// for sorting name in ascending order
class FirstComparator implements Comparator<Employee> 
{
	@Override 
	public int compare(Employee e1, Employee e2)
	{
		return e1.name.compareTo(e2.name);
	}
}

// for sorting name in descending order
class SecondComparator implements Comparator<Employee>
{
	@Override 
	public int compare(Employee e1, Employee e2)
	{
		return - (e1.name).compareTo(e2.name);  
	}
}

// for sorting age in ascending order
class ThirdComparator implements Comparator<Employee> 
{
	@Override 
	public int compare(Employee e1, Employee e2)
	{
		return e1.age - e2.age;    
	}
}


// for sorting age in descending order
class FourthComparator implements Comparator<Employee> 
{
	@Override 
	public int compare(Employee e1, Employee e2)
	{
		return - (e1.age - e2.age);
	}
}

// Employee class
class Employee 
	{
	 int id;
	 String name;
	 Integer age;

	public Employee(int id, String name, int age)
	{
		this.id = id;
		this.name = name;
		this.age = age;
	}

	@Override 
	public String toString()  
	{
		return " " + this.id + " " + this.name + " "+ this.age;
	}
}
-------------------------------------------------------------------
31-Jul-23
---------
Methods of SortedMap interface :
--------------------------------
1) firstKey()  //first key

2) lastKey()  //last key

3) headMap(int keyRange) //less than the specified range

4) tailMap(int keyRange)  //equal to or greater than the specified range

5) subMap(int startKeyRange, int endKeyRange) //the range of key where startKey will be inclusive and endKey will be exclusive.

return type of headMap(), tailMap() and subMap() would be SortedMap(I)
-------------------------------------------------------------------
------------------------------------------------------------------------------------------
import java.util.*;  
public class SortedMapMethodDemo
	{  
 public static void main(String args[])
	 {  
		SortedMap<Integer,String> map=new TreeMap<Integer,String>();    
		  map.put(100,"Amit");    
		  map.put(101,"Ravi");    
		  map.put(102,"Vijay");    
		  map.put(103,"Rahul");   

		  System.out.println("First Key: "+map.firstKey());  //100
		   System.out.println("Last Key "+map.lastKey());   //103
		   System.out.println("headMap: "+map.headMap(102));  //100 101
		   System.out.println("tailMap: "+map.tailMap(102));  //102 103
		   System.out.println("subMap: "+map.subMap(100, 102)); //100 101 

	 }
 }  
 ------------------------------------------------------------------------------------------
 NavigableMap (HW)
 ------------------------------------------------------------------

IdentityHashMap :
--------------------
public class IdentityHashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Clonable, Serializable.

It was introduced from JDK 1.4 onwards.

The IdentityHashMap uses == operator to compare keys.

As we know HashMap uses equals() and hashCode() method for comparing the keys based on the hashcode of the object it will serach the bucket location and insert the entry their only.

So We should use IdentityHashMap where we need to check the reference or memory address instead of logical equality.

HashMap uses hashCode of the "Object key" to find out the bucket loaction in Hashtable, on the other hand IdentityHashMap does not use hashCode() method actually It uses System.identityHashCode(Object o)

IdentityHashMap is more faster than HashMap in case of Comparison.


It has three constrcutors, It does not contain loadFactor specific constructor.
-------------------------------------------------------------------
import java.util.*;
public class IdentityHashMapDemo 
{
	public static void main(String[] args) 
	{
		HashMap<String,Integer> hm = new HashMap<>();

		IdentityHashMap<String,Integer> ihm = new IdentityHashMap<>();
		
		hm.put("Ravi",23);
		hm.put(new String("Ravi"), 24);
		
		ihm.put("Ravi",23);
		ihm.put(new String("Ravi"), 27); //compares based on == operator
		
		System.out.println("HashMap size :"+hm.size());  //1
		System.out.println(hm);
		System.out.println("........................");
		System.out.println("IdentityHashMap size :"+ihm.size()); //2		
		System.out.println(ihm);

	}

}
------------------------------------------------------------------

WeakHashMap :-
------------------
public class WeakHashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>

It is a predefined class in java.util package under Map interface.It was introduced from JDK 1.2 onwards.

While working with HashMap, keys of HashMap are of strong reference type. This means the entry of  map will not be deleted by the garbage collector even though the key is set to be null and  still it is not eligible for Garbage Collector.

On the other hand while working with WeakHashMap, keys of WeakHashMap are of weak reference type. This means the entry of a map is  deleted by the garbage collector if the key value is set to be null because it is of weak type.

So, HashMap dominates over Garbage Collector where as Garbage Collector dominates over WeakHashMap.

It contains 4 types of Constructor :
---------------------------------------
1) WeakHashMap wm1 = new WeakHashMap();
   
    Creates an empty WeakHashMap object with default capacity is 16 and load fator 0.75


2) WeakHashMap wm2 = new WeakHashMap(int initialCapacity);

3) WeakHashMap wm3 = new WeakHashMap(int initialCapacity, float loadFactor);

    Eg:- WeakHashMap wm = new WeakHashMap(10,0.9);

    capacity - The capacity of this map is 10. Meaning, it can store 10 entries.

    loadFactor - The load factor of this map is 0.9. This means whenever our hashtable is filled up by 90%, the entries are moved to a new hashtable of double the size of the original hashtable.

4) WeakHashMap wm4 = new WeakHashMap(Map m);
------------------------------------------------------------------
import java.util.*;
public class WeakHashMapDemo
{
	public static void main(String args[])  throws Exception
	{
	    WeakHashMap map = new WeakHashMap();
		Test  t  = new Test();
		map.put(t," Rahul "); //here we passing reference 't' as a key

		System.out.println(map); //{Test demo = Rahul} 
		
		t = null;
		
		System.gc();	//Explicitly calling garbage collector 
		
		Thread.sleep(5000); 
		
		System.out.println(map); //{}
	}
}

class Test
{
	@Override
	public String toString()
	{
		return "Test demo";
	}
	
	@Override
	public void finalize() //called automaticaly if an object is eligible 4 GC
	{
		System.out.println("finalize method is called");
	}
}
------------------------------------------------------------------
Queue interface :-
-------------------

1) It is sub interface of Collection(I)

2) It works in FIFO(First In first out) 

3) It is an ordered collection.

4) In a queue, insertion is possible from last is called REAR where as deletion is possible from the starting is called FRONT of the queue.

5) From jdk 1.5 onwards LinkedList class implments Queue interface to handle the basic queue operations. 

PriorityQueue :
----------------
public class PriorityQueue extends AbstractQueue implements Serializable 

It is a predefined class in java.util package, available from Jdk 1.5 onwards.

The LinkedList class has been enhanced to implement Queue interface to handle basic operation of Queue.

A PriorityQueue is used when we want to store the Objects based on some priority.

The main purpose of PriorityQueue class is to create a "Priority in, Priority out" queue which is opposite to classical FIFO order.

A priority Queue stores the element in a natural sorting order where the elements which are sorted first, will be accessed first from top the queue.

A priority queue does not permit null elements as well as It uses Comparator interface to sort the elements.

It provides natural sorting order so we can't take non-comparable objects(hetrogeneous types of Object)

The initial capacity of PriorityQueue is 11.

Constructor :
--------------
1) PriorityQueue pq1 = new PriorityQueue();

2) PriorityQueue pq2 = new PriorityQueue(int initialCapacity);

3) PriorityQueue pq3 = new PriorityQueue(int initialCapacity, Comparator cmp);

4) PriorityQueue pq4 = new PriorityQueue(Collection c);


Methods :-
----------
add() / offer() :- Used to add an element in the Queue

poll() :- It is used to fetch the elements from top of the queue, after fetching it will delete the element.


peek() :- It is also used to fetch the elements from top of the queue, Unlike poll it will only fetch but not delete the element.

boolean remove(Object element) :- It is used to remove an element. The return  type is boolean.             
-------------------------------------------------------------------
import java.util.PriorityQueue;

public class PriorityQueueDemo 
{
      public static void main(String[] argv)
      {
            PriorityQueue<String> pq = new PriorityQueue<>();
            pq.add("Orange");
			pq.add("Apple");
			//pq.add(null); 
			System.out.println(pq.peek() ); //Apple    
			System.out.println(pq.poll() );   //Apple     
			System.out.println(pq.peek() ); //Orange
			System.out.println(pq);            //[Orange] 

      }
}
------------------------------------------------------------------
import java.util.PriorityQueue;
public class PriorityQueueDemo1 
{
      public static void main(String[] argv)
      {
            PriorityQueue<String> pq = new PriorityQueue<>();
            pq.add("9");
            pq.add("8");
			pq.add("7");
            System.out.print(pq.peek() + " ");  
            pq.offer("6");
			pq.offer("5");
            pq.add("3");

            pq.remove("1");    
            System.out.print(pq.poll() + " ");
            if (pq.remove("2"))
                System.out.print(pq.poll() + " ");
            System.out.println(pq.poll() + " " + pq.peek());
      }
}
----------------------------------------------------------------------
import java.util.PriorityQueue;
public class PriorityQueueDemo2
{
      public static void main(String[] argv)
      {
            PriorityQueue<String> pq = new PriorityQueue<String>();
            pq.add("2");
            pq.add("4");          
			pq.add("6");
            System.out.print(pq.peek() + " "); //2 2 3 4 4
            pq.offer("1");
			pq.offer("9");
            pq.add("3");   
			
            pq.remove("1");
            System.out.print(pq.poll() + " ");
            if (pq.remove("2"))
                System.out.print(pq.poll() + " ");
            System.out.println(pq.poll() + " " + pq.peek()+"  "+pq.poll());
	  }
}
----------------------------------------------------------------------

Generics :                      
-----------
Why generic came into picture : 
------------------------------------
As we know our compiler is known for Strict type checking because java is a statically typed checked language.

The basic problem with collection is It can hold any kind of Object.

ArrayList al = new ArrayList();
al.add("Ravi");
al.add("Aswin");
al.add("Rahul");
al.add("Raj");
al.add("Samir");

for(int i =0; i<al.size(); i++)
{ 
   String s = (String) al.get(i);
   System.out.println(s);
}

By looking the above code it is clear that Collection stores everything in the form of Object so here even after adding String type only we need type casting as shown below

-------------------------------------------------------------------------------------------
import java.util.*;
class Test1 
{
	public static void main(String[] args) 
	{
		ArrayList al = new ArrayList(); //raw type
		al.add("Ravi");
		al.add("Ajay");
		al.add("Vijay");		
			
		for(int i=0; i<al.size(); i++)
		{
		String name = (String)al.get(i); //type casting is required
		System.out.println(name);
		}		
	}
}
-------------------------------------------------------------------------------------------
Even after type casting there is no gurantee that the things which are coming from ArrayList Object is String only because we can add anything in the Collection as a result java.lang.ClassCastException as shown in the program below.
  ----------------------------------------------------------------------------------------
 import java.util.*;
class Test2
{
	public static void main(String[] args) 
	{
		ArrayList t = new ArrayList(); //raw type
		t.add("alpha");
		t.add("beta");
		for (int i = 0; i < t.size(); i++) 
		{
		  String str =(String) t.get(i);
		  System.out.println(str);
		}
		 t.add(1234);
		 t.add(1256);
		  for (int i = 0; i < t.size(); ++i)
	       {	 
			 String obj= (String)t.get(i); //we can't perform type casting here
			 System.out.println(obj);
		  }
	}
}

In the above program we have to write Object to hold the collection values, here we can't perform type casting otherwise we will get java.lang.ClassCastException
-------------------------------------------------------------------------------------------
To avoid all the above said problem Generics came into picture from JDK 1.5 onwards
 
 -> It deals with type safe Object so there is a gurantee of both the end i.e putting inside and getting out.
 
 Example:-
 ArrayList<String > al = new ArrayList<String>();

 Now here we have a gurantee that only String can be inserted as well as only String will come out from the Collection so we can perform String related operation.

 Advantages :-
 ---------------
 a) Type safe Object (No compiler warning)

 b) Strict compile time checking

 c) No need of type casting
---------------------------------------------------------------------
01-Aug-23
---------
import java.util.*;
public class Test3
{
public static void main(String[] args) 
{
		ArrayList<String> al = new ArrayList<>();  //Generic type
		al.add("Ravi");
		al.add("Ajay");
		al.add("Vijay");		
		
        for(int i=0; i<al.size(); i++)
		{
		String name = al.get(i); //no type casting is required
		System.out.println(name.toUpperCase());
		}
   }
}
---------------------------------------------------------------------
//Program that describes the return type of any method can be type safe 
//[We can apply generics on method return type]

import java.util.*;
public class Test4
{
	public static void main(String [] args)
	{
		Dog d1 = new Dog();
		Dog d2 = d1.getDogList().get(0);
		System.out.println(d2);
	}
}
class Dog
{
	public List<Dog> getDogList()
	{
		List<Dog> d = new ArrayList<Dog>();
		d.add(new Dog());
		d.add(new Dog());
		return d;
	}
}
-------------------------------------------------------------------------------------------
Note :- In the above program the compiler will stop us from returning anything which is not compaitable List<Dog> and there is a gurantee that only "type safe list of Dog object" will be returned so we need not to provide type casting as shown below
Dog d2 = (Dog) d1.getDogList().get(0);  //before generic.
---------------------------------------------------------------------
//Mixing generic with non-generic
import java.util.*;
class Car
{
}
public class Test5
{
	public static void main(String [] args) 
	{
	ArrayList<Car> a = new ArrayList<>();
	a.add(new Car());
	a.add(new Car());
    a.add(new Car());

	ArrayList b = a;  //assigning Generic to raw type  
	
    System.out.println(b);
   
	}
}
---------------------------------------------------------------------
//Mixing generic to non-generic
import java.util.*; 
public class Test6 
{
	public static void main(String[] args) 
	{ 
		List<Integer> myList = new ArrayList<>(); 
		myList.add(4); 
		myList.add(6); 
		myList.add(5);
        
		UnknownClass u = new UnknownClass(); 
		int total = u.addValues(myList); 
		System.out.println("The sum of Integer Object is :"+total); 
	} 
}  
class UnknownClass 
{ 
	public int addValues(List list)  //safe Object to unsafe object OR generic to raw type
	{ 	 
	Iterator it = list.iterator();    
	int total = 0; 
	while (it.hasNext()) 
	{
		int i = ((Integer)it.next());
		total += i;                           //total = 15
	} 
	return total; 
	} 
} 
Note :-
In the above program the compiler will not generate any warning message because even though we are assigning type safe Integer Object to unsafe or raw type List Object but this List Object is not inserting anything new in the collection so there is no risk to the caller.
---------------------------------------------------------------------
//Mixing generic to non-generic
import java.util.*; 
public class Test7 
{
	public static void main(String[] args) 
	{ 
		List<Integer> myList = new ArrayList<>(); 

		myList.add(4); 
		myList.add(6); 
		UnknownClass u = new UnknownClass(); 
		int total = u.addValues(myList); 
		System.out.println(total); 
	} 
}  
class UnknownClass 
{ 
    public int addValues(List list)  
	{ 
		list.add(5);	//adding object to raw type
		Iterator it = list.iterator(); 
		int total = 0; 
		while (it.hasNext()) 
		{
		int i = ((Integer)it.next()); 
		total += i; 
		} 
		return total; 
	} 
} 

*Type Erasure
------------

In the above program the compiler will  generate  warning message because the unsafe List Object is inserting the Integer object 5 so the type safe Integer objcet is getting value 5 from unsafe type so there is a problem to the caller method.

By writing ArrayList<Integer> actually JVM does not have any idea that our ArrayList was suppose to hold only Integers. 

All the type safe information does not exist at runtime. All our generic code is Strictly for compiler. There is a process done by java compiler called "Type erasure" in which the java compiler converts generic version to non-generic type.

List<Integer> myList = new ArrayList<Integer>();

At the compilation time it is fine but at runtime for JVM the code becomes

List myList = new ArrayList();

Note :- GENERIC IS STRICTLY A COMPILE TIME PROTECTION.
---------------------------------------------------------------------
//Polymorphism with array

import java.util.*;
abstract class Animal
{
	public abstract void checkup();
}

class Dog extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Dog checkup");
	}
}

class Cat extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Cat checkup");
	}
}

class Bird extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Bird checkup");
	}
}

public class  Test8
{
	public void checkAnimals(Animal x[])   // Animal []x = new Dog[2];
	{
		for(Animal a : x)
		{
			a.checkup();
		}
	}

	public static void main(String[] args) 
	{
		Dog []dogs={new Dog(), new Dog()};

		Cat []cats={new Cat(), new Cat(), new Cat()};

		Bird []birds = {new Bird(), new Bird()};

		Test8 t = new Test8();

		t.checkAnimals(dogs);
		t.checkAnimals(cats);
		t.checkAnimals(birds);
	}
}


Note :-From the above program it is clear that polymorphism(Upcasting) concept works with array.
-------------------------------------------------------------------------------------------
import java.util.*;
abstract class Animal
{
	public abstract void checkup();
}

class Dog extends Animal
{
    @Override
	public void checkup()
	{
		System.out.println("Dog checkup");
	}
}

class Cat extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Cat checkup");
	}
}
class Bird extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Bird checkup");
	}
}
public class Test9
{
	public void checkAnimals(List<Animal> animals)
	{
		for(Animal x : animals)
		{
             x.checkup();
		}
	}
	public static void main(String[] args) 
	{
		List<Dog> dogs = new ArrayList<Dog>();
		dogs.add(new Dog());
		dogs.add(new Dog());

		List<Cat> cats = new ArrayList<Cat>();
		cats.add(new Cat());
		cats.add(new Cat());

		List<Bird> birds = new ArrayList<Bird>();
		birds.add(new Bird());
		
		Test9 t = new Test9();
		t.checkAnimals(dogs);
		t.checkAnimals(cats);
		t.checkAnimals(birds);

	}
}
------------------------------------------------------------------------------------------
Note :- The above program will generate the compilation error.

So from the above program it is clear that polymorphism does not work in the same way for generics as it does with arrays.

Eg:-

Parent [] arr = new Child[5]; //valid
Object [] arr = new String[5]; //valid

But in generics the same type is not valid

List<Object> list = new ArrayList<Integer>(); //Invalid
List<Parent> mylist = new ArrayList<Child>(); //Invalid
---------------------------------------------------------------------
--------------
public class Test10
{
public static void main(String [] args)
	{	
		Object []obj = new String[3]; //valid with Array
		obj[0] = "Ravi";
		obj[1] = "hyd";
		obj[2] = 12; //java.lang.ArrayStoreException
	}
}

Note :- It will generate java.lang.ArrayStoreException because we are trying to insert 12 (integer value) into String array.

In Array we have an Exception called ArrayStoreException but the same Exception or such type of exception, is not available with Generics that is the reason in generics compiler does not allow upcasting concept.
(It is a strict compile time checking)
---------------------------------------------------------------------
02-Aug-23
---------
import java.util.*;
class Parent
{

}
class Child extends Parent
{
}

public class Test11
{
public static void main(String [] args)
	{	
		//ArrayList<Parent> lp = new ArrayList<Child>();

		ArrayList<Parent> lp1 = new ArrayList<Parent>(); 

		ArrayList<Child> lp2 = new ArrayList<>(); 

		System.out.println("Success");
	}
}
--------------------------------------------------------------------
Wild card character(?) :
------------------------
<?>			-: Many possibilities

<Animal>		-: Only <Animal> can assign, but not Dog or 
                           sub type of animal

<? super Dog>	-: Dog, Animal, Object can assign (Compiler has surity)

<? extends Animal) -: Below of Animal means, sub classes of Animal (But the compiler does not have surity because you can have many sub classes of Animal in the future, so chances of wrong collections)
---------------------------------------------------------------------
//program on wild-card chracter
import java.util.*;
class Parent
{

}
class Child extends Parent
{
}
public class Test12
{
public static void main(String [] args)
	{	
		List<?> lp = new ArrayList<Child>(); 
		System.out.println("Wild card....");
	}
}
---------------------------------------------------------------------
import java.util.*;
public class Test13 
{
	public static void main(String[] args) 
	{
		List<? extends Number> list1 = new ArrayList<Integer>();

		List<? super String> list2 = new ArrayList<Object>();

		List<Integer> list3 = new ArrayList<Integer>();

		List list4 = new ArrayList();

		System.out.println("yes");
	}
}
---------------------------------------------------------------------
import java.util.*;
public class  Test14
{
	public static void main(String[] args) 
	{
		try
		{
		List<Object> x = new ArrayList<>(); //Array of Object[java 9]
            x.add(10);
			x.add("Ravi");
			x.add(true);
			x.add(34.89);
			System.out.println(x);
		}
		catch (Exception e)
		{
			System.out.println(e);
		}
	}
}
---------------------------------------------------------------------
The following program describes how to work with independent data type so we will get flexibility:
--------------------------------
class MyClass<T>      
{
	T obj;
	public MyClass(T obj)       //obj = 12 that is Integer Object
	{
		this.obj=obj;
	}

	T getObj()
	{
		return obj;
	}
}
public class Test15
{
	public static void main(String[] args) 
	{
		Integer i=12;
		MyClass<Integer> mi = new MyClass<Integer>(i);
		System.out.println("Integer object stored :"+mi.getObj());

		Float f=12.34f;
		MyClass<Float> mf = new MyClass<Float>(f);
		System.out.println("Float object stored :"+mf.getObj());

		MyClass<String> ms = new MyClass<String>("Rahul");
		System.out.println("String object stored :"+ms.getObj());

		MyClass<Boolean> mb = new MyClass<Boolean>(false);
		System.out.println("Boolean object stored :"+mb.getObj());

		Double d=99.34;
		MyClass<Double> md = new MyClass<Double>(d);
		System.out.println("Double object stored :"+md.getObj());
		
	}
}
---------------------------------------------------------------------
//E stands for Element type
class Fruit    
{
}
class Apple extends Fruit   //Fruit is the super, Apple is sub class
{
}

class Basket<E>      //E type is Fruit
{
	private E element;	
	public void setElement(E element)    //Fruit element = new Apple();
	{
		this.element = element;
	}	

	public E getElement() 
	{
		return element;		
	}
}

public class Test16
{
	public static void main(String[] args) 
	{
		Basket<Fruit> b = new Basket<Fruit>();
		b.setElement(new Apple());

		Apple x = (Apple) b.getElement();	
		System.out.println(x);
		
	}
}
---------------------------------------------------------------------
Concurrent collections in java :
---------------------------------




































































































 

































































































































     







































































































































































































    












































 






























































































































































































































































































