javaravishanker@gmail.com
22nd August 2024

Write a Program to add two numbers :
------------------------------------
public class Addition 
{
	public static void main(String[] args) 
	{
		int x = 100;
		int y = 200;
		int z = x + y;
		System.out.println(z);
	}
}

How to provide user-friendly message :
--------------------------------------
In order to provide user-friendly message we can use '+' operator.

Behavior of '+' Operator :
--------------------------
1 + 1 = 2  [Here '+' operator is working as Arithmetic Operator]

"1" + 1 = 11 [Here '+' operator is working as Concatenation Operator]

22 + "22" = 2222 [Here '+' operator is working as Concatenation Operator]

"NIT" + 22 = NIT22 [Here '+' operator is working as Concatenation Operator]

While Working with '+' operator, if any of the operand is String type then '+' operator will behave as String concatenation operator.

//Providing User-friendly message

public class Addition 
{
	public static void main(String[] args) 
	{
		int x = 100;
		int y = 200;
		int z = x + y;
		System.out.println("The Sum is :"+z);
	}
}
--------------------------------------------------------------------------
//Program to add two numbers without using 3rd variable
public class Sum 
{
	public static void main(String[] args) 
	{
		int x = 100;
		int y = 200;

		System.out.println("The Sum is :"+x+y); //100200
		System.out.println(+x+y); //300
		System.out.println(""+x+y);
		System.out.println("The Sum is :"+(x+y));
	}
}
-------------------------------------------------------------------------
Difference between println() and print() method :
-------------------------------------------------
print() method will print the data and it will keep the cursor in the same line where as println() method will print the data and move the cursor to the next line.

//Difference between println() and print() method :
public class Printing 
{
	public static void main(String[] args) 
	{
		System.out.println("Hello "); //Hello 
		System.out.println("World");  //World

	}
}
----------------------------------------------------------------------
Command Line Argument :
-----------------------
If we pass an argument to the main method then it is called command line Argument.

By using command line argument, We can pass some value at runtime i.e. at the time of execution of the program.

The advantage is, Single time compilation and number of time execution with different values.

//Program on command Line Argument
public class Command 
{
	public static void main(String[] args) 
	{
		System.out.println(args[0]);     

	}
}

javac Command.java
java Command Virat Rohit Scott

It will print Virat
-----------------------------------------------------------------------
//Program to print complete Name of a player
public class FullName 
{
	public static void main(String[] x) 
	{
		System.out.println(x[0]);
		
	}
}

javac FullName.java
java FullName "Virat Kohli"

It will print Virat Kohli
------------------------------------------------------------------------
//Single time compilation and number of times execution
public class CommandDemo 
{
	public static void main(String[] args) 
	{
		System.out.println(args[0]);
	}
}

javac CommandDemo.java

java CommandDemo Scott
It Will print Scott

java CommandDemo Smith
It Will print Smith

java CommandDemo Martin
It Will print Martin
------------------------------------------------------------------------
//Accepting integer value from command line Argument
public class AcceptInteger 
{
	public static void main(String[] args) 
	{
		System.out.println(args[0]);
	}
}

javac AcceptInteger.java
java AcceptInteger 100 -> It will print 100 
java AcceptInteger 12.90 -> It will print 12.90
java AcceptInteger A -> It will print A 

Note : All Command Line Arguments are treated as String Object, even if they represent another data type like number.
------------------------------------------------------------------------
29-08-2024
-----------
Program to add two numbers by using Command Line Argument :
----------------------------------------------------------
public class CommandAdd
{
	public static void main(String[] x) 
	{
		System.out.println(x[0] + x[1]);
	}
}

javac CommandAdd.java
java CommandAdd 100 200

It will print 100200 [Here '+' operator will work as String concatenation operator]
-------------------------------------------------------------------------
How to convert a String value into integer :
---------------------------------------------
There is a predefined class called Integer, available in java.lang package. It contains a predefined static method parseInt(String x), by using this method we can convert a String into integer value.

Example :
---------
public class Integer
{
  public static int parseInt(String x)
  {
     //Will accept String and convert into integer
  }
}
------------------------------------------------------------------------
//Adding two numbers by converting then into integer

public class CommandAddition 
{
	public static void main(String[] args) 
	{
		String x = args[0];
		String y = args[1];

        //Converting String into integer
		int num1 = Integer.parseInt(x);
		int num2 = Integer.parseInt(y);

		System.out.println("Sum is :"+(num1 + num2));
         
	}
}
=========================================================================
WAP that describes how exactly Integer.parseInt() is working internally ?
-------------------------------------------------------------------------
public class Calculate 
{
   public static int doSum(int x, int y)
	{       
       return x+y;
	}

    public static int getSquareOfNumber(int num)
	{
		return num*num;
	}


	public static void main(String[] args) 
	{
		int sum = Calculate.doSum(100,200);
		System.out.println("Sum is :"+sum);


        int square =  Calculate.getSquareOfNumber(5);
		System.out.println("Square is :"+square);
	}
}
------------------------------------------------------------------------
How to convert a String into double ?
-------------------------------------
double d = Double.parseDouble(String x);


How to convert a String into float ?
-------------------------------------
float y =  Float.parseFloat(String x);
=========================================================================
Working with Eclipse IDE :
--------------------------
IDE stands for "Integrated Dvelopment Environment". 

By using Eclipse IDE, We can develop, compile and execute our java program in a single window.

The main purpose of eclipse IDE is reduce the development time, once development time will be reduced then automatically the cost of the project will be reduced.
------------------------------------------------------------------------
What is a package?
------------------
A package is folder in windows. In java to create a package we are using package keyword, It must be first statement of the program.

Example :
---------
package basic;

public class Hello
{
}

How to compile : javac  -d  .  Hello.java
                 [javac space -d space . space FileName.java]

Here one folder will be created called basic (package name ) and Hello.class file will be automatically placed in the basic folder.


 Types of Packages :
---------------------------
1) Predefined OR Built-in package : The packages which are created by java software people for arranging the programs are called predefined package.

Example : java.lang, java.util, java.io, java.sql, java.net and so on

2) Userdefined Package OR Custom package : The packages which are created by user for arranging the user-defined programs are called user-defined package.

Example :
basic;
com.ravi.basic;
com.tcs.online_shopping;
------------------------------------------------------------------------
How to execute command line argument program by using Eclipse IDE :
-------------------------------------------------------------------
package basic;

public class Command 
{
	public static void main(String[] args) 
	{
		System.out.println(args[1]);
	}

}

Right click on the program -> Run As -> Run configuration -> Check your main class name -> select argument tab -> pass the appropriate value -> Run
------------------------------------------------------------------------
Write a program to find out the area of Rectangle where length and  breadth of the Rectangle must be taken from user from command line argument.

package basic;

public class AreaOfRectangle 
{
 public static void main(String[] args)
  {
	  int length = Integer.parseInt(args[0]); 
	  int breadth = Integer.parseInt(args[1]);
	  
	  int areaOfRect = length * breadth;
	  System.out.println("Area of Rect is :"+areaOfRect);
  }
}
-------------------------------------------------------------------------
30-08-2024
-----------
Naming convention in java ?
----------------------------
Naming convention provides two important characteristics :

 a) Standard Code (Industry accepted code)
 b) Readability of the code will enhance.

1) How to write a class in java :
----------------------------------
While writing a class in java, we should follow pascal naming convention.
Here first character of each word must be capital. In java, a class represents noun.

Example :
---------
ThisIsExampleOfClass

System
String
Integer
DataInputStream
ArrayIndexOutOfBoundsException
Object
BufferedReader

2) How to write a method in java :
----------------------------------
While writing a method we should follow camel case naming convention, according to this from 2nd word onwards first character of each word must be in capital. It represents verb.

Example :
thisIsExampleOfMethod

parseInt()
readLine()
read()
print()
println()
toUpperCase()
toLowerCase()


3) How to write a field/variable in java :
-------------------------------------------
While writing a variable we should follow camel case naming convention but unlike method variable does not have () symbol.

Example :
----------
rollNumber    
customerName
customerBill
studentName
playerName

4) How to write a final and static variable :
---------------------------------------------
While writing the final and static variable we should follow snake_case naming convention.

Example :
Integer.MIN_VALUE  [MIN_VALUE is final and static variable]
Integer.MAX_VALUE  [MAX_VALUE is final and static variable]

5) How to write a package :
---------------------------
A package must be written in lower case only. Generally it is reverse of company name.

com.nit.basic
com.tcs.introduction
com.wipro.shopping

-------------------------------------------------------------------------
Tokens in java :
----------------
Token is the smallest unit of the program which is identified by the compiler.

Without token we can't complete statement or expression in java.

Token is divided into 5 types in java

  1) Keyword
  2) Identifier
  3) Literal
  4) Punctuators (Seperators)
  5) Operator


Keyword
--------
A keyword is a predefined word whose meaning is already defined by the compiler.

In java all the keywords must be in lowercase only.

A keyword we can't use as a name of the variable, name of the class or name of the method.  

true, false and null look like keywords but actually they are literals.

As of now, we have 67 keywords in java.
--------------------------------------------------------------------
Identifiers :
--------------
A name in java program by default considered as identifiers.

Assigned to variable, method, classes to uniquely identify them.

We can't use keyword as an identifier.

Ex:-

class Fan 
{
   int coil  ;
   
   void switchOn()  
   {
   }
}

Here Fan(Name of the class), coil (Name of the variable) and switchOn(Name of the Method) are identifiers.
------------------------------------------------------------------------------------
Rules for defining an identifier :
------------------------------------
1) Can consist of uppercase(A-Z), lowercase(a-z),  digits(0-9), $ sign, and underscore (_)
2) Begins with letter, $, and _
3) It is case sensitive
4) Cannot be a keyword
5) No limitation of length 
-------------------------------------------------------------------------
Literal :
---------
The constant values which we are assigning to a variable is called literal.

In java we have 5 types of Literals :

1) Integral Literal
2) Floating Point Literal
3) Character Literal
4) Boolean Literal
5) String Literal

Note : null is also literal.
-------------------------------------------------------------------------
Integral Literal :
------------------
If any numeric literal does not contain decimal or fraction then it is called Integral Literal.

Example : 34, 100, 45, 900

In order to represent an integral literal, we have 4 data types 
  byte (8 bits)
  short (16 bits)
  int (32 bits)
  long (64 bits)

An integral literal we can represent in four different forms

a) Decimal Literal
b) Octal Literal
c) Hexadecimal Literal
d) Binary Literal (Available from JDK 1.7)

Decimal Literal :
-----------------
By default our numeric literals are decimal literal. Here base is 10 so, It accepts 10 digits i.e. from 0-9.

Example : 
int x = 20;
int y = 123;
int z = 234;

Octal Literal :
---------------
If any Integer literal starts with 0 (Zero) then it will become octal literal. Here base is 8 so it will accept 8 digits i.e 0 to 7.

Example :

int a = 018; //Invalid becuase it contains digit 8 which is out of range
int b = 0777; //Valid
int c = 0123; //Valid


Hexadecimal Literal :
---------------------
If a numeric literal starts with 0X (Zero capital X) OR 0x (zero small x) then it will become Hexadecimal literal. Here base is 16 so it will accept 16 digits i.e 0 to 9 and A - F.

Example :

int x = 0X12; //Valid
int y = 0xadd; //Valid
int z = 0Xface; //valid
int a = 0Xage; //Inavlid because character 'g' out of range

Binary Literal :
---------------
If a numeric literal starts with 0B (Zero capital B) or 0b (Zero small b) then it will become Binary literal. Binary literal is available from JDK 1.7v.
Here base is 2 so it will accept 2 digits i.e 0 and 1.

Note : As a developer we can represent a numeric literal into octal, hexadecimal and binary but to get the output(result), JVM will convert into decimal format only.
-------------------------------------------------------------------------
//Octal Literal
public class Test1 
{
  public static void main(String [] args)
  {
     int x = 015;  
	 System.out.println(x);
     
  }
}
------------------------------------------------------------------------
//Hexadecimal Literal
public class Test2 
{
  public static void main(String [] args)
  {
     int x = 0Xadd;  
	 System.out.println(x);
     
  }
}
------------------------------------------------------------------------
//Binary Literal
public class Test3 
{
  public static void main(String [] args)
  {
     int x = 0B101;  
	 System.out.println(x);
     
  }
}
-------------------------------------------------------------------
By default every integral literal is of type int only. byte and short are below than int so we can assign integral literal(Which is by default int type) to byte and short but the values must be within the range. [for Byte -128 to 127 and for short -32768 to 32767]

Actually whenever we are assigning integral literal to byte and short data type then compiler internally converts into corresponding type.

byte b = (byte) 12; [Compiler is converting int to byte]
short s = (short) 12; [Compiler is converting int to short]

In order to represent long value we should use either L OR l (Capital L OR Small l) as a suffix to integral literal.

According to IT industry, we should use L bacause l looks like digit 1.
-------------------------------------------------------------------------
31-08-2024
----------

/* By default every integral literal is of type int only*/
public class Test4
{
public static void main(String[] args)
	{
                byte b = 128; //error int can'tbe converted to byte
		System.out.println(b);
		
		short s = 32768;  //error int can'tbe converted to shot
		System.out.println(s);
    }
}
-----------------------------------------------------------------------
//Assigning smaller data type value to bigger data type
public class Test5
{
public static void main(String[] args)
	{
   	    byte b = 125;  
		short s = b;  //[Implicit OR Automatic OR Widening]
		System.out.println(s);
	}
}
------------------------------------------------------------------------
//Converting bigger type to smaller type
public class Test6
{
public static void main(String[] args)
	{
		short s = 127;
		byte b =  (byte) s; //Explicit OR Manual OR Narrowing
		System.out.println(b);
	}
}

Note : User is responsible to provide Explicit type casting (In case user is trying to assign bigger to smaller type) but here there is chance of loss of data.
-------------------------------------------------------------------------
public class Test7
 {
 public static void main(String[] args)
 {
		byte x = (byte) 127L;
		System.out.println("x value  = "+x);

		long l = 29L;
		System.out.println("l value  = "+l);

        int y =  (int) 18L; 
		System.out.println("y value  = "+y);
 
  }
 } 
-----------------------------------------------------------------------
Is java pure Object Oriented Language ?
---------------------------------------
No, Java is not a pure object oriented langauge because it is accepting primary data type, Actually any language which accepts primary data type is not a pure object oriented language.

Only Objects are moving in the network but not the primary data type so java has introduced Wrapper class concept to convert the primary data types into corresponding wrapper object.

Primary Data type           Wrapper Object
	byte		:	Byte
	short		:	Short
	int		:	Integer
	long		:	Long
	float		:	Float
	double		:	Double
	char		:	Character
	boolean		:	Boolean


Note : Apart from these 8 data types, Everything is an object in java so, if we remove all these 8 data types then java will become pure OOP language.
-------------------------------------------------------------------------
//Wrapper claases
public class Test8 
{
	public static void main(String[] args) 
	{
		Integer x = 24;  
		Integer y = 24;
		Integer z = x + y;
		System.out.println("The sum is :"+z);	
		
		Boolean b = true;
		System.out.println(b);

		Double d = 90.90;
		System.out.println(d);

		Character c = 'A';
		System.out.println(c);
	}
}
------------------------------------------------------------------------
How to find out the minimum, maximum value as well as size of different data types :

The Warpper classes like Byte, Short, Integer and Long has provided predefined static and final variables to represent minimum value, maximum value as well as size of the respective data type.

Example : 

If we want to get the minimum value, maximum value as well as size of byte data type then Byte class (Wrapper class) has provided the following final and static variables

Byte.MIN_VALUE   : -128

Byte.MAX_VALUE   :  127

Byte.SIZE        :  8 (bits format)

-------------------------------------------------------------------------
 //Program to find out the range and size of Integeral Data type
public class Test9 
{
	public static void main(String[] args) 
	{
		System.out.println("\n Byte range:");
		System.out.println(" min: " + Byte.MIN_VALUE);
		System.out.println(" max: " + Byte.MAX_VALUE);
		System.out.println(" size :"+Byte.SIZE);
 
		System.out.println("\n Short range:");
		System.out.println(" min: " + Short.MIN_VALUE);
		System.out.println(" max: " + Short.MAX_VALUE);
		System.out.println(" size :"+Short.SIZE);

		System.out.println("\n Integer range:");
		System.out.println(" min: " + Integer.MIN_VALUE);
		System.out.println(" max: " + Integer.MAX_VALUE);
		System.out.println(" size :"+Integer.SIZE);

		System.out.println("\n Long range:");
		System.out.println(" min: " + Long.MIN_VALUE);
		System.out.println(" max: " + Long.MAX_VALUE);
		System.out.println(" size :"+Long.SIZE);
		
	}
}
------------------------------------------------------------------------
Providing _ (underscore) in integeral Literal :
------------------------------------------------
In Order to enhance the readability of large numeric literals, Java software people has provided  _ (underscore) from JDK 1.7v. While writing the big numbers to separate the numbers we can use _

We can't start or end an integral literal with _ we will get compilation error.

//We can provide _ in integral literal
public class Test10 
{
	public static void main(String[] args) 
	{
	    long mobile = 98_1234_5678L;
	    System.out.println("Mobile Number is :"+mobile);
	}
}
------------------------------------------------------------------------
public class Test11 
{
	public static void main(String[] args) 
	{
		final int x = 127;  //final we are using in place of const
		byte b = x;
		System.out.println(b);
	}
}

The above program will compile as well as execute.
-------------------------------------------------------------------------
var keyword in java :
---------------------
var keyword is introduced from java 10v. 
It can be used inside the method only.
It must be initialized in the same line where we are declaring the variable with var keyword.
It is also known as local variable type inference.

public class Test12 
{
	public static void main(String[] args) 
        { 
           var x = 10; //Initialization is compulsory here
	   System.out.println(x);
	  
	}

}
------------------------------------------------------------------------
Converting from Decimal to another number System :
---------------------------------------------------
If we want to convert decimal to another numeber system then Integer class has provided the following methods toBinaryString(), toOctalString(), toHexString() to convert from decimal to binary, octal and hexadecimal repectively.

// Converting from decimal to another number system
public class Test13 
{
      public static void main(String[] argv) 
      {
		   //decimal to Binary
           System.out.println(Integer.toBinaryString(7)); //111

		   //decimal to Octal  
           System.out.println(Integer.toOctalString(15)); //17

		   //decimal to Hexadecimal
           System.out.println(Integer.toHexString(2781)); //add 
      }
}

Integer class static methods :
--------------------------------
1) public static String toBinaryString(int x)
2) public static String toOctalString(int x)
3) public static String toHexString(int x)

------------------------------------------------------------------------
02-09-2024
-----------
floating point literal :
------------------------
*If a numeric literal contains decimal or fraction then it is called Floating point Literal.
Example : 78.90, 89.45, 12.90


*In floating point literal, we have 2 data types 
          float (32 bits)
	  double (64 bits)


*By default every floating point literal is of type double only.
double d1 = 12.90;//Valid

*But if we try to assign double literal  directly to the float type then we will get compilation error.

               float f1 = 8.9; //error

*We can represent double type into float type by using the following 3 ways 

          float f2 = (float) 9.8; //Valid
	  float f3 = 7.7f; //Valid
	  float f4 = 8.5F; //Valid

*Even though, every floating point literal is of type double only, compiler has provided the following two flavors to represent the double value explicitly, just to enhance the redability of the code.

            double d1 = 12D;
	    double d2 = 56d;

* We can represent an integral literal in four different forms, i.e. decimal, octal, hexadecimal and binary but a floating point literal can be represented by only form i.e DECIMAL.

* A floating point literal we can represent in exponent form.
  Example : double d1 = 15e2; (15 X 10 to the power 2)
            double d2 = 15e-2;


* An integral literal (byte, short, int and long) we can assign to floating point literal but a floating point literal we can't assign to 
integral literal directly.
-----------------------------------------------------------------------
public class Test 
{
	public static void main(String[] args) 
	{
		float f = 2.0; //error
		System.out.println(f);				
	}
}
------------------------------------------------------------------------
public class Test1 
{
	public static void main(String[] args) 
	{		
		float b = 15.29F;
		float c = 15.25f;
		float d = (float) 15.30;

		System.out.println(b + " : "+c+ " : "+d);
       
	}
}
-------------------------------------------------------------------------
public class Test2 
{
	public static void main(String[] args) 
	{
		double d = 15.15;
		double e = 15d;
		double f = 15.15D;
		
		System.out.println(d+" , "+e+" , "+f);
	}
}
-------------------------------------------------------------------------
public class Test3 
{
	public static void main(String[] args) 
	{
		 double x = 0129.89;  

		 double y = 0167;

		 double z = 0178; //error [8 is out of the range]

		System.out.println(x+","+y+","+z);
	}
}
-------------------------------------------------------------------------
class Test4 
{
	public static void main(String[] args) 
	{
		double x = 0X29;  

		double y = 0X9.15; //error
		
		System.out.println(x+","+y);
	}
}
-------------------------------------------------------------------------
public class Test5 
{
	public static void main(String[] args) 
	{
		double d1 = 15e-3;
		System.out.println("d1 value is :"+d1);		

		double d2 = 15e3;
		System.out.println("d2 value is :"+d2);		
	}
}
-------------------------------------------------------------------------
public class Test6 
{
	public static void main(String[] args) 
	{
		double a = 0791; 

		double b = 0791.0; 

		double c = 0777;  

		double d = 0Xdead; 
		
		double e = 0Xdead.0; 
	}
}
------------------------------------------------------------------------
public class Test7 
{
	public static void main(String[] args) 
	{
	   double a = 1.5e3;
	   float b = 1.5e3; //error   
	   float c = 1.5e3F; 	   
	   double d = 10; 	   
	   int e = 10.0; //error
	   long f = 10D; //error
	   int g = 10F;   //error
	   long l = 12.78F; //error
	}
}
-------------------------------------------------------------------------
//Range and size of floating point literal 
public class Test8 
{
	public static void main(String[] args)    
	{
		System.out.println("\n Float range:");
		System.out.println(" min: " + Float.MIN_VALUE);
		System.out.println(" max: " + Float.MAX_VALUE); 
		System.out.println(" size :"+Float.SIZE);

		System.out.println("\n Double range:");
		System.out.println(" min: " + Double.MIN_VALUE);
		System.out.println(" max: " + Double.MAX_VALUE);
		System.out.println(" size :"+Double.SIZE);
	}
} 
------------------------------------------------------------------------
Character Literal :
--------------------
It is also known as char literal.

We have only one data type i.e. char data type which accepts 16 bits of memory.

char literal we can represent in the following different ways :

 a) Single character enclosed with single quotes. 
    char ch = 'A';

 b) In older languages like C and C++, which support ASCII value and range of value is 0 - 255 that means we can assign 0 - 255 to represent
 ASCII value of that particular character.
 But in java we can assign 0 - 65535 to represent different characters from different languages because Java support UNICODE chracter System.

              Example :
	      char ch1 = 65535;  //Valid
	      char ch2 = 65536;  //Invalid


c) In order to get the UNICODE value of the character, we can assign char literal to integral literal.

            Example :
	    int x = 'A';

d) All the escape sequences we can represent as a char literal.	

           Example :
          char ch = '\n';

e) We can represent char literal in 4 digit hexadecimal UNICODE format, 
   where the format is 

                '\uXXXX'

           Here u stand for UNICODE [only small u]
	   XXXX represents exactly 4 digit.

           Minimum Range = '\u0000'
	   Maximum Range = '\uffff'


	   Example : char ch = '\u0061';   //a
-------------------------------------------------------------------------
03-09-2024
----------
public class Test1 
{
	public static void main(String[] args) 
	{
		char ch1 = 'a';
		System.out.println("ch1 value is :"+ch1); 

		char ch2 = 97;   
		System.out.println("ch2 value is :"+ch2); 
      
		
	}
}
-----------------------------------------------------------------------
public class Test2 
{
	public static void main(String[] args) 
	{
		int ch = 'A';
		System.out.println("ch value is :"+ch);
	}
}
-----------------------------------------------------------------------
//The UNICODE value for ? character is 63 
public class Test3 
{
	public static void main(String[] args) 
	{
		char ch1 = 63;  
		System.out.println("ch1 value is :"+ch1);
		
		char ch2 = 64;  
		System.out.println("ch2 value is :"+ch2); 

		char ch3 = 65; 
		System.out.println("ch3 value is :"+ch3); 
	}
}
-----------------------------------------------------------------------
public class Test4 
{
	public static void main(String[] args) 
	{
		char ch1 = 32000;
        System.out.println("ch1 value is :"+ch1); 

		char ch2 = 0Xadd;  
		System.out.println("ch2 value is :"+ch2); 
	}
}

Note : We will get the output ? and ? because in the current system the 
       language translator is not available so itis unable to translate the given UNICODE value into corresponding character.
 -----------------------------------------------------------------------
//Addition of two character in the form of Integer
public class Test5
{
public static void main(String txt[ ])
  {
	int x = 'A'; 
    int y = 'B';
    System.out.println(x+y); //131
	System.out.println('A' + 'A'); //130
   } 
} 
------------------------------------------------------------------------
//Range of UNICODE Value (65535) OR '\uffff'
class Test6 
{
	public static void main(String[] args) 
	{
		char ch1 = 65535; 
		System.out.println("ch value is :"+ch1);

		char ch2 = 65536; //error
		System.out.println("ch value is :"+ch2);
	}
}
------------------------------------------------------------------------
//WAP in java to describe unicode representation of char in hexadecimal format
public class Test7 
{
	public static void main(String[] args) 
	{
		int ch1 = '\u0000'; 
		System.out.println(ch1);

		int ch2 = '\uffff'; 
		System.out.println(ch2);

		char ch3 = '\u0041'; 
        System.out.println(ch3); //A  

		char ch4 = '\u0061';
		System.out.println(ch4); //a
	}
}
-----------------------------------------------------------------------
class Test8 
{
	public static void main(String[] args) 
	{
		char c1 = 'A';
		char c2 = 65;
		char c3 = '\u0041';

		System.out.println("c1 = "+c1+", c2 ="+c2+", c3 ="+c3);
	}
}
------------------------------------------------------------------------
class Test9 
{
	public static void main(String[] args) 
	{
		int x = 'A';
		int y = '\u0041';
		System.out.println("x = "+x+" y ="+y);
	}
}
------------------------------------------------------------------------
//Every escape sequence is char literal
class Test10 
{
	public static void main(String [] args) 
	{
		char ch ='\n';
		System.out.println("Hello");
		System.out.println(ch);
		
	}
}
-----------------------------------------------------------------------
public class Test11  
{
	public static void main(String[] args) 
	{
		System.out.println(Character.MIN_VALUE); //white space
		System.out.println(Character.MAX_VALUE); //?
		System.out.println(Character.SIZE); //16 bits
		
	}
}
------------------------------------------------------------------------
Boolean Literal :
------------------
In boolean literal we have only data type i.e boolean data type.

It accepts 1 bit of memory and also depends upon JVM implemention.

We can represent two states either true or false.

   boolean isEmpty = true;
   boolean isAlive = false;


Unlike C and C++, we can't assign numberic value to boolean type.

   boolean b = 1;  //Invalid [Valid in C and C++]

We can't assign String literal to boolean data type.
------------------------------------------------------------------------
public class Test1
{
    public static void main(String[] args)
    {
        boolean isValid = true;   
        boolean isEmpty = false;
		
        System.out.println(isValid);
        System.out.println(isEmpty);
     }
}
-----------------------------------------------------------------------
public class Test2
{
    public static void main(String[] args)
    {
	boolean c = 0; //error
        boolean d = 1; //error
        System.out.println(c);
        System.out.println(d);       
    }
}
-----------------------------------------------------------------------
public class Test3 
{
	public static void main(String[] args) 
	{
		boolean x = "true";  //error
		boolean y = "false"; //error 
		System.out.println(x);
        System.out.println(y); 
	}
}
-----------------------------------------------------------------------
String Literal :
----------------
String is a collection of characters which will be enclosed with double quotes. 

It can accept different types symols, numbers, characters because String is a collection alpha-numeric character.

In Java we can create String by using following 3 ways :

1) By Using String Literal :
----------------------------
   String str = "india"; 

2) By using new keyword :
-------------------------
   String str1 = new String("Hyderabad");

3) By using character array [Old Approach]
------------------------------------------
   char ch[] = {'R', 'A', 'J'};
-----------------------------------------------------------------------
//Three Ways to create the String Object
public class StringTest1 
{
	public static void main(String[] args) 
	{
		String s1 = "Hello World";       //Literal
		System.out.println(s1);

		String s2 = new String("Ravi"); //Using new Keyword
		System.out.println(s2);

		char s3[] = {'H','E','L','L','O'}; //Character Array 
		System.out.println(s3);

	}
}
------------------------------------------------------------------------
//String is collection of alpha-numeric character
public class StringTest2 
{
	public static void main(String[] args) 
	{
		String x="B-61 Hyderabad";
		System.out.println(x);
		
		String y = "123";  
		System.out.println(y);

		String z = "67.90";       
		System.out.println(z);

		String p = "A";        
		System.out.println(p);
	}
}
-----------------------------------------------------------------------
IQ
--
//IQ
public class StringTest3
{
	public static void main(String []args)
	{		
		String s = 15+29+"Ravi"+40+40; 
		System.out.println(s);	
		
	}
}
======================================================================
4) Punctuators :
----------------
It is  also called separators.

It is used to inform the compiler how things are grouped in the code.

()  {}   []   ;   ,   .   @   … (var args)  
-----------------------------------------------------------------
5) Operators 
------------
It is a symbol which describes that how a calculation will be performed on operands.

Types Of Operators :
------------------------
1) Arithmetic Operator (Binary Operator)

2) Unary Operators

3) Assignment Operator

4) Relational Operator

5) Logical Operators (&&  ||  !)  

6) Boolean Operators (&  |)

7) Bitwise Operators (^  ~)

8) Ternary Operator

*9) Member Operator( Dot . Operator)

*10) new Operator

*11) instanceof Operator [It is also relational operator]

-----------------------------------------------------------------------
Basic Concepts of Operators :
-----------------------------
class Test 
{
	public static void main(String[] args) 
	{
               int x = 15;
		int y = x++;
		System.out.println(x + " : "+ y);
	}
}
-----------------------------------------------------------------------
class Test 
{
	public static void main(String[] args) 
	{
        int x = 15;
		int y = --x;;
		System.out.println(x + " : "+ y);
	}
}
------------------------------------------------------------------------
class Test 
{
	public static void main(String[] args) 
	{
        int x = 15;
		int y = ++5;
		System.out.println(x + " : "+ y);
	}
}
-----------------------------------------------------------------------
class Test 
{
	public static void main(String[] args) 
	{
         int x = 5;
	  int y = ++(++x); 
	  System.out.println(x +": "+y);
	}
}
-----------------------------------------------------------------------
class Test 
{
	public static void main(String[] args) 
	{
       char ch = 'A';
	   ch++;
	   System.out.println(ch);
	}
}
------------------------------------------------------------------------
class Test 
{
	public static void main(String[] args) 
	{
           double d1 = 12.12;
	   d1++;
	   System.out.println(d1);
	}
}

Note :- Increment and Decrement Operator we can apply with any data type except boolean.
----------------------------------------------------------------
04-09-2024
-----------
What is local variable ?
------------------------
If we declare any variable inside a method OR block OR constructor then it is called local/ stack/ temporary/ automatic variable.

Example :
---------
public void m1()
{
   int x = 100;  //Local Variable
}

A local variable must be initialized by the developer before use becuase we don't have default value for local variable.

We can't apply any kind of access modifier on local variable except final.

Without declaration and initialization we can't access local variable.

A local variable can be use from the same method, block or constructor only.[Scope is within the same method, block or constructor]
--------------------------------------------------------------------
Example :
----------
public class Test
{   
    public static void main(String [] args)
    {
	   final int x = 10;
	   System.out.println(x);
	}
}



Why we can't access local variable outside of the method or block or 
--------------------------------------------------------------------
constructor :
-------------

In java, Methods are executed in a special memory area called Stack area.

Stack is data structure which works on the basis of LIFO.

In java whenever we call a method then one stack frame is cretaed internally.

This Stack frame will automatically deleted, once the execution of the method is completed so with that stack frame all the local variables and parameter variables are also deleted from the memory as shown in the Program below.

public class MethodExecution 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Method started");
         m1();
		System.out.println("Main Method Ended");
	}

	public static void m1() 
	{
		System.out.println("m1 Method started");
        m2();
		System.out.println("m1 Method Ended");
	}

	public static void m2() 
	{
		int x = 100;
		System.out.println("M2 method body :"+x);
	}
}


Note : Here x is a local variable and scope of this x variable is within the same method (m2 method) only, Once m2 method execution is over x variable will be deleted from the Stack Frame.
------------------------------------------------------------------------
Limitation of Command Line Argument :
-------------------------------------
As we know by using Command Line Argument, we can pass some value 
at runtime, These values are stroed in String array variable and then only the exceution of the program will be started.

In Command line Argumenet we can't ask to enter the value from our end user as shown in the Program.

public class CommandLimitation 
{
	public static void main(String[] args) 
	{
		System.out.println("Enter your Name :");
		String name = args[0];
		System.out.println("Your Name is :"+name);
	}
}
------------------------------------------------------------------------
public class AcceptCharacter 
{
	public static void main(String[] args) 
	{
		System.out.println("Enter your Gender [M/F] :");
		 char gender = args[0].charAt(0);
		 System.out.println("Your Gender is :"+gender);
	}
}
-----------------------------------------------------------------------
How to read the value from end user :
--------------------------------------
In java, we can read the data from various ways, which are as follows 

1) DataInputStream class (java.io)
2) BufferedReader class (java.io)
3) Console (java.io)
4) System.in.read() (java.lang)
5) Scanner class

Scanner class :
---------------
It is a predefined class available in java.util package available from JDK 1.5v.

By using Scanner class we can read appropriate data from the end user.

System class static variables :
------------------------------
System class has provided 3 final and static variables :

System.out : Used to display normal message.

System.err : Used to display error message.

System.in : Used to take the input from the source.

How to create an Object for Scanner class :
-------------------------------------------
Scanner sc = new Scanner(System.in);

Methods of Scanner class :
---------------------------
Scanner class has provided various non static methods.

1) public String next() : Will read single word. 

2) public String nextLine() : Will read multiple words OR complete line.

3) public byte nextByte() : Will read byte data.

4) public short nextShort() : Will read short data.

5) public int nextInt() : Will read int data.

6) public long nextLong() : Will read long data.

7) public float nextFloat() : Will read float data.

8) public double nextDouble() : Will read double data.

9) public boolean nextBoolean() : Will read boolean data

10) public char next().charAt(0) : Will read a char data
------------------------------------------------------------------------
Read character from user using Scanner class :
----------------------------------------------
package com.ravi.scanner_ex;

import java.util.Scanner;

public class ReadCharacter 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter your Gender :");
		char gender = sc.next().charAt(0);
		System.out.println("Your Gender is :"+gender);
                sc.close();
	}

}
-----------------------------------------------------------------------
//Reading the name from the end user
package com.ravi.scanner_ex;

import java.util.Scanner;

public class ReadName {

	public static void main(String[] args)
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter your Name :");
		String name = sc.nextLine();
		System.out.println("Your Name is :"+name);
		sc.close();

	}

}
-----------------------------------------------------------------------
package com.ravi.scanner_ex;

import java.util.Scanner;

public class ReadStudentData {

	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);		
			
		System.out.print("Enter your roll number :");
		int roll = sc.nextInt();
		
		System.out.print("Enter your Name :");
		String name = sc.nextLine(); //Buffer Problem
		name = sc.nextLine();
		
		System.out.println("Your roll is :"+roll);
		System.out.println("Your Name is :"+name);
		sc.close();
		

	}

}
------------------------------------------------------------------------
05-09-2024
----------
Expression Conversion :
-----------------------
Whenever we are working with Arithmetic Operator (+,-,*,/,%) or unary minus operator, after expression exeution the result will be converted (Promoted) to int type, Actually to store the result minimum 32 bits format is required.

public class Test 
{
	public static void main(String [] args) 
	{	
		short s = 12;
		short t = 14;
		short u = s + t; //error
		System.out.println(u);
	}
	
}  

After Arithmetic operator expression the result will be promoted to int type so, to hold the result minimum 32 bit data is required.
-----------------------------------------------------------------------
Unary minus operator :
----------------------
public class Test 
{
	public static void main(String [] args) 
	{	
		int x = 15;
		System.out.println(-x);

	}
	
}  
-----------------------------------------------------------------------
public class Test 
{
	public static void main(String [] args) 
	{	
		byte b = 1;
		short c = -b; //error
		System.out.println(c);

	}
	
}  

In Arithmetic operator OR Unary minus operator, the result will be promated to int type (32 bits) so to hold the result int data type is reqd.
-----------------------------------------------------------------------
public class Test 
{
	public static void main(String [] args) 
	{	
		byte b = 1;
		b += 2;
		System.out.println(b);

	}
	
}  

In the above program we are using short hand operator so we will get the result in byte format also.
------------------------------------------------------------------------
public class Test 
{
	public static void main(String [] args) 
	{	
		  int z = 5;
		  if(++z > 5 || ++z > 6)   //Logical OR
		  {
			  z++;
		  }
		  System.out.println(z);  //7

         System.out.println("................");

		  z = 5;
		  if(++z > 5 | ++z > 6)   //Boolean OR
		  {
			  z++;
		  }
		  System.out.println(z); //8

	}
	
}  
-----------------------------------------------------------------------
Program on Boolean AND operator :
----------------------------------
public class Test 
{
	public static void main(String [] args) 
	{	
		int z = 5;
		if(++z > 6 & ++z> 6)
		{
			System.out.println("Inside If");
			z++;			
		}
		System.out.println(z);

	}
	
}  
-----------------------------------------------------------------------
Working with Bitwise AND(&), Bitwise OR(|) and Bitwise X-OR (^) :
------------------------------------------------------------------
public class Test 
{
	public static void main(String [] args) 
	{	
		System.out.println(false ^ true);
		

	}
	
}  

Note : If both the inputs are alternate of each other then we will get true otherwise we will get false.[Same input output will be false]
----------------------------------------------------------------------
public class Test 
{
	public static void main(String [] args) 
	{	
		System.out.println(5 & 6); //4
		System.out.println(5 | 6); //7
		System.out.println(5 ^ 6); //3
		

	}
	
}  
-----------------------------------------------------------------------
Bitwise Complement Operator (~) :
---------------------------------
It will not work with boolean type.

public class Test 
{
	public static void main(String [] args) 
	{	
		System.out.println(~true);//error	

	}
	
}  
-----------------------------------------------------------------------
public class Test 
{
	public static void main(String [] args) 
	{	
		System.out.println(~-5); // 4	
		System.out.println(~5);  //-6

	}
	
}  
-----------------------------------------------------------------------
Member access operator (.) :
-----------------------------
It is called Member access operator, by using this we can access the member of the class.
In the following program we have static method in the Welcome class, in order to call the static method we can use Welcome class and to access the static method of Welcome class we should use .(Dot) operator.

class Welcome
{
	public static void m1()  //static Method
	{
		System.out.println("M1 static Method");
	}
}
public class Test 
{
	public static void main(String [] args) 
	{	
		Welcome.m1();
	}
	
}  
------------------------------------------------------------------------
class Welcome
{
	public void m1() //non static Method
	{
		System.out.println("M1 non-static Method");
	}
}
public class Test 
{
	public static void main(String [] args) 
	{	
		Welcome w = new Welcome();
		w.m1();
	}
	
}  

Note : In order to call static method, Object is not required  but to call non static method, Object is required.
-----------------------------------------------------------------------
new Keyword :
-------------
It is also an operator.
It is used to create the object and initialize the non static member with default value.

class Welcome
{
	public void m1() //non static Method
	{
		System.out.println("M1 non-static Method");
	}
}
public class Test 
{
	public static void main(String [] args) 
	{	
		Welcome w = new Welcome();
		w.m1();
	}
	
}  
-----------------------------------------------------------------
Limitation of if else :
-----------------------
The major drawback with if condition is, it checks the condition again and again so It increases the burdon over CPU so we introduced switch-case statement to reduce the overhead of the CPU.

06-09-2024
-----------
Switch case statement in java :
-------------------------------
It is a selective statement so, we can select one statement among the available statements.

break is optional but if we use break then the control will move from out of the switch body.

We can write default so if any statement is not matching then default will be executed.

In switch case we can't pass long, float and double and boolean value.

[long we can pass in switch case from java 14v]

We can pass String from JDK 1.7v and we can also pass enum from JDK 1.5v. 
------------------------------------------------------------------------
import java.util.*;
public class SwitchDemo 
{
	public static void main(String[] args) 
	{	
		Scanner sc = new Scanner(System.in);
        System.out.print("Please Enter a Character :"); 
		
		char colour = sc.next().toLowerCase().charAt(0);
		

		switch(colour)      
		{
		case 'r' : System.out.println("Red") ; break;
		case 'g' : System.out.println("Green");break;
		case 'b' : System.out.println("Blue"); break;
		case 'w' : System.out.println("White"); break;
		default : System.out.println("No colour");
		}
		System.out.println("Completed") ;
	}
}
-----------------------------------------------------------------------
import java.util.*;
public class SwitchDemo1
{
public static void main(String args[]) 
  {	
		System.out.println("\t\t**Main Menu**\n");	
		System.out.println("\t\t**100 Police**\n");
		System.out.println("\t\t**101 Fire**\n");
		System.out.println("\t\t**102 Ambulance**\n");
		System.out.println("\t\t**139 Railway**\n");
		System.out.println("\t\t**181 Women's Helpline**\n");		

		System.out.print("Enter your choice :");
		Scanner sc = new Scanner(System.in);
		int choice = sc.nextInt();	
		
		switch(choice)
		{
		case 100:
		System.out.println("Police Services");
		break;
		case 101:
		System.out.println("Fire Services");
		break;
		case 102:
		System.out.println("Ambulance Services");
		break;
		case 139:
		System.out.println("Railway Enquiry");
		break;
		case 181:
		System.out.println("Women's Helpline ");
		break;
		default:
		System.out.println("Your choice is wrong");		
		} 
    }
}
----------------------------------------------------------------------
Passing String value in switch case :
--------------------------------------
import java.util.*;
public class SwitchDemo2 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter the name of the season :");
		String season = sc.next().toLowerCase();

		switch(season)  //String allowed from 1.7
		{
			case "summer" :
				 System.out.println("It is summer Season!!");
			 break;

			 case "rainy" :
				 System.out.println("It is Rainy Season!!");
			 break;
		}
	}
}
-----------------------------------------------------------------------
public class Test 
{	
	public static void main(String[] args) 
	{	
	   long l = 12L;

	   switch(l) //error
		{
           case 12L :
	   System.out.println("It is case 12");
		   break;
		}
	}

}
----------------------------------------------------------------------
public class Test 
{	
	public static void main(String[] args) 
	{	
	   float l = 12L;

	   switch(l)
		{
           case 12 :
			   System.out.println("It is case 12");
		   break;
		}
	}

}

Note : We can't pass long, float and double value.
-----------------------------------------------------------------------
public class Test 
{	
	public static void main(String[] args) 
	{	
	        int x = 12;
		int y = 12;

	        switch(x)
		{
                   case y :  //error
			   System.out.println("It is case 12");
		   break;
		}
	}

}

Note : In the label of switch we should take constant value.
------------------------------------------------------------------------
public class Test 
{	
	public static void main(String[] args) 
	{	
	        int x = 12;
		final int y = 12;

	   switch(x)
		{
                    case y :
			   System.out.println("It is case 12");
		   break;
		}
	}

}
-----------------------------------------------------------------------
public class Test 
{	
	public static void main(String[] args) 
	{	
	   byte b = 90;

	   switch(b)
		{
           case 128 :  //error
			   System.out.println("It is case 127");
		   break;
		}
	}

}

Note : Value 128 is out of the range of byte and same applicable for short data type
------------------------------------------------------------------------
Loops in java :
---------------
A loop is nothing but repeatation of statements based on the 
specified condition.

In java we have 4 types of loops :
----------------------------------
1) do-while loop
2) while loop
3) for loop
4) for each loop
-----------------------------------------------------------------------
//Program on do while loop :
----------------------------
public class DoWhile 
{
	public static void main(String[] args) 
	{
		do
		{
			int x = 1;  //Local Variable (block Level)
			System.out.println("x value is :"+x);
			x++;
		}
		while (x<=10); //error
	}
}

Note : x is a block level variable because It is declared inside do block so the scope of this x variable will be within the do block only.
------------------------------------------------------------------------
public class DoWhile 
{
	public static void main(String[] args) 
	{
		int x = 1;  //Local Variable 
		do
		{			
			System.out.println("x value is :"+x);
			x++;
		}
		while (x<=10);
	}
}
-----------------------------------------------------------------------
Program on while loop :
-----------------------
public class WhileDemo 
{
	public static void main(String[] args) 
	{
		int x = 1;

		while(x>=-10)
		{
			System.out.println(x);
			x--;
		}
	}
}
-----------------------------------------------------------------------
Program on for loop :
---------------------
public class ForLoop 
{
	public static void main(String[] args) 
	{
		for(int i=1; i<=10; i++)
		{
           System.out.println(i);
		}
	}
}
------------------------------------------------------------------------
For Each loop :
----------------
It is an enhanced for loop.
It is introduced from JDK 1.5v.
It is used to retrieve OR Iterate the values one by one from the Collection like array.


//Program on forEach loop to fetch the values from the array
public class ForEachLoop1
{
   public static void main(String [] args)
   {
       int arr[] = {10,20,30,40,50,60,70}; 

       for(int x : arr)
       {
          System.out.println(x);
       }
   }
}
-----------------------------------------------------------------------  
How to sort Array data :
--------------------------
In java.util pacakge, there is a predefined class called Arrays which has various static methods to sort the array in ascending or alphabetical order.

Example :
           Arrays.sort(int []arr);  //For sorting int array
	   Arrays.sort(Object []arr) //For sorting String array

-----------------------------------------------------------------------
 //Sorting the integer array
 package com.ravi.foreach_demo;

import java.util.Arrays;

public class ForEachLoop2 {

	public static void main(String[] args) 
	{
		int []arr = {90,67,34,12,9};
		
		Arrays.sort(arr);
		
		for(int x : arr)
		{
			System.out.println(x);
		}

	}

}
-----------------------------------------------------------------------
//Sorting the string array
package com.ravi.foreach_demo;

import java.util.Arrays;

public class ForEachLoop3 {

	public static void main(String[] args) 
	{
		String []fruits = {"Orange","Mango","Apple"};
		
		Arrays.sort(fruits);
		
		for(String fruit : fruits)
		{
			System.out.println(fruit);
		}

	}

}
------------------------------------------------------------------------
In java, Can we hold hetrogeneous types of data using array ?
-------------------------------------------------------------
Yes, by using Object array we can hold hetrogeneous type of data but we can't peform sorting operation using Arrays.sort(), It will generate 
java.lang.ClassCastException

package com.ravi.foreach_demo;

public class ForEachLoop4 {

	public static void main(String[] args) 
	{
		Object []values = {12,90.78,'A',"NIT",true};
		
		//Arrays.sort(values); //Invalid [java.lang.ClassCastException]
		
		for(Object value : values)
		{
			System.out.println(value);
		}

	}

}
-----------------------------------------------------------------------
09-09-2024
-----------
What is BLC and ELC class in java ?
------------------------------------
BLC :
------
BLC statnds for Business Logic class, In this class we are responsible to write the logic. This class will not contain main method.
The main purpose of this BLC class to reuse this class in various packages.

Example :
----------
//BLC
public class Calculate
{
  //Here We are responsible to write the logic
}

ELC :
-----
It stands for Executable Logic class, It will not contain any logic but the execution of the program will start from this ELC class because it contains main method.

Example :
---------
//ELC
public class Main
{
  public static void main(String [] args)
  {
  }
}

======================================================================
How to reuse a class in java ?
-------------------------------
The slogan of java is "WORA" write once run anywhere.

A public class created in one package can be reuse from different packages also by using import statement.

Each .java file can contain only one public class.The file name must match with the class name.

*In a single java file, we can write only one public class and multiple non-public classes but it is not a recommended approach because the non public class we can use within the same package only.

So the conclusion is, we should declare every java class in a separate file to enhance the reusability of the BLC classes.
[Note we have 10 classes -> 10 java files]

How many .class file will be created in the above approach :
------------------------------------------------------------
For a public class in a single file, Only 1 .class file will be created.

For a public class in a single file which contains n number of non public classes then compiler will generate n number of .class file.

Example :
----------
Test.java
----------
public class Test  
{
	
}

class A
{
}

class B
{
}

class C
{
}

Note : Here total 4 .class file will be generated.
----------------------------------------------------------------------
Working with static method and method return type :
---------------------------------------------------
static method :
---------------
If a method is declared with static keyword (like main method) then it is called static method.

In order to call a static method, Object is not required, We can call static method directly with the help of class name.
----------------------------------------------------------------------
How to call a static method available in the same class :
---------------------------------------------------------
If a static method is available in the same class (ELC class) then we can directly call the static method from another static method, Here class name is also not required as shown in the program.

//A static method can be directly call within the same class
package com.ravi.pack1;

public class Test1
{
	public static void main (String[] args)
	{	       
		square(5); 	    
	}

	public static void square(int x)
	{  
	  System.out.println("Square is :"+(x*x));
	}
}
-----------------------------------------------------------------------
Calling the static method (No return value) with the help of class name :
------------------------------------------------------------------------
2 files :
----------

GetSquare.java(BLC)
-------------------
package com.ravi.pack2;

//BLC
public class GetSquare 
{
   public static void getSquareOfNumber(int num)
   {
	   System.out.println("Square of "+num+" is :"+(num*num));
   }
}

Test2.java(ELC)
----------------
package com.ravi.pack2;

import java.util.Scanner;

//ELC
public class Test2 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter the side :");
		int side = sc.nextInt();
		GetSquare.getSquareOfNumber(side);
		sc.close();
	}
}

Here getSquareOfNumber() method return type is void so there is no communication between BLC and ELC class.
-------------------------------------------------------------------------
2 files :
----------
FindSquare.java
-----------------
//A static method returning integer value 
package com.ravi.pack3;

//BLC
public class FindSquare
{
	public static int getSquare(int x)
	{
		return (x*x);
	}
}



Test3.java
-----------
package com.ravi.pack3;

import java.util.Scanner;

//ELC
public class Test3
{
	public static void main (String[] arg)
	{	
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter the value of side :");
		int side = sc.nextInt();
		
	    int squareOfNum = FindSquare.getSquare(side);
	    System.out.println("Square of "+side+" is :"+squareOfNum);
	     
		sc.close();
	}
}

Here getSquare() method return type is int so there is communication is possible between BLC and ELC class.
------------------------------------------------------------------------
Test cases with data [Validation of outer world data]:
------------------------------------------------------
2 files :
----------
Calculate.java
--------------
/*Program to find out the square and cube of 
  the number by following criteria
 * 
a) If number is 0 or Negative it should return -1
b) If number is even It should return square of the number
c) If number is odd It should return cube of the number
*/

package com.ravi.pack4;

//BLC
public class Calculate 
{
  public static int getSquareAndCube(int num)
  {
	  if(num <=0)
	  {
		  return -1;
	  }
	  else if(num % 2==0)
	  {
		 return num*num; 
	  }
	  else
	  {
		 return num*num*num; 
	  }
  }
  
}

Test4.java
------------
package com.ravi.pack4;

import java.util.Scanner;

public class Test4 
{	
   public static void main(String[] args) 
   {
	 Scanner sc = new Scanner(System.in);	 
	 System.out.print("Enter a number :");
	 int num = sc.nextInt();
	 
	 int result = Calculate.getSquareAndCube(num);
	 System.out.println("Result is :"+result);
	 sc.close();
	 
   }	
	
}
--------------------------------------------------------------------------
2 files :
---------
Rectangle.java
--------------
package com.ravi.pack5;

//BLC
public class Rectangle 
{
  public static double getAreaOfRectangle(double length, double breadth)
  {	  
	  return (length * breadth);  
  }
  
}

Test5.java
-----------
package com.ravi.pack5;

import java.util.Scanner;

public class Test5 
{
	public static void main(String[] args)
	{
	  Scanner sc = new Scanner(System.in);
	  System.out.print("Enter the length of the Rect :");
	  double length = sc.nextDouble();
	  
	  System.out.print("Enter the breadth of the Rect :");
	  double breadth = sc.nextDouble();
	  
	  double areaOfRectangle = Rectangle.getAreaOfRectangle(length, breadth);
	 
	  System.out.println("Area of Rectangle is :"+areaOfRectangle);
	  sc.close();
	}
}
-----------------------------------------------------------------------
10-09-2024
----------
2 files :
---------
EvenOrOdd.java
---------------
package com.ravi.pack6;

//BLC
public class EvenOrOdd 
{
	public static boolean isEven(int num)
    {
        return (num % 2 == 0);
    }
}


Test6.java
----------
package com.ravi.pack6;

import java.util.Scanner;

//ELC
public class Test6 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter a Number :");
		int num = sc.nextInt();
		
	    boolean isEven = EvenOrOdd.isEven(num);
	    System.out.println(num+" is Even ?:"+isEven);
	    
	    System.out.print("Enter another Number :");
		num = sc.nextInt();
	    
	    isEven = EvenOrOdd.isEven(num);
	    System.out.println(num+" is Even ?:"+isEven);
	    sc.close();
	}

}
-----------------------------------------------------------------------
How to provide formatting for Decimal number :
----------------------------------------------
In java.text package, there is a predefined class called DecimalFormat through which we can provide formatting for Decimal number.

DecimalFormat df = new DecimalFormat("00.00");  //format [String pattern]
System.out.println(df.format(double d));

Note :- format is non static method of DecimalFormat class which accpts double as a parameter, and return type of this method is 
String.

public String format(double number)
----------------------------------------------------------------------
2 files :
----------
Circle.java
------------
//Area of Circle
//If the radius is 0 or Negative then return -1.

package com.ravi.pack7;
public class Circle 
{
  public static String getAreaOfCircle(double radius)
  {	
	  if(radius <= 0)
	  {
		  return ""+(-1);
	  }
	  else
	  {
		 double PI = 3.14; 
		 double areaOfCircle = PI * radius * radius;
		 return ""+areaOfCircle;
	  }
  }
}

Test7.java
-----------
package com.ravi.pack7;

import java.text.DecimalFormat;
import java.util.Scanner;

public class Test7 
{
	public static void main(String[] args) 
	{   
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter the radius :");
		double radius = sc.nextDouble();
		
		String circle = Circle.getAreaOfCircle(radius);
		//Converting String to double
		double area = Double.parseDouble(circle);
		
		
		DecimalFormat df = new DecimalFormat("00.00");
		System.out.println("Area of Circle is :"+df.format(area));
		sc.close();
	}
}
------------------------------------------------------------------------
How to work with String format :
--------------------------------
2 files :
----------
Student.java
-------------
package com.ravi.pack8;

//BLC
public class Student 
{
 public static String getStudentDetails(int roll, String name, double fees)
  {
	//[Student name is : Ravi, roll is : 101, fees is :1200.90] 
	 
	 return "[Student name is :"+name+", roll is :"+roll+", fees is :"+fees+"]";
	 
	 
  }   
}

Test8.java
-----------
package com.ravi.pack8;

public class Test8 
{
	public static void main(String[] args)
	{
	    String studentDetails = Student.getStudentDetails(111, "Smith", 12000);
	    System.out.println(studentDetails);
	}

}
------------------------------------------------------------------------
Note : We can't invoke a method from System.out.println() statement whose return type is void, It will generate CE.

Example :
----------
class A
{
  public static void m1()
  {}
}

class Main
{
  public static void main(String [] args)
   {
      System.out.println(A.m1()); //CE
   }
}
------------------------------------------------------------------------
2 files :
---------
Table.java
----------
package com.ravi.pack9;

//BLC 
public class Table 
{
  public static void printTable(int num) //[9 X 1 = 9]
  {
	for(int i=1; i<=10; i++)
	{
		System.out.println(num+" X "+i+" = "+(num*i));
	}
	System.out.println("==============================");
  }
}

Test9.java
-----------
package com.ravi.pack9;

//ELC 
public class Test9 
{
	public static void main(String[] args) 
	{		
		for(int i = 1; i<=9; i++)
		{
			Table.printTable(i);
		}
	}

}
========================================================================
Types of Variable in java :
---------------------------
Based on the data type we have only 2 types of variable in java :

  1) Primitive Variables 
  2) Reference Variables 

1) Primitive Variables :
------------------------
If a variable is declared with primitive data type like byt, short, int, long and so on then it is called Primitive Variables.

Example :
          int x = 100;
	  boolean y = true;

2) Reference Variable :
-----------------------
If a variable is declared with class name, interface name, enum , record and so on then it is called reference variable.

Example :
          Student s; //s is reference variable
	  Scanner sc = new Scanner(System.in); //sc is reference variable
          Integer y = null; //y is reference variable

Note : With primitive variable we can't call a method as well as we can't  assign null literal.

       int x = null;  //Invalid

       int y = 45;
       y.m1(); //Invalid


Based on declaration position Variables are divided into 4 types :

  a) Class Variables OR Static Field
  b) Instance Variables OR Non Static Field
  c) Local /Stack/temporary/Automatic Variable
  d) Parameter Variables 

Program on Primitive Variables :
---------------------------------
package com.ravi.variables;

class Test
{
	int x = 100; //Primitive + Instance Variable
	static int y = 200; // //Primitive + Class Variable
	
	public  void acceptData(int a) //Primitive + Parameter Variable
	{
		int b = 400; //Primitive + Local Variable
		System.out.println("Local Variable :"+b); //Stack Memory
		System.out.println("Parameter Variable :"+a);//Stack Memory
		System.out.println("Instance Variable :"+this.x); //HEAP MEMORY
		System.out.println("Class Variable :"+Test.y); //CLASS AREA {Method Area}
	}
}


public class PrimitiveVariables 
{
  public static void main(String[] args) 
  {
	  Test t1 = new Test();
	  t1.acceptData(300);
  }
}

-------------------------------------------------------------------------
Program on Reference Variables :
---------------------------------
package com.ravi.variables;

import java.util.Scanner;

class Student
{
	
}

public class ReferenceVariable
{
	Student s1 = new Student(); //Reference + Non Static Variable
	static Scanner sc = new Scanner(System.in); //Reference + Static Variable
	
	public static void main(String[] args) 
	{
		Student stud = new Student(); //Reference + Local Variable

		acceptStudentObject(stud);		
	}	
	public static void acceptStudentObject(Student st) //Reference + Parameter
	{		
	}

}
-------------------------------------------------------------------------
11-09-2024
----------
Object Oriented Programming (OOPs) 
----------------------------------
What is an Object?
------------------
An object is a physical entity which exist in the real world.
Example :- Pen, Car, Laptop, Mouse, Fan and so on

An Object is having 3 characteristics :

   a) Identification of the Object (Name of the Object)
   b) State of the Object (Data OR Properties OR Variable of Object)
   c) Behavior of the Object (Functionality of the Object)

OOP is a technique through which we can design or develop the programs using class and object.

Writing programs on real life objects is known as Object Oriented Programming.

Here in OOP we concentrate on objects rather than function/method.

Advantages of OOP :
--------------------
1) Modularity  (Dividing the bigger task into smaller task)
2) Reusability (We can reuse the component so many times)
3) Flexibility (Easy to maintain [By using interface])

Features of OOP :
-----------------
1) Class
2) Object
3) Abstraction
4) Encapsulation
5) Inheritance
6) Polymorphism

======================================================================
What is a class?
-----------------
A class is model/blueprint/template/prototype for creating the object.

A class is a logical entity which does not take any memory.

A class is a user-defined data type which contains data member and member function.

public class Employee
{
    Employee Data (Properties) 
         +
    Employee behavior (Function/Method)
}

A CLASS IS A COMPONENT WHICH IS USED TO DEFINE OBJECT PROPERTIES AND OBJECT BEHAVIOR.
--------------------------------------------------------------

WAP in OOP to provide initial value to object properties :

2 files :
---------
Student.java
-------------
package com.ravi.oop;

//BLC
public class Student 
{
   String studentName;  //Instance Variable
   double studentHeight; //Instance Variable
   int studentRollNumber; //Instance Variable
   
   public void talk()
   {
	   System.out.println("My name is :"+studentName);
	   System.out.println("My rollnumber is :"+studentRollNumber);
	   System.out.println("My Height is :"+studentHeight);
	   
   }
   
   public void writeExam()
   {
	  System.out.println("Every saturday "+studentName+" is writing the Exam paper"); 
   }
   
   
}

StudentDemo.java
-----------------
package com.ravi.oop;

//ELC
public class StudentDemo 
{
	public static void main(String[] args) 
	{
		Student raj = new Student();
		//Initialize the properties (Variables)
		raj.studentRollNumber = 111;
		raj.studentName = "Raj Gourav";
		raj.studentHeight = 5.8;
		//Calling the behavior
		raj.talk();
		raj.writeExam();
		
		
		Student priya = new Student();
		//Initializing the properties
		priya.studentName = "Priya";
		priya.studentRollNumber = 222;
		priya.studentHeight = 5.6;
		//calling the behavior
		priya.talk();
		priya.writeExam();
		
		

	}

}
=======================================================================
Steps for creating Object Orineted Programming 

Step 1 :-  Create the Object based on the BLC class inside ELC 
           class.[main method]

Step 2 :- Define all the object properties and behavior inside
          the BLC class based on your imagination.

Step 3 :- Initialize all the object properties with user friendly value by using reference variable.

step 4 :- call the behavior (calling the methods)
-----------------------------------------------------------------------
12-09-2024
----------
How to initialize the object properties by using Object reference through Scanner class :

2 files :
----------
Customer.java
-------------
package com.ravi.oop;

public class Customer 
{
   int customerId;  //instance Variable
   String customerName; //instance Variable
   double customerBill; //instance Variable
   
   public void buyProduct()
   {
	  System.out.println(customerName+"  has purchased one Mobile"); 
   }
   
   public void billPayment()
   {
	   System.out.println(customerName+" has paid "+customerBill+" amount");
   }
   
}

CustomerDemo.java
------------------
package com.ravi.oop;

import java.util.Scanner;

public class CustomerDemo 
{
	public static void main(String[] args) 
	{
		Customer scott = new Customer();
		//Initializing the Object Properties
		
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter Customer Id :");
		int id = sc.nextInt();
		scott.customerId = id;
		
		System.out.print("Enter Customer Name :");
		String name = sc.nextLine();
		name = sc.nextLine();
		scott.customerName = name;
		
		System.out.print("Enter Customer Bill :");
		double bill = sc.nextDouble();
		scott.customerBill = bill;
		
		scott.buyProduct();  scott.billPayment();
		sc.close();

	}

}
-----------------------------------------------------------------------
Initializing the Object properties through Methods :
-----------------------------------------------------
We can also initialize the object properties through methods as shown in the program.

2 files :
---------
Employee.java
--------------
package com.ravi.oop;

public class Employee 
{
  int employeeId;
  String employeeName;
  
   public void setEmployeeData()
   {
	   employeeId = 111;
	   employeeName = "Smith";
   }
   
   public void getEmployeeData()
   {
	   System.out.println("Employee Id is :"+employeeId);
	   System.out.println("Employee Name is :"+employeeName);
	   
   }
  
}

EmployeeDemo.java
------------------
package com.ravi.oop;

public class EmployeeDemo {

	public static void main(String[] args) 
	{
		Employee smith = new Employee();
        smith.setEmployeeData();
        smith.getEmployeeData();
	}

}

Note : Upto here, we have learned the following two types to initialize the Object properties 
   a) By using Object Reference
   b) By using Methods
-----------------------------------------------------------------------
What is an instance variable ?
-------------------------------
If a non static variable is declared inside a class and outside of the 
method then it is called instance variable.[class level variable]

class Test
{
   int x = 100;  //Instance Variable
}

An instance variable will automatically initalized with default value (even the variable final) at the time of Object creation.

Without an object the life of the instance variable will not be started.

public class Test 
{
   int x = 100; 

   public static void main(String [] args)
	{
	    System.out.println(x); //error [Object is not created]
	}
	
}  

In java, There is a special memory for object where object and its properties (Instance Variable) are available called HEAP Memory.

The scope of instance variable is within the class as well as it depends upon the access modifier.

=======================================================================
What is a constructor [Introduction Only]
------------------------------------------
If the name of the class and name of the method both are exactly same and It does not contain any type of return type (Without return type)
then it is called constructor.

Example :
---------
class Student
{
  public Student() //Constructor
  {
  }
}
-----------------------------------------------------------------------
Default constructor added by the compiler :
-------------------------------------------
In java, whenever we write a class and if we don't write any kind 
of constructor in the class then automatically java compiler will add one default constructor to the class.

Test.java
----------
public class Test
{

}

javac Test.java (Compilation)

Test.class
-----------
public class Test
{
   public Test() //default constructor added by the compiler
   {
   }
}

Note :- default constructor does not take any argument.

Every java class must have at-least one constructor either explicitly
written by user OR implicitly added by compiler.

The access modifier of default constructor depnds upon class access
modifier that means if my class is public then default constrauctor added by compiler will be public, if class is not public then default constructor added by compiler will also not public.
----------------------------------------------------------------------
Why compiler is adding default constructor to our class :
---------------------------------------------------------
We have 2 reasons that why compiler is adding default constructor :

1) Without default constructor, Object creation is not possible in java by using new keyword, if the class does not contain user-defined constructor.

2) As we know only class level variables are having default values so,  default constructor will initialize all the instance variables with default values with the help of new keyword.
  
 Data type - Default value
   byte  - 0
   short - 0
   int   - 0
   long  - 0
   float - 0.0
   double - 0.0
   char - (space) '\u0000'  
   boolean - false
   String - null
   Object - null (For any class i.e reference variable the default value is null)

Student.java
--------------
package com.ravi.oop;

public class Student 
{
	int id;
	String name;
	
	public void displayStudentData()
	{
		System.out.println("Id is :"+id);
		System.out.println("Name is :"+name);
	}
	
	
	public static void main(String[] args) 
	{
		Student raj = new Student();

	}

}

Note : Even we are not initializing our instance variable but it will 
       be initialized by default constructor using new keyword [super () ]
-------------------------------------------------------------------
How to provide our own user-defined values for the instance variable :
----------
2 files :
----------
Manager.java
------------
package com.ravi.oop;

import java.util.Scanner;

public class Manager 
{
   int managerId; //Instance Variable
   String managerName; //Instance Variable
   
   public void setManagerData()
   {
	   Scanner sc = new Scanner(System.in);
	   System.out.print("Enter Manager Id :");
	   managerId = sc.nextInt();  //id = 111
	   System.out.print("Enter Manager Name :");
	   String name = sc.nextLine(); //\n
	   managerName = sc.nextLine(); //smith
   }
   
   public void getManagerData()
   {
	   System.out.println("Manager Id is :"+managerId);
	   System.out.println("Manager Name is :"+managerName);
   }
   
   
   
   
}

ManagerDemo.java
-----------------
package com.ravi.oop;

public class ManagerDemo {

	public static void main(String[] args)
	{
		Manager smith = new Manager();
		smith.setManagerData();
        smith.getManagerData();
	}

}
-------------------------------------------------------------------
How to initialize the Object properties through parameter variable :
-------------------------------------------------------------------
We can initialize the instance variable by using method parameter as 
shown in the program

2 files :
---------
Player.java
------------
package com.ravi.oop;

public class Player 
{
   int playerId;  //Instance Variable
   String playerName; //Instance Variable
   
   public void setPlayerData(int pid, String pname)
   {
	   playerId = pid;
	   playerName = pname;
   }
   
   public void getPlayerData()
   {
	   System.out.println("Player Id is :"+playerId);
	   System.out.println("Player Name is :"+playerName);
   }
   
   
}

PlayerDemo.java
---------------
package com.ravi.oop;

public class PlayerDemo {

	public static void main(String[] args) 
	{
		Player rohit = new Player();
		rohit.setPlayerData(45, "Rohit Sharma");
		rohit.getPlayerData();
		
		System.out.println("..................");
		
		Player virat = new Player();
		virat.setPlayerData(18, "Virat Kohli");
		virat.getPlayerData();

	}

}
--------------------------------------------------------------------
How to initialize the instance variable through parameter variable as per requirement.

2 files :
----------
Employee.java
-------------
package com.ravi.oop;

public class Employee 
{
  int employeeId;
  String employeeName;
  double employeeSalary;
  char employeeGrade;
  
  public void setEmployeeData(int id, String name, double salary)
  {
	employeeId = id;
	employeeName = name;
	employeeSalary = salary;
  }
  
  public void getEmployeeData()
  {
	  System.out.println("Employee Id is :"+employeeId);
	  System.out.println("Employee Name is :"+employeeName);
	  System.out.println("Employee Salary is :"+employeeSalary);
	  System.out.println("Employee Grade is :"+employeeGrade);
  }
  
  public void calculateEmployeeGrade()
  {
	  if(employeeSalary >= 90000)
	  {
		  employeeGrade = 'A';
	  }
	  else if(employeeSalary >= 75000)
	  {
		  employeeGrade = 'B';
	  }
	  else if(employeeSalary >= 50000)
	  {
		  employeeGrade = 'C';
	  }
	  else
	  {
		  employeeGrade = 'D';
	  }
  }
  
  
  
  
}

EmployeeDemo.java
-------------------
package com.ravi.oop;

public class EmployeeDemo {

	public static void main(String[] args) 
	{
		Employee john = new Employee();
		john.setEmployeeData(111, "John", 95000);
		john.calculateEmployeeGrade();
		john.getEmployeeData();  

	}

}
--------------------------------------------------------------------
Variable Shadow :
-----------------
Variable shadowing in Java occurs when a variable declared within a certain scope (like a method or a block or Constructor) has the same name as a variable declared in an outer scope (class Level). 

In variable Shadow, the variable in the inner scope hides the variables in Outer scope so known as variable shadowing.

This means that within the inner scope (Method, block Or Constructor), when we refer to the variable directly by name, We are actually referring to the inner variable, not the outer variable.

2 files :
---------
Student.java
-------------
package com.ravi.oop;

public class Student 
{
   int studentId = 111;  //Instance Variable
   String studentName = "Smith";  //Instance Variable
   
   public void accept()
   {
	  int studentId = 222;           //Local Variable
	  String studentName = "John";   //Local Variable
	  
	  System.out.println(studentId);
	  System.out.println(studentName);
   }  
   
}


VariableShadow.java
--------------------
package com.ravi.oop;

public class VariableShadow {

	public static void main(String[] args) 
	{
		Student s1 = new Student();
		s1.accept();

	}

}
--------------------------------------------------------------------
this keyword in java :
----------------------
Whenever instance variable name and parameter variable name both are same then at the time of instance variable initialization our runtime environment will provide more priority to parameter variable/local variable, parameter variables are hiding the instance variables (Due to variable shadow)

To avoid the above said problen, Java software people introduced "this" keyword.

this keyword always refers to the current object and instance variables are the part of the object so by using this keyword we can represent instance variable.

We cannot use this (non static member) keyword from static area (Static context).

-------------------------------------------------------------------
2 files :
----------
Customer.java
--------------
package com.ravi.oop;

public class Customer 
{
   int customerId;
   String customerName;
   
   public void setCustomerData(int customerId, String customerName)
   {	   
	   this.customerId = customerId;
	   this.customerName = customerName;
	   
   }
   
   public void getCustomerData()
   {
	   System.out.println("Customer Id is :"+this.customerId);
	   System.out.println("Customer Name is :"+this.customerName);
   }
   
   
}

ThisKeywordDemo.java
---------------------
package com.ravi.oop;

public class ThisKeywordDemo 
{
	public static void main(String[] args)
	{
		Customer raj = new Customer();
		raj.setCustomerData(111, "Raj");
		raj.getCustomerData();
	}

}
===================================================================
How to print object properties by using toString() method :
-----------------------------------------------------------
If we want to print our object properties (Instance Variables) then we should generate(override) toString() method in our class from Object class.

Now with the help of toString() method we need not to write any display kind of method to print the object properties i.e instance variable.

In order to generate the toString() method we need to follow the steps
Right click on the program -> source -> generate toString()

In order to call this toString() method, we need to print the corresponding object reference by using System.out.println() statement.

Manager m = new Manager();
System.out.println(m); //Calling toString() method of Manager class

Employee e = new Employee();
System.out.println(e); //Calling toString() method of Employee class.


2 files :
-----------
Trainer.java
------------

package com.ravi.oop;

public class Trainer {
	int trainerId;
	String trainerName;
	String trainerSubject;

	public void setTrainerData(int trainerId, String trainerName, String trainerSubject) {
		this.trainerId = trainerId;
		this.trainerName = trainerName;
		this.trainerSubject = trainerSubject;

	}

	@Override
	public String toString() 
	{
		return "Trainer [trainerId=" + trainerId + ", trainerName=" + trainerName + ", trainerSubject=" + trainerSubject
				+ "]";
	}

	

}

ToStringDemo.java
------------------
package com.ravi.oop;

public class ToStringDemo 
{
	public static void main(String[] args) 
	{
		Trainer scott = new Trainer();
		scott.setTrainerData(111, "Scott", "Java");
		
		System.out.println(scott); //toString()

	}

}
==================================================================
16-09-2024
-----------
Role of instance variable while creating the Object :
-----------------------------------------------------
Whenever we create an objet in java, a separate copy of all the instance variables will be created with each and every object.

Program :
---------
package com.ravi.oop;

public class Test 
{
    int x = 10;        
	public static void main(String[] args) 
	{
		Test t1 = new Test();
		Test t2 = new Test();
		
		++t1.x;   --t2.x;
		
		System.out.println(t1.x); //11
		System.out.println(t2.x); //9

	}
}
------------------------------------------------------------------
What is a static field ?
------------------------
It is a class level variable.

If a variable is declared with static modifier inside a class then it is called class variable OR static field.

A static field variable will be automatically initialized with default values and memory will be allocated (even the variable is final) AT THE TIME OF LOADING THE CLASS INTO JVM MEMORY.

In order to access the static member, we need not to create an object, here class name is required.

Role of static field in Object creation :
-----------------------------------------
Whenever we create an object then a single copy of static filed is created and the same single copy is sharable by all the objects so, if we make any changes through one object, it will reflect to all the objects as shown in the program.

package com.ravi.oop;

public class Demo 
{
    static int x = 10;
    
	public static void main(String[] args) 
	{
		Demo d1 = new Demo();
		Demo d2 = new Demo();
		
		++d1.x;  ++d2.x;
		
		System.out.println(d1.x); //12
		System.out.println(d2.x); //12		
	}

}


So, The conclusion is :

   Instance Variable = Multiple Copies with each and every object
   Static Field = Single Copy is sharable by all the Objects.
-----------------------------------------------------------------
When we should decalre a variable as static variable and when we should declare as variable as a non static variable ?

Instance Variable :
-------------------
If the value of the variable is different with respect to objects then we should declare a variable as a instance variable.

Static Variable :
------------------
If the value of the variable is common to all the objects then we should declare a variable as a static variable.

Program :
---------
2 files :
---------
package com.nit;

public class Student 
{
    int rollNumber;
    String studentName;
    String studentAddress;
    static String collegeName = "NIT";
    static String courseName = "Java";
    
    public void setStudentData(int rollNumber, String studentName, String studentAddress)
    {
    	this.rollNumber = rollNumber;
    	this.studentName = studentName;
    	this.studentAddress = studentAddress;
    }

	@Override
	public String toString() {
		return "Student [rollNumber=" + rollNumber + ", studentName=" + studentName + ", studentAddress="
				+ studentAddress + ", college name=" +Student.collegeName+", course name = "+ Student.courseName+" ]";
				
				
	}  
    
}

VariableDeclaration.java
-------------------------
package com.nit;

public class VariableDeclaration {

	public static void main(String[] args) 
	{
		Student raj = new Student();
		raj.setStudentData(111, "Raj", "Ameerpet");
		System.out.println(raj);
		
		Student priya = new Student();
		priya.setStudentData(222, "Priya", "S.R Nagar");
		System.out.println(priya);

	}

}
=================================================================
18-09-2024
----------
What is Data Hiding ?
----------------------
Data hiding is nothing but declaring our data members with private access modifier so our data will not be accessible from outer world that means no one can access our data directly from  outside of the class.

*We should provide the accessibility of our data through methods so we can perform VALIDATION ON DATA which are coming from outer world.

2 files :
---------
Customer.java
-------------
package com.ravi.data_hiding;

public class Customer 
{
  private double balance = 10000; //Data Hiding
  
  public void deposit(double amount)
  {
	  //Validation
	  if(amount <=0)
	  {
		  System.err.println("Amount can't be deposited");
	  }
	  else
	  {
		  this.balance = this.balance + amount;
		  System.out.println("Amount After deposit is :"+this.balance);
	  }
  }
  
  public void withdraw(double amount)
  {
	this.balance = this.balance - amount;
	System.out.println("Balance After Withdraw is :"+this.balance);
  }
  
  
}


BankApplication.java
---------------------
package com.ravi.data_hiding;

public class BankApplication {

	public static void main(String[] args)
	{
		Customer scott = new Customer();
		scott.deposit(1000);
		scott.withdraw(5000);

	}

}
-----------------------------------------------------------------
Constructor :
-------------
What is Constructor ?
---------------------
What is the advantage of writing constructor in our class ?
------------------------------------------------------------
If we don't write a constructor in our program then variable initialization and variable re-initialization both are done in two different lines.

If we write constructor in our program then variable initialization and variable re-initialization both are done in the same line i.e at the time of Object creation. [08-OCT]

With Constructor approach, we need not to depend on method to re-initialize our instance variable with user value.
----------------------------------------------------------------
Defination of Constructor :
---------------------------
It is used to construct the Object that's why it is known as Constructor.

If the name of the class and name of the method both are exactly same and it does not contain any return type then it is called Constructor.

Example :
----------
public class Student
{
   public Student() //Constructor
   {
   } 

   public void Student() //Method
   {
   } 
}

Every java class must contain at-least one constructor, either explicitly written by developer OR implicitly added by compiler.

*The main purpose of constructor to initialize the Object properties (Instance Variable)

A constructor never contain any return type but internally it returns current class object (this keyword)

package com.ravi.constructor;

public class Employee 
{
	public void getSalary()
	{
		System.out.println("Employee is getting the Salary");
	}

	public static void main(String[] args) 
	{
		
		new Employee().getSalary();
	}
}

A constructor is automatically called and executed at the time of Object creation (No need to call explicitly like method)

Every time we create an object by using new keyword, at-least one constructor must be invoked.
================================================================
Program that describes difference between Method and Constructor

2 files :
---------
Student.java
-------------
package com.ravi.data_hiding;

public class Student 
{
  public Student()
  {
	  System.out.println("I am Constructor");
  }
  
  public void Student()
  {
	  System.out.println("I am Method");
  }
}

StudentDemo.java
-----------------
package com.ravi.data_hiding;

public class StudentDemo {

	public static void main(String[] args) 
	{
		Student s = new Student(); //Constructor will be invoked
		s.Student(); //Method Will be invoked
	}
}
----------------------------------------------------------------
Types of Constructor :
----------------------
In java we have 3 types of Constructors :

1) Default Constructor (Compiler added Constructor)

2) No Argument OR Parameterless OR Non Parameterized OR Zero Argument constructor (User defined without parameter constructor)

3) Parameterized Constructor
-----------------------------------------------------------------
Default No Argument Constructor :
---------------------------------
Whenever we write a class and if we don't write any type of constructor then automatically one default constructor is added by the compiler.

The access modifier of default constaructor would be same as class access modifier.

It does not accept any parameter.

Example.java
--------------
public class Example 
{

}

javac Example.java

Example.class
------------
public class Example
{
   public Example() //default constructor
   {
   }
}
--------------------------------------------------------------------
No Argument Constructor :
--------------------------
If a user defines a constructor inside a class without argument then it is called no argument constructor.

No argument constructor and default constructor, both look like same the only difference is, default constructor means added by compiler and no argument constructor means written by user.

public class Student
{
  private int rollNumber;
  private String studentName;
  
  public Student() //No Argument Constructor
  {
     rollNumber = 111;
     studentName = "Raj";
  }
  
}  
  
No argument constructor is not recommended to initialize our object properties because due to no argument constructor all the object properties will be initialized with SAME VALUE as shown in the program.

2 files :
----------
Person.java
------------
package com.ravi.constructor_demo;

public class Person {
	private int personId;
	private String personName;

	public Person() // No Argument Constructor
	{
		this.personId = 111;
		this.personName = "Scott";
	}

	@Override
	public String toString() 
	{
		return "Person [personId=" + personId + ", personName=" + personName + "]";
	}

}


package com.ravi.constructor_demo;

public class NoArgumentConstructor {

	public static void main(String[] args) 
	{
		Person scott = new Person();
		System.out.println(scott);
		
		Person smith = new Person();
		System.out.println(smith);

	}

}

Note : In the above program we have 2 objects scott and smith but both the objects initialized with scott data.

To avoid this we introduced Parameterized constructor.
--------------------------------------------------------------
Parameterized Constructor :
---------------------------
If we pass one or more argument to the constructor then it is called parameterized constructor.

By using parameterized constructor all the objects will be initialized with different values.

Example :
----------
public class Employee
{
   int id;
   String name;
   
   public Employee(int id, String name)
   {
      this.id = id;
      this.name = name;
   }
 }
-------------------------------------------------------------------
Initializing the Object properties through Parameterized Constructor
--------------------------------------------------------------------
2 files :
---------
Dog.java
---------
package com.ravi.constructor_demo;

public class Dog
{
	private String dogName;
	private double dogHeight;
	private String dogColor;

	public Dog(String dogName, double dogHeight, String dogColor) {
		super();
		this.dogName = dogName;
		this.dogHeight = dogHeight;
		this.dogColor = dogColor;
	}

	@Override
	public String toString() 
	{
		return "Dog [dogName=" + dogName + ", dogHeight=" + dogHeight + ", dogColor=" + dogColor + "]";
	}
}

ParameterizedConstructor.java
------------------------------
package com.ravi.constructor_demo;

public class ParameterizedConstructor {

	public static void main(String[] args) 
	{
		Dog tommy = new Dog("Tommy", 3.4,"Black");
		System.out.println(tommy);
		
		Dog tiger = new Dog("Tiger", 4.4,"Dark Grey");
		System.out.println(tiger);

	}
}
--------------------------------------------------------------------
How to write setter and getter methods :
-----------------------------------------
public class Customer
{
   private double customerBill; 
   
   //Initialize the customerBill using parameterized constructor
   public Customer(double customerBill)
   {
      this.customerBill = customerBill;
   }

   //Writing setter to modify the existing customerBill
     public void setCustomerBill(double customerBill)
     {
      this.customerBill = customerBill;
     }
   
   //Writing getter to retrieve the private data value outside of BLC class
   public double getCustomerBill()
   {
      return this.customerBill;
   }
}
--------------------------------------------------------------------
FINAL CONCLUSION :
-------------------
Parameterized Constructor : To initialize the Object properties with user values.

Setter : To modify the existing object data.[Only one data at a time] OR Writing Operation

Getter : To read/retrieve private data value outside of BLC class. [Reading Operation]
--------------------------------------------------------------------
*** What is Encapsulation 
--------------------------
[Accessing our private data with public methods like setter and getter]
--------------------------------
Binding the private data with its associated method in a single unit is called Encapsulation.

Encapsulation ensures that our private data (Object Properties) must be accessible via public methods like setter and getter.

It provides security because our data is private (Data Hiding) and it is only accessible via public methods WITH PROPER DATA VALIDATION.

In java, class is the example of encapsulation.


How to achieve encapsulation in a class :
------------------------------------------
In order to achieve encapsulation we should follow the following two 
techniques :

1) Declare all the data members with private access modifiers (Data Hiding OR Data Security)

2) Write public methods to perform read(getter) and write(setter) operation on these private data like setter and getter.

Note : If we decalre all our data with private access modifier then it is called TIGHTLY ENCAPSULATED CLASS. On the other hand if we declare our data other then private access modifier then it is called Loosely Encapsulated class.

Program on encapsulation :
--------------------------
2 files :
----------
Employee.java
--------------
package com.ravi.constructor_demo;

public class Employee 
{
	private double employeeSalary;

	public Employee(double employeeSalary) 
	{
		super();
		this.employeeSalary = employeeSalary;
	}

	public double getEmployeeSalary() //getter
	{
		return employeeSalary;
	}

	public void setEmployeeSalary(double employeeSalary) //setter
	{
		if(employeeSalary <=0)
		{
			System.err.println("Invalid Data");
		}
		else
		{
		this.employeeSalary = employeeSalary;
		}
	}

	@Override
	public String toString() 
	{
		return "Employee [employeeSalary=" + employeeSalary + "]";
	}
	
}

SetterAndGetter.java
----------------------
package com.ravi.constructor_demo;

public class SetterAndGetter {

	public static void main(String[] args) 
	{
		Employee scott = new Employee(55000);
		scott.setEmployeeSalary(scott.getEmployeeSalary()+10000);
		System.out.println(scott);
		
		//Verify whether scott is developer/designer/tester
		
		double empSalary = scott.getEmployeeSalary();
		
		if(empSalary >=60000)
		{
			System.out.println("Scott is Developer");
		}
		else if(empSalary >=40000)
		{
			System.out.println("Scott is Designer");
		}
		else
		{
			System.out.println("Scott is Tester");
		}

	}

}
--------------------------------------------------------------------
20-09-2024
-----------
Method return type as a class :
-------------------------------
While declaring a method in java, return type is compulsory.
As a method return type we have following options

1) void as a retutn type of the Method

2) Any primitive data type as a return type of the method.

3) Any class name/interface / enum / record we can take as a return type of the method.

Example 1 :
-----------
package com.nit;

public class Demo 
{
  public Demo m1() //Factory Method
  {
	 return this; //Valid
	     OR
	 return null;  //Valid
	     OR
	  return new Demo();  //Valid 
  }
}

Example 2 :
-----------
package com.nit;

public class Demo 
{
  int x;
  
  public Demo(int x)
  {
	  this.x = x;
  }
	
  public Demo m1() 
  {
	 return new Demo(8);
	
  }
}

Note : Here the return value depends upon the available constructor in the class.
====================================================================
What is a Factory Method :
--------------------------
If a method return type is class name menas it is returning the Object of the class then it is called Factory Method.
--------------------------------------------------------------------
2 files :
---------
Product.java
-------------
package com.ravi.factory_method;

public class Product 
{
	private int productId;
	private String productName;
	private double productPrice;

	public Product(int productId, String productName, double productPrice) 
	{
		super();
		this.productId = productId;
		this.productName = productName;
		this.productPrice = productPrice;
	}

	@Override
	public String toString() {
		return "Product [productId=" + productId + ", productName=" + productName + ", productPrice=" + productPrice
				+ "]";
	}
	
	public static Product getProductObject()
	{
		return new Product(111,"Laptop",92000);
	}

}

ProductDemo.java
-----------------
package com.ravi.factory_method;

public class ProductDemo {

	public static void main(String[] args)
	{
		Product obj =  Product.getProductObject();
		System.out.println(obj);

	}

}

In the avove program getProductObject() is providing only one product object so it is not recommended because the main purpose of any method to provide re-usability as shown in the program below.

2 files :
----------
Employee.java
--------------
package com.ravi.factory_method;

import java.util.Scanner;

public class Employee 
{
	private int employeeId;
	private String employeeName;
	private double employeeSalary;

	public Employee(int employeeId, String employeeName, double employeeSalary) {
		super();
		this.employeeId = employeeId;
		this.employeeName = employeeName;
		this.employeeSalary = employeeSalary;
	}

	@Override
	public String toString() {
		return "Employee [employeeId=" + employeeId + ", employeeName=" + employeeName + ", employeeSalary="
				+ employeeSalary + "]";
	}
	
	public static Employee getEmployeeObject()
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter Employee Id :");
		int id = sc.nextInt();
		
		System.out.print("Enter Employee Name :");
		String name = sc.nextLine();
		name = sc.nextLine();
		
		System.out.print("Enter Employee Salary :");
		double sal = sc.nextDouble();
		
		return new Employee(id, name, sal);
	}
}

EmployeeDemo.java
------------------
package com.ravi.factory_method;

import java.util.Scanner;

public class EmployeeDemo {

	public static void main(String[] args) 
	{
		 Scanner sc = new Scanner(System.in);
		 System.out.print("How many Employee Object you want ?");
		 int noOfObj = sc.nextInt();
		 
		 for(int i=1; i<=noOfObj; i++)
		 {
			 Employee employee = Employee.getEmployeeObject();
			 System.out.println(employee);
		 }
		 
		 sc.close();
		 
	}

}
--------------------------------------------------------------------
What is Shallow and Deep copy in java :
----------------------------------------
Shallow Copy :
--------------
In Shallow copy, Only one Object will be created but the same object will be refered by multiple reference variables.

If we modify the object properties by any of the reference variable then original object will be modified as shown in the program.

package com.ravi.object_duplication;

public class Laptop 
{
    private double laptopPrice;
    private String laptopBrand;
    
    
	public Laptop(double laptopPrice, String laptopBrand) 
	{
		super();
		this.laptopPrice = laptopPrice;
		this.laptopBrand = laptopBrand;
	}
	
	

	@Override
	public String toString() {
		return "Laptop [laptopPrice=" + laptopPrice + ", laptopBrand=" + laptopBrand + "]";
	}



	public static void main(String[] args) 
	{
		Laptop laptop1 = new Laptop(86000, "HP");		
		Laptop laptop2 = laptop1;  [Diagram 20-SEP]
		
		System.out.println("Before Change");		
		System.out.println(laptop1);
		System.out.println(laptop2);
		
		laptop2.laptopBrand = "DELL";
		laptop2.laptopPrice = 95000;
		
		System.out.println("After Change");		
		System.out.println(laptop1);
		System.out.println(laptop2);
		
		

	}

}
--------------------------------------------------------------------
Deep Copy :
-----------
In deep copy two different objects will be created, the 2nd object will copy the content of first object.

If we modify the object by using reference variable then only one object will be modified because both the objects are created in two different memory location as shown below.

package com.ravi.object_duplication;

public class Customer 
{
    private int customerId;
    private String customerName;
      
    
    
	@Override
	public String toString() {
		return "Customer [customerId=" + customerId + ", customerName=" + customerName + "]";
	}



	public static void main(String[] args) 
	{
		Customer c1 = new Customer();
		c1.customerId = 111;
		c1.customerName = "Scott";
		
		Customer c2 = new Customer();
		c2.customerId = c1.customerId;
        c2.customerName = c1.customerName;
        
        System.out.println("Before Change");
        System.out.println(c1);
        System.out.println(c2);
        
        System.out.println("..................");
        System.out.println("After change in 2nd Object");
        c2.customerId = 222;
        c2.customerName = "Smith";
        System.out.println(c1);
        System.out.println(c2);
	}

}
===============================================================
**Pass by Value :
-----------------
Java does not support pointers so java only works with pass by value.

Pass by value means we are sending the copy of orginal data to the method.

package com.ravi.pass_by_value;

public class PassByValueDemo1 {

	public static void main(String[] args) 
	{
		int x = 100;
		changeData(x);
        System.out.println(x);
	}
	
	public static void changeData(int y)
	{
		y = 150;
	}

}

Here output is 100 because we are passing the copy of x to y variable
--------------------------------------------------------------------
package com.ravi.pass_by_value;

public class PassByValueDemo2 {

	public static void main(String[] args) 
	{
		int x = 100;
		x = changeData(x);
               System.out.println(x);
	}
	
	public static int changeData(int y)
	{
		y = 150;
		return y;
	}

}

Note : In both the program we are working with primitive variables.
--------------------------------------------------------------------
package com.ravi.pass_by_value;

class Customer
{
	private int customerId = 111;

	public void setCustomerId(int customerId) 
	{
		this.customerId = customerId;
	}
	
	public int getCustomerId()
	{
		return this.customerId;
	}	
}

public class ReferenceDemo1
{

	public static void main(String[] args) 
	{
		Customer c1 = new Customer();
		System.out.println(c1.getCustomerId()); //111	
		
		accept(c1);
		System.out.println(c1.getCustomerId());	//555
	}
	
	public static void accept(Customer cust)  
	{
		cust.setCustomerId(555);
	}	
}

Here we will get the Output 111 and 555, here we are working with 
reference variable, the reference variable c1 is assigned to reference variable cust hence, if we modify by using cust variable then original object will be modified.
--------------------------------------------------------------------
package com.ravi.pass_by_value;

class Product 
{
	private int productId = 111;

	public int getProductId() 
	{
		return productId;
	}

	public void setProductId(int productId) 
	{
		this.productId = productId;
	}	
}

public class ReferenceDemo2 {

	public static void main(String[] args) 
	{
		Product p1 = new Product(); //100x
		System.out.println(p1.getProductId()); //111
		
		accept(p1);
		System.out.println(p1.getProductId()); //111
	}

	public static void accept(Product prod)
	{
		prod = new Product(); //200x
		prod.setProductId(999);
	}
}

Here on p1 reference variable we are assigning one new Product object so the old object value will remain unchaged.
--------------------------------------------------------------------
package com.ravi.object_duplication;

public class Customer 
{
    private double customerBill = 4000;


	public static void main(String[] args) 
	{
		Customer c1 = new Customer();
		Customer c2 = c1;
		
		c2.customerBill = 9000;
		
		System.out.println(c1.customerBill); //9000
		System.out.println(c2.customerBill); //9000
		
		
	}

}
-------------------------------------------------------------------
package com.ravi.object_duplication;

public class Customer 
{
    private double customerBill = 4000;


	public static void main(String[] args) 
	{
		Customer c1 = new Customer();
		
		Customer c2 = new Customer();
		c2.customerBill = 10000;
		
		System.out.println(c1.customerBill); //4000
		System.out.println(c2.customerBill); //10000
		
	}

}
---------------------------------------------------------------
HEAP and STACK Diagram :
------------------------
What is Garbage Collector in java -----------------------------------
It is an automatic memory management technique in java.

In C++ language, A programmer is responsible to allocate as well as de-allocate the memory otherwise we will get OutOfMemoryError.

In java language, Programmer is only responsible to allocate the memory, Memory de-allocation is automatically done by garbage collector.

Garbage Collector is a daemon thread which is responsible to delete the objects from the HEAP Memory. Actually It scans the heap memory and identifying which objects are eligible for Garbage Collector.[THE OBJECTS WHICH DOES NOT CONTAIN ANY REFERENCES ONLY THOSE OBJECTS ARE ELIGIBLE FOR GC]

It internally uses an algorithm called Mark and Sweep algorithm to delete the un-used objects.

As a developer we can also explicitly call garbage collector by writing the following code

System.gc();

==============================================================

How many ways we can make an object eligible for Garbage Collector :
--------------------------------------------------------------------
There are 3 ways we can make an object eligible for GC.

1) Assigning null literal to existing reference variable :
   Employee e1 = new Employee(111,"Ravi");
            e1 = null;

2) Creating an Object inside a method :

   public void createObject()
   {
      Employee e2 = new Employee();
   }
Here we are creating Employee object inside the method so, once the method execution is over then e2 will be deleted from the Stack Frame and the employee object will become eligible for GC.

3) Assigning new Object to the old existing reference variable:
   
   Employee e3 = new Employee();
   e3 = new Employee();

Earlier e3 variable was poting to Employee object after that a new Employee Object is created which is pointing to another memory location so the first object is eligible for GC.

===============================================================
Memory in java :
------------------
In java, whenever we create an object then Object and its content (properties and behavior) are stroed in a special memory called HEAP Memory. Garbage collector visits heap memory only.

All the local variables and parameters variables are executed in Stack Frame and available in Stack Memory.
--------------------------------------------------------------
HEAP and Stack Diagram for CustomerDemo.java :
-----------------------------------------------
class Customer
{
	private String name;
	private int id;

	public Customer(String name , int id) 
	{
		super();
		this.name=name;
		this.id=id;
	}

	public void setId(int id)  //setter  
	{
		this.id=id;
	}

	public int getId() //getter
	{
		return this.id;
	}
}

public class CustomerDemo
{
	public static void main(String[] args) 
	{
		int val = 100;

		Customer c = new Customer("Ravi",2);

        m1(c);   
		
		//GC [Only 1 object i.e 3000x is eligible for GC]
		
		System.out.println(c.getId());
	}

	public static void m1(Customer cust) 
	{
		cust.setId(5);

	    cust = new Customer("Rahul",7);

		cust.setId(9);
		System.out.println(cust.getId());
	}
}  
    
//Output 9 5
--------------------------------------------------------------
public class Sample
{	
	private Integer i1 = 900;

	public static void main(String[] args) 
	{
		Sample s1 = new Sample();    
		                              
		Sample s2 = new Sample();       

	    Sample s3 = modify(s2);  

		s1 = null;

         //GC [4 Objects 1000x,2000x,5000x and 6000x are eligible]

		System.out.println(s2.i1);		
	}
    public static Sample modify(Sample s)
	{
		s.i1=9;
		s = new Sample();
		s.i1= 20;  
        System.out.println(s.i1);
		s=null;
		return s;
	}
}

//20 9
--------------------------------------------------------------
public class Test 
{
	Test t;
	int val;

	public Test(int val)  
	{
		this.val = val;
	}

	public Test(int val, Test t)
	{
		this.val = val;
		this.t = t;
	}

	public static void main(String[] args) 
	{
		Test t1 = new Test(100);
		
		Test t2 = new Test(200,t1);

		Test t3 = new Test(300,t1);

		Test t4 = new Test(400,t2);

		t2.t = t3; 
		t3.t = t4; 
		t1.t = t2.t; 
		t2.t = t4.t; 

	System.out.println(t1.t.val);
	System.out.println(t2.t.val);
	System.out.println(t3.t.val);
	System.out.println(t4.t.val);
	}
	
}  
--------------------------------------------------------------
public class Employee
{
	int id = 100;
	
	public static void main(String[] args) 
	{
		int val = 200;

		Employee e1 = new Employee();     

		e1.id = val;

		update(e1);	  
		
		System.out.println(e1.id);

        Employee e2 = new Employee(); 

		e2.id = 900;
        
		switchEmployees(e2,e1); //3000x, 1000x

		  //GC [2 objects 2000x and 4000x]

			System.out.println(e1.id);
		    System.out.println(e2.id);
	    } 
		
	 public static void update(Employee e)  
	 {
        e.id = 500;
		e = new Employee();
		e.id = 400;
		System.out.println(e.id);
	 }

	 public static void switchEmployees(Employee e1, Employee e2)
	  {
		 int temp = e1.id; 
		 e1.id = e2.id; //500
		 e2 = new Employee();
		 e2.id = temp;
	  }
   }
--------------------------------------------------------------
Passing an Object reference to the Constructor :(Copy Constructor)
--------------------------------------------------------------
We can pass an object reference to the constructor so we can copy the content of one object to another object.

public class Manager 
{
	private int managerId;
	private String managerName;

	public Manager(Employee emp) 
	{
		this.managerId = emp.getEmployeeId();
		this.managerName = emp.getEmployeeName();
	}
}



The following program explains how to copy the content of Employee object to initialize Manager class properties :

3 files :
----------
Employee.java
--------------
package com.ravi.copy_constructor;

public class Employee 
{
    private int employeeId;
    private String employeeName;
    
	public Employee(int employeeId, String employeeName) 
	{
		super();
		this.employeeId = employeeId;
		this.employeeName = employeeName;
	}

	public int getEmployeeId() {
		return employeeId;
	}

	public String getEmployeeName() {
		return employeeName;
	}  
}

Manager.java
-------------
package com.ravi.copy_constructor;

public class Manager 
{
	private int managerId;
	private String managerName;

	public Manager(Employee emp) 
	{
		this.managerId = emp.getEmployeeId();
		this.managerName = emp.getEmployeeName();
	}

	@Override
	public String toString() {
		return "Manager [managerId=" + managerId + ", managerName=" + managerName + "]";
	}
}

CopyConstructorDemo1.java
---------------------------
package com.ravi.copy_constructor;

public class CopyConstructorDemo1 {

	public static void main(String[] args) 
	{
		Employee raj = new Employee(111, "Raj");
		
		Manager m1 = new Manager(raj);
		System.out.println(m1);

	}

}

Note : In the above program we are initializing the Manager data through Employee Data.

The following program explains how to initialize the same class data in another object.

2 files :
---------
Player.java
-----------
package com.ravi.copy_constructor;

public class Player 
{
	private String name1;
	private String name2;

	public Player(String name1, String name2) 
	{
		super();
		this.name1 = name1;
		this.name2 = name2;
	}
	
	public Player(Player p)  //p = p1
	{
		this.name1 = p.name2;
		this.name2 = p.name1;
	}

	@Override
	public String toString() {
		return "Player [name1=" + name1 + ", name2=" + name2 + "]";
	}
}

CopyConstructorDemo2.java
--------------------------
package com.ravi.copy_constructor;

public class CopyConstructorDemo2 {

	public static void main(String[] args) 
	{
		Player p1 = new Player("Virat", "Rohit");
		System.out.println(p1);
		
		
		Player p2 = new Player(p1);
		System.out.println(p2);
		

	}

}
---------------------------------------------------------------
Lab Program :
-------------
Lab Program :(Method return type as a class + Passing Object ref)
----------------------------------------------------------------
A class called Customer is given to you. 

The task is to find the applicable Credit card Type and create CardType object based on the Credit Points of a customer.

Define the following for the class.

Attributes : 
	customerName : String,private
	creditPoints: int, private

Constructor :
	parameterizedConstructor: for both cusotmerName & creditPoints in that order.

Methods :
	Name of the method : getCreditPoints
	Return Type : int
	Modifier   : public 
	Task : This method must return creditPoints
	
	Name of the method : toString, Override it, 
	Return type : String 
	Task :  return only customerName from this.

Create another class called CardType. Define the following for the class

Attributes :
	customer : Customer, private
	cardType : String, private
Constructor :
	parameterizedConstructor: for customer and cardType attributes in that order

Methods :
	Name of the method : toString  Override this.  
	Return type : String
	Modifier : public
	Task :  Return the string in the following format.
		The Customer 'Rajeev' Is Eligible For 'Gold' Card.


Create One more class by name CardsOnOffer and define the following for the class.

Method : 
	Name Of the method : getOfferedCard 
	Return type : CardType
	Modifiers: public,static
	Arguments: Customer object

	Task : 	Create and return a CardType object after logically finding cardType from creditPoints as per the below rules.
		creditPoints	    cardType
		100  - 500	-   Silver
		501  - 1000	-   Gold
		1000 >		-   Platinum
		< 100		-   EMI
		
Create  an ELC class which contains Main method to test the working of the above.

4 Files :
----------
Customer.java
---------------
package com.ravi.scenario_program;

public class Customer 
{
	private int creditPoints;
	private String customerName;

	public Customer(int creditPoints, String customerName) 
	{
		super();
		this.creditPoints = creditPoints;
		this.customerName = customerName;
	}
	
	public int getCreditPoints() //getter
	{
		return this.creditPoints;
	}

	@Override
	public String toString() 
	{
        return this.customerName;
	}
}

CardType.java
---------------
package com.ravi.scenario_program;

public class CardType 
{
	private String cardType;
	private Customer customer; // HAS-A Relation

	public CardType(String cardType, Customer customer)
	{
		super();
		this.cardType = cardType;
		this.customer = customer;
	}

	@Override
	public String toString() 
	{
	  //The Customer 'Rajeev' Is Eligible For 'Gold' Card.
	
	  return "The Customer '"+this.customer+"' Is Eligible For '"+this.cardType+"' Card";
	}
	
	
	

}


CardsOnOffer.java
------------------
package com.ravi.scenario_program;

public class CardsOnOffer 
{
	public static CardType getOfferedCard(Customer cust)
	{
	        int crediPoint = cust.getCreditPoints();
		
		if(crediPoint>=100 && crediPoint <=500)
		{
			return new CardType("Silver", cust);
		}
		
		else if(crediPoint>500 && crediPoint <=1000)
		{
			return new CardType("Gold", cust);
		}
		else if(crediPoint>1000)
		{
			return new CardType("Platinum", cust);
		}	
		else
		{
			return new CardType("EMI", cust);
		}
		
	}
	
}

ELC.java
---------
package com.ravi.scenario_program;

import java.util.Scanner;

public class ELC {

	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter Customer Name :");
		String name = sc.nextLine();
		
		System.out.print("Enter Customer Credit Points :");
		int creditPoint = sc.nextInt();
		
		Customer c1 = new Customer(creditPoint, name);
		
		CardType offeredCard = CardsOnOffer.getOfferedCard(c1);
		System.out.println(offeredCard);
		
		sc.close();	

	}

}
---------------------------------------------------------------
25-09-2024
----------
Modifiers on Constructor :
---------------------------
Constructor can accept all types of access modifiers which are apllicable for accessibility level like private, default, protected and public.

package com.ravi.constructor;

public class Sample 
{
	private int x,y;
	
	private Sample(int x, int y) //Private Constructor
	{
		this.x = x;
		this.y = y;
	}
	
	
	@Override
	public String toString() {
		return "Sample [x=" + x + ", y=" + y + "]";
	}

	public static void main(String[] args) 
	{
		Sample s = new Sample(12, 24);
		System.out.println(s);

	}

}
----------------------------------------------------------------
package com.ravi.constructor;

public class Demo 
{
    public Demo()
    {
    	System.out.println("No Argument Constructor");
    	return;  //Valid
    }
    
	public static void main(String[] args) 
	{
		new Demo(); //Nameless OR Anonymous Object
	}

}
----------------------------------------------------------------
Note : We can't apply static, final, abstract and synchronized modifier on constructor.
----------------------------------------------------------------
IQ :
----
Why we should declare a constructor with private Access modifier ?

We can declare a constructor with private access modifier due to the following two reasons :

1) If we want to declare only static variables and static methods inside a class then we should decalre constructor with private access modifier [Object is not required]

Example : java.util.Arrays and java.lang.Math class has private constructor because It contains only static methods.

2) If we want to develop singleton class, for singleton class we should create only one object by the class itself then we should declare the constructor with private access modifier.

package com.ravi.constructor;

public class Foo 
{
  private Foo() //Private Constructor
  {
	  System.out.println("It is a private Constructor");
  }
  
  public static void main(String [] args)
  {
	  new Foo(); 	  
  }
	
}
-------------------------------------------------------------------
What is an instance block OR instance initializer in java ?
------------------------------------------------------------
It is a special block in java which is automatically executed at the time of creating the Object.

Example :

{
   //Instance OR Non static block
}

If a constructor contains first line as a super() statement then only compiler will add instance block in the 2nd line of constructor otherwise it will not be added by the compiler.

If constructor contains super() then non static block will be executerd before the body of the constructor.

The main purpose of instance block to initialize the instance variables (So It is called Instance Iniatilizer) of the class OR to write a common logic which will be applicable to all the objects.

If a class contains multiple non static blocks then it will be executed according to the order [Top to bottom]

Instance initializer must be executed normally that menas we can't interrupt the execution flow of any initializer hence we can't write return statement inside non static block.

If a user defines non static block after the body of the constructor then compiler will not placed in the 2nd line of the constructor. It will be executed as it is because compiler will search the NSB in the class level.

-----------------------------------------------------------------
package com.ravi.instance_block;

class Test
{
	{
		System.out.println("Instance OR Non static Block ");
	}
}

public class InstanceBlockDemo1 
{
	public static void main(String[] args) 
	{
		new Test();
		new Test();
		new Test();
	}

}

Everytime we will create the object, Instance block will be executed
------------------------------------------------------------------
package com.ravi.instance_block;

class Sample
{
	int x;
	
	{
		x = 100;
	}
	
}


public class InstanceBlockDemo2 {

	public static void main(String[] args) 
	{
		Sample s1 = new Sample();
		System.out.println(s1.x);

	}

}

Note : By using instance block we can initialize the instance variable.
----------------------------------------------------------------
package com.ravi.instance_block;

class Sample1
{
	public Sample1()
	{
		System.out.println("No Arg Constr");
	}
	
	public Sample1(int x)
	{
		System.out.println("Parameterized Constructor");
	}
	
	
	{
		System.out.println("Non Static Block");
	}
	
}

public class InstanceBlockDemo3 {

	public static void main(String[] args) 
	{
		new Sample1();
		new Sample1(15);
		
	}

}

Note : Non static block will be added to all the constructors which contains super().
-------------------------------------------------------------------
package com.ravi.instance_block;

class NIT
{
	public NIT()
	{
		super();
		//NSB
		System.out.println("No Arg constr");
	}
	
	public NIT(String batch)
	{
		this();
		System.out.println("Parameterized Constr "+batch);
	}
	
	{
		System.out.println("Instance Block OR Non static Block");
	}
}


public class InstanceBlockDemo4 {

	public static void main(String[] args) 
	{
		new NIT("Batch 37");

	}

}

Note : Non static block will not be added to the constructor which contains this()
------------------------------------------------------------------
package com.ravi.instance_block;

class Demo1
{
	int x;
	
	{
		x = 100;
		System.out.println(x);
	}
	
	{
		x = 200;
		System.out.println(x);
	}
	
	{
		x = 300;
		System.out.println(x);
	}
	
	
	public Demo1()
	{
		x = 400;
		System.out.println(x);
	}
}


public class InstanceBlockDemo5 {

	public static void main(String[] args) 
	{
		new Demo1();
	}

}

Note : NSB will be executed according to the order.
-------------------------------------------------------------------
package com.ravi.instance_block;

public class InstanceDemo6 
{
	{
		System.out.println("Instance block");
		return;
	}

	
	public static void main(String[] args) 
	
	{
		// TODO Auto-generated method stub

	}

}

Note : no return keyword inside non static block
-----------------------------------------------------------------
package com.ravi.instance_block;

class General
{
	public General()
	{
		System.out.println("Constructor Body");
		
		{
			System.out.println("Non Static Block");
		}
	}	
}

public class InsatanceBlockDemo7 
{
	public static void main(String[] args) 
	{		
        new General();
	}

}

Note : Here non static block will be executed after the body of constructor.
----------------------------------------------------------------
Order of instance variable initialization in the program life cycle :

All the instance variables are initialized in the following order during the life cycle :

1) It will initialized with default value at the time of Object   creation. [new Demo(); Demo class instance variable will be initialized with default value, init method is working internally]
   
2) Now control will verify whether, we have initailized at the time of variable declaration or not.

3) Now control will verify whether, we have initailized 
   inside non static block or not. [If present]

4) Now control will verify whether, we have initailized in the 
   body of the constructor or not.
   
5) Now control will verify whether, we have initailized in the method body or not but it is not recommended because Object is already created, we need to call the method explicitly, It is not the part of the object.

Default value [new keyword] => At the time of declaration => in the body of non static block => in the body of constructor => Inside method body [Not Recommended]

package com.ravi.instance_initialization;

class Demo
{
	int x = 100;  //Initialization Order1
	
	
	Demo()
	{
		this.x = 300; //Initialization Order3
	}
	
	

	{
		x = 200; //Initialization Order2
	}
}

public class InstanceInitializationOrder 
{
	public static void main(String[] args)
	{
		Demo d1 = new Demo();
		System.out.println(d1.x);

	}

}
----------------------------------------------------------------
What is blank final field in java ?
------------------------------------
If a final instance variable is not initialized at the time of declaration then it is called blank final field.

final int A ; //Blank final field

A final variable must have user-defined value.

A blank final field can't be initialized by default constrcutor as shown in the program.

class Test 
{
	final int A;  //Blank final field
	
	public static void main(String[] args) 
	{
		Test t1 = new Test();
		System.out.println(t1.A);
	}
}

A blank final field must be explicitly initialized by the user till the execution of constructor body.[Till Object creation]. It can be iniatialized in the following two places :
  
   a) Inside a non static block [If available]
   b) Inside the constructor body
   
class Test 
{
	final int A ;  //Blank final field
	
	{
		A = 100;
	}
	
	
	
	public static void main(String[] args) 
	{
		Test t1 = new Test();
		System.out.println(t1.A);
	}
}

* A blank final field can't be initialized by method.[Object creation is already completed]

* A blank final field can also have default values as shown the in the program.

class Test 
{
	final int A ;  //Blank final field
	
	{
		printDefaultValue();
		A = 100;
	}
	
	public void printDefaultValue()
	{
		System.out.println(A);
	}
	
	
	public static void main(String[] args) 
	{
		Test t1 = new Test();
		System.out.println(t1.A);
	}
}

A blank final must be iniatilized explicitly by user in all the constructors available in the class.

package com.ravi.basic;

class Sample
{
	private final int x;
	
	public Sample()
	{
		x = 100;
	}
	
	public Sample(int y)
	{
		x = y;		
	}

	public int getX() 
	{
		return x;
	}
	
	
	
}


public class BlankFinalField {

	public static void main(String[] args)
	{
		Sample s1 = new Sample();
		System.out.println(s1.getX());
		
		Sample s2 = new Sample(200);
		System.out.println(s2.getX());

	}

}
=================================================================
Relationship between the classes :
----------------------------------
In java we have 2 types of relation in between the classes :

 a) IS-A Relation
 b) HAS-A Relation
 
IS-A Relation :
---------------
class Car
{
}
class Ford extends Car //[Ford IS-A car ]
{
}

HAS-A Relation :
-----------------
class Engine
{
}

class Car
{
   private Engine engine;  //Car HAS-A Engine.
}


IS-A relation we can achieve by using Inheritance Concept.
HAS-A relation we can achieve by using Association Concept.

27-09-2024
------------
Inheritance (IS-A Relation) :
--------------------------------
Deriving a new class (child class) from existing class (parent class) in such a way that the new class will acquire all the properties and features (except private) from the existing class is called inheritance.

It is one of the most imporatnt feature of OOPs which provides "CODE REUSABILITY".

Using inheritance mechanism the relationship between the  classes is parent and child. According to Java the parent class is called super class and the child class is called sub class.

In java we provide inheritance using 'extends' keyword.

*By using inheritance all the feature of super class is by default available to the sub class so the sub class need not to start the process from begning onwards.

Inheritance provides IS-A relation between the classes. IS-A relation is tightly coupled relation (Blood Relation) so if we modify the super class content then automatically sub class content will also modify.

Inheritance provides us hierarchical classification of classes, In this hierarchy if we move towards upward direction more generalized properties will occur, on the other hand if we move towards downwand more specialized properties will occur.
------------------------------------------------------------------
Types of Inheritance in java :
------------------------------
Java supports 5 types of inheritance :

 1) Single level Inheritance
 2) Multi level Inheritance
 3) Hierarchical Inheritance
 4) Multiple Inheritance (Not supported using class)
 5) Hybrid Inheritance (Combination of two)
---------------------------------------------------------------
Program on Single Level Inheritance :
-------------------------------------
package com.ravi.inheritance;

class Father
{
	public void house()
	{
		System.out.println("3 BHK House");
	}
}
class Son extends Father
{
	public void car()
	{
		System.out.println("Audi Car");
	}
}

public class SingleLevelDemo1 
{
	public static void main(String[] args) 
	{
		Son s1 = new Son();
		s1.house();
		s1.car();

	}

}

Note : In inheritance we should always create the object for more specialized class(son class);
-------------------------------------------------------------
package com.ravi.inheritance;

class Super
{
	private int x,y;

	public int getX() 
	{
		return x;
	}

	public void setX(int x) 
	{
		this.x = x;
	}

	public int getY() 
	{
		return y;
	}

	public void setY(int y) 
	{
		this.y = y;
	}	
}

class Sub extends Super
{
	public void dispalyData()
	{
		System.out.println("x value is :"+getX());
		System.out.println("y value is :"+getY());
	}
}

public class SingleLevelDemo2 {

	public static void main(String[] args)
	{
		Sub s1 = new Sub();
		s1.setX(100);
		s1.setY(200);
		s1.dispalyData();

	}

}
---------------------------------------------------------------
28-09-2024
-----------
How to initialize the super class properties :
----------------------------------------------
In order to initialize the super class properties we should use super keyword in the sub class as a first line of constructor.

super keyword always referes to its immediate super class.

Just like this keyword, super keyword (non static member) also we can't use inside static context.

super keyword we can use 3 ways in java :
------------------------------------------
1) To access super class variable
2) To access super class method
3) To access super class constructor.

1) To access the super class variable (Variable Hiding) :
---------------------------------------------------------
Whenever super class variable name and sub class variable name both are same then it is called variable Hiding, Here sub class variable hides super class variable.

In order to access super class variable i.e super class memory, we should use super keyword as shown in the program.

VariableHiding.java
-------------------
package com.ravi.super_keyword;

class Father
{
	protected double balance = 50000; 
}
class Son extends Father
{
	protected double balance = 9000; //Variable Hiding
	
	public void getBalance()
	{
		System.out.println("Son balance is :"+this.balance);
		System.out.println("Father balance is :"+super.balance);
	}	
}

public class VariableHiding 
{
	public static void main(String[] args) 
	{
		Son s = new Son();
		s.getBalance();

	}

}
---------------------------------------------------------------
2) To call super class method :
-------------------------------
If the super class non static method name and sub class non static method name both are same (Method Overriding) and if we create an object for sub class then sub class method will be 
executed (bottom to top), if we want to call super class method from sub class method body then we we should use super keyword as shown in the program.

class Super
{
	public void show()
	{
		
		System.out.println("Super class show method");
	}
}
class Sub extends Super
{
	public void show()
	{
		super.show();
		System.out.println("Sub class show method");
	}
}
public class CallingSuperClassMethod 
{	
	public static void main(String[] args) 
	{	
	   Sub sub = new Sub();
	   sub.show();
	}

}
--------------------------------------------------------------
3) To access the super class constructor (Constructor Chaining) :
----------------------------------------------------------------
Whenever we write a class in java and we don't write any kind of constructor to the class then the java compiler will automatically add one default no argument constructor to the class.

THE FIRST LINE OF ANY CONSTRUCTOR IS RESERVERD EITHER FOR super() or this() keyword that means first line of any constructor is used to call another constructor of either same class OR super class.

In the first line of any constructor if we don't specify either super() or this() then the compiler will automatically add super() to the first line of constructor.

Now the purpose of this super() [added by java compiler], to call the default constructor or No-Argument constructor of the super class.

In order to call the constructor of super class as well as same class, we have total 4 cases.
---------------------------------------------------------------
Case 1:
-------
super() : Automatically added by java compiler to maintain the 
          hierarchy in the first line of the Constructor. It
	  is used to call default OR no argument constructor 
	  of super class.

package com.ravi.constructor_demo;

class Alpha
{
	public Alpha()
	{
		super();  
		System.out.println("Alpha class");
	}
}
class Beta extends Alpha
{
	public Beta()
	{
		super();
		System.out.println("Beta class");
	}
}

public class CallingSuperClassConstructor 
{
	public static void main(String[] args)
	{
	  Beta b = new Beta();

	}

}
---------------------------------------------------------------
Case 2 :
---------
super("Java") : Must be explicitly written by user in the
                first line of constructor [not inside a method]. It is used to call the parameterized constructor of super class.

package com.ravi.constructor_demo;

class Super
{
	protected String name;
	
	public Super(String name)
	{
		this.name = name;
	}	
	
}
class Sub extends Super
{
	public Sub()
	{
		super("Java");  //Calling Parameterized constr
	}
	
	public String getSubjectName()
	{
		return this.name;
	}
}

public class CallingParameterizedConstructor
{
	public static void main(String[] args) 
	{
		Sub s1 = new Sub();
		System.out.println(s1.getSubjectName());

	}

}
--------------------------------------------------------------
Program that describes default constructor and super() will be added by the compiler.

ConstructorDemo.java
---------------------
package com.ravi.super_demo;

class Alpha
{
	public Alpha()
	{
		System.out.println("Alpha class Constructor!!!");
	}
}
class Beta extends Alpha
{}

class Gamma extends Beta
{
	public Gamma()
	{
		System.out.println("Gamma class Constructor!!!");
	}
}

public class ConstructorDemo {

	public static void main(String[] args) 
	{
		new Gamma();
	}

}


30-09-2024
----------
Case 3 :
--------
this() : Must be explicitly written by user in the
         first line of constructor. It is used to call
          no argument constructor of current class.

package com.ravi.super_demo;

class Super
{
	public Super()
	{
		System.out.println("Super class no argument constructor");
	}
	
	public Super(String msg)
	{
		this();
		System.out.println("Super class  Parameterized constructor :"+msg);
	}
}
class Sub extends Super
{
	public Sub()
	{
		super("Java");
		System.out.println("Sub class no argument constructor");
	}
}

public class CallingSameClassNoArg 
{
	public static void main(String[] args)
	{
		new Sub();

	}

}
----------------------------------------------------------------
Case 4 :
---------
this(15) : Must be explicitly written by user in the
           first line of constructor. It is used to call
           parameterized constructor of current class.

package com.ravi.super_demo;

class Base
{
	
	public Base()
	{
		this(15);
		System.out.println("No Argument Constructor of Base class");
	}
	
	public Base(int x)
	{
		System.out.println("Parameterized Constructor of Base class :"+x);
	}
}

class Derived extends Base
{
	public Derived()
	{
		System.out.println("No Argument Constructor of Derived class");
	}
}

public class ParameterizedConstructorOfCurrent 
{
	public static void main(String[] args) 
	{
		Derived d = new Derived();
	}

}
----------------------------------------------------------------
Program on super keyword :
--------------------------
package com.ravi.super_demo;

class Shape
{
	protected int x;

	public Shape(int x)
	{
		super();
		this.x = x;
		System.out.println("x value is :"+x);
	}	
}
class Square extends Shape
{
	
	public Square(int side)
	{
		super(side);
	}
	
	public void getAraeOfSquare()
	{
		double area = x * x;
		System.out.println("Area of Square is :"+area);
	}
}

public class SuperDemo1 {

	public static void main(String[] args) 
	{
		Square ss = new Square(5);
		ss.getAraeOfSquare();

	}

}
----------------------------------------------------------------
Another Program on super keyword :
----------------------------------
package com.ravi.super_demo;

class Shape
{
	protected int x;

	public Shape(int x)
	{
		super();
		this.x = x;
		System.out.println("x value is :"+x);
	}	
}

class Rectangle extends Shape
{
	protected int breadth;
	
	public Rectangle(int length, int breadth)  //10   20
	{
		super(length);
		this.breadth = breadth;
	}
	
	public void getAreaOfRectangle()
	{
		double area = super.x * this.breadth;
		System.out.println("Area of Rectangle :"+area);
	}
	
}

class Circle extends Shape
{
	protected final double PI = 3.14;
	
	public Circle(int radius)
	{
		super(radius);
	}
	
	public void getAreaOfCircle()
	{
		double area = PI * x * x;
		System.out.println("Area of Circle is :"+area);
	}
}


public class SuperDemo1 {

	public static void main(String[] args) 
	{
		Rectangle rr = new Rectangle(10, 20);
		rr.getAreaOfRectangle();
		
		Circle cc = new Circle(3);
		cc.getAreaOfCircle();	

	}

}
================================================================
HOW MANY WAYS WE CAN INITIALIZE THE OBJECT PROPERTIES ?
-------------------------------------------------------
The following are the ways to initialize the object properties :
----------------------------------------------------------------
public class Test
{
   int x,y;
}


1) At the time of declaration :

   Example :
   
  public class Test
   {
      int x = 10;
      int y = 20;
   }

   Test t1 = new Test();   [x = 10  y = 20]
   Test t2 = new Test();   [x = 10  y = 20]

Here the drawback is all objects will be initialized with same value.
-----------------------------------------------------------------------

2) By using Object Reference :

   public class Test
   {
      int x,y;
   }
   
   Test t1 = new Test();   t1.x=10;   t1.y=20;
   Test t2 = new Test();   t2.x=30;   t2.y=40;

   Here we are getting different values with respect to object but here the program becomes more complex.
---------------------------------------------------------------
3) By using methods :

   A) First Approach (Method without Parameter)
   ----------------------------------------------
   public class Test
   {
      int x,y;

      public void setData()  
      {                         
         x = 100;  y = 200;
      }
   }

    Test t1 = new Test();  t1.setData();  [x = 100   y = 200]
    Test t2 = new Test();  t2.setData();  [x = 100   y = 200]
    
    Here also, all the objects will be iniatilized with same 
    value.

    B) Second Approach (Method with Parameter)
    -------------------------------------------
     public class Test
     {
      int x,y;

      public void setData(int x, int y)  
      {                        
         this.x = x;
	 this.y = y;
      }
   }
   
    Test t1 = new Test();  t1.setData(12,78);  [x = 12   y = 78]
    Test t2 = new Test();  t2.setData(15,29);  [x = 15   y = 29]

    Here the Drawback is initialization and re-initialization both are done in two different lines so Constructor introduced.
----------------------------------------------------------------------
4) By using Constructor 

   A) First Approach (No Argument Constructor)
   --------------------------------------------
   public class Test
   {
      int x,y;

      public Test()  //All the objects will be initialized with
      {                                             same value
         x = 0;  y = 0;
      }     
           
   }

    Test t1 = new Test();    [x = 0   y = 0]
    Test t2 = new Test();    [x = 0   y = 0]
    

    B) Second Approach (Parameterized Constructor)
    -----------------------------------------------
     public class Test
     {
      int x,y;      

      public Test(int x, int y)  
      {                        
         this.x = x;
	 this.y = y;
      }
   }

    Test t1 = new Test(12,78);    [x = 12   y = 78]
    Test t2 = new Test(15,29);    [x = 15   y = 29]

    This is the best way to initialize our instance variable because variable initialization and variable re-initialization both will be done in the same line as well as all the objects will be initialized with different values. 

    C) Third Approach (Copy Constructor)
    --------------------------------------

       public class Manager
       {
          private int managerId;
	  private String managerName;
          
	  public Manager(Employee emp)
	  {
	    this.managerId = emp.getEmployeeId();
	    this.managerName = emp.getEmployeeName();
          }
       }

Here with the help of Object reference (Employee class) we are 
initializing the properties of Manager class. (Copy Constructor)

        d) By using instance block (Instance Initializer)
	-------------------------------------------------
	
	public class Test
	{
	   int x,y;

           public Test()
	   {
	      System.out.println(x); //100
	      System.out.println(y); //200
	   }

           //Instance block
	   {
	       x = 100; 
	       y = 200;
	   }

------------------------------------------------------------------
5) By using super keyword :

   class Super
   {
     int x,y;

     public Super(int x , int y)
     {
        this.x = x;
	this.y = y;
     }
   }
   class Sub extends Super
   {
      Sub()
      {
         super(100,200); //Initializing the properties of super class
      }
   }

   new Sub();
================================================================
WAP in java for Single Level Inheritance :
-------------------------------------------
package com.ravi.super_demo;

class TemporaryEmployee
{
	protected int employeeNumber;
	protected String employeeName;
	protected String employeeAddress;
	
	public TemporaryEmployee(int employeeNumber, String employeeName, String employeeAddress) 
	{
		super();
		this.employeeNumber = employeeNumber;
		this.employeeName = employeeName;
		this.employeeAddress = employeeAddress;
	}	
}
class PermanentEmployee extends TemporaryEmployee
{
	protected String department;
	protected String designation;
	
	public PermanentEmployee(int employeeNumber, String employeeName, String employeeAddress, String department,	String designation) {
		super(employeeNumber, employeeName, employeeAddress);
		this.department = department;
		this.designation = designation;
	}

	@Override
	public String toString() 
	{
		return "PermanentEmployee [employeeNumber=" + employeeNumber + ", employeeName=" + employeeName
				+ ", employeeAddress=" + employeeAddress + ", department=" + department + ", designation=" + designation
				+ "]";
	}	
}

public class SingleLevelDemo1 
{

	public static void main(String[] args) 
	{
		PermanentEmployee p = new PermanentEmployee(1, "Scott", "Ameerpet", "IT", "Java Developer");
		System.out.println(p);
	}
}
----------------------------------------------------------------
01-10-2024
-----------
Program on Hierarchical Inheritance :
--------------------------------------
package com.ravi.inheritance;

import java.util.Scanner;

class Employee
{
	protected double employeeSalary;
	
	public Employee(double employeeSalary) 
	{
		super();
		this.employeeSalary = employeeSalary;
	}
}
class Developer extends Employee
{
	public Developer(double developerSalary)
	{
		super(developerSalary);
	}

	@Override
	public String toString() 
	{
		return "Developer [employeeSalary=" + employeeSalary + "]";
	}	
	
}
class Designer extends Employee
{
	public Designer(double designerSalary)
	{
		super(designerSalary);
	}

	@Override
	public String toString() 
	{
		return "Designer [employeeSalary=" + employeeSalary + "]";
	}
}

public class HierachicalInheritance 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter Developer Salary :");
		double devSalary = sc.nextDouble();
		Developer developer = new Developer(devSalary);
		System.out.println(developer);
		
		System.out.print("Enter Designer Salary :");
		double desSalary = sc.nextDouble();
		Designer designer = new Designer(desSalary);
		System.out.println(designer);
		sc.close();
	}

}
----------------------------------------------------------------
Program on Multilevel inheritance :
-----------------------------------
package com.ravi.inheritance;

class Student
{
	protected int studentId;
	protected String studentName;
	protected String studentAddress;
	
	public Student(int studentId, String studentName, String studentAddress) 
	{
		super();
		this.studentId = studentId;
		this.studentName = studentName;
		this.studentAddress = studentAddress;
	}

	@Override
	public String toString() 
	{
		return "Student [studentId=" + studentId + ", studentName=" + studentName + ", studentAddress=" + studentAddress
				+ "]";
	}	
}

class Science extends Student  
{
	protected int phyMarks;
	protected int cheMarks;
	public Science(int studentId, String studentName, String studentAddress, int phyMarks, int cheMarks) {
		super(studentId, studentName, studentAddress);
		this.phyMarks = phyMarks;
		this.cheMarks = cheMarks;
	}
	@Override
	public String toString() 
	{
		return super.toString()+"Science [phyMarks=" + phyMarks + ", cheMarks=" + cheMarks + "]";
	}	
	
}
class PCM extends Science
{
	protected int maths;

	public PCM(int studentId, String studentName, String studentAddress, int phyMarks, int cheMarks, int maths) {
		super(studentId, studentName, studentAddress, phyMarks, cheMarks);
		this.maths = maths;
	}
	
	@Override
	public String toString() 
	{
		return super.toString()+"PCM [maths=" + maths + "]";
	}	
	
	public void totalMarks()
	{
		int total = phyMarks + cheMarks + maths;
		System.out.println("Total Marks is :"+total);
	}
	
}

public class MultiLevelInheritance {

	public static void main(String[] args) 
	{
		PCM p = new PCM(1, "Smith", "S R Nagar", 60, 70, 90);
		p.totalMarks();
		System.out.println(p);

	}

}
----------------------------------------------------------------
**Why java does not support multiple Inheritance ?
--------------------------------------------------
Multiple Inheritance is a situation where a sub class wants to inherit the properties two or more than two super classes.

In every constructor we have super() or this(). When compiler will add super() to the first line of the constructor then we have an ambiguity issue that super() will call which super class constructor as shown in the diagram [01-OCT-24]

It is also known as Diamond Problem in java so the final conclusion is we can't achieve multiple inheritance using classes but same we can achieve by using interface [interface does not contain any constructor]

================================================================
Access modifiers in java :
---------------------------
In order to define the accessibility level of the class as well as member of the class we have 4 access modifiers :

1) private (Within the same class)
2) default (Within the same package)
3) protected (Within the same package Or even from another 
              package by using Inheritance)
4) public (No Restriction)


private :
---------
It is the most restrictive access modifier because the member declared as private can't be accessible from outside of the class.
In Java we can't declare an outer class as a private or protected. Generally we should declare the data member(variables) as private.

In java outer class can be declared as public, abstract, final, sealed and non-sealed only.

default :-
----------
It is an access modifier which is less restrictive than private. It is such kind of access modifier whose physical existance is not avaialble that means when we don't specify any kind of access modifier before the class name, variable name or method name then by default it would be default.

As far as its accessibility is concerned, default members are accessible within the same folder(package) only. It is also known as private-package modifier.


protected :
------------
It is an access modifier which is less restrictive than default because the member declared as protected can be accessible from the outside of the package (folder) too but by using inheritance concept.

2 files :
----------
Test.java [It is in com.nit.m1 package]
---------------------------------------
package com.nit.m1;

public class Test 
{
   protected int x = 500; 
  
}

ELC.java[It is in com.nit.m2 package]
--------------------------------------
package com.nit.m2;

import com.nit.m1.Test;

public class ELC extends Test 
{
	public static void main(String[] args) 
	{
		ELC e1 = new ELC();
		System.out.println(e1.x);
	}

}

Note : From the above programs it is clear that protected members are accessible from outside of the pacakge but by using Inheritance.

public :
-------
It is an access modifier which does not contain any kind of restriction that is the reason the member declared as public can be accessible from everywhere without any restriction.

According to Object Oriented rule we should declare the classes and methods as public where as variables must be declared as private or protected according to the requirement.

Note : If a method is used for internal purpose only (like validation)
then we can declare that method as private method.It is called 
Helper method.
----------------------------------------------------------------
02-10-2024
-------------
JVM Architecture with class loader sub system :
-----------------------------------------------
The entire JVM Architecture is divided into 3 sections :

1) Class Loader sub system
2) Runtime Data areas (Memory Areas)
3) Execution Engine

Class Loader Sub System :
-------------------------
The main purpose of Class Loader sub system to load the required .class file into JVM Memory from different memory loactions.

In order to load the .class file into JVM Memory, It uses an algorithm called "Delegation Hierarchy Algoroithm".

Internally, Class Loader sub system performs the following Task

      1) LOADING
      2) LINKING
      3) INITIALIZATION


LOADING :
---------
In order to load the required .class file, JVM makes a request to class loader sub system. The class loader sub system follows delegation hierarchy algorithm to load the required .class files from different areas.

To load the required .class file we have 3 different kinds of class loaders.

1) Bootstrap/Primordial class loader

2) Extension/Platform class loader

3) Application/System class loader

Bootstrap/Primordial class Loader :-
------------------------------------
It is responsible for loading all the predefined .class files that means all API(Application Programming Interface) level predefined classes are loaded by Bootstrap class loader.

It has the highest priority becuase Bootstrap class loader is the super class for Platform class loader.

It loads the classes from the following path 
C -> Program files -> Java -> JDK -> lib -> jrt-fs.jar 

Platform/Extension class loader :
----------------------------------
It is responsible to load the required .class file which is given by some 3rd party in the form of jar file.

It is the sub class of Bootstrap class loader and super class of Application class loader so it has more priority than Application class loader.

It loads the required .class file from the following path.
C -> Program files -> Java -> JDK -> lib -> ext -> ThirdParty.jar 

Command to create the jar file :
jar cf FileName.jar FileName.class         [*.class]

[If we want to compile more than one java file at a time then the command is :  javac *.java]

Application/System class loader :
---------------------------------------
It is responsible to load all userdefined .class file into JVM memory.

It has the lowest priority because it is the sub class Platform class loader.

It loads the .class file from class path level or environment 
variable.

Note :- 
------
If all the class loaders are failed to load the .class file into JVM memory then we will get a Runtime exception i.e java.lang.ClassNotFoundException.
----------------------------------------------------------------
How Delegation Hierarchy algorithm works :-
---------------------------------------------------
Whenever JVM makes a request to class loader sub system to load the required .class file into JVM memory, first of all, class loader sub system makes a request to Application class loader, Application class loader will delegate(by pass) the request to the Extension class loader, Extension class loader will also delegate the request to Bootstrap class loader.

Bootstrap class loader will load the .class file from lib folder(jrt-fs.jar) and then by pass the request back to extension class loader, Extension class loader will load the .class file from ext folder(*.jar) and by pass the request back to Application class loader, It will load the .class file from environment variable into JVM memory. 

Note : java.lang.Object is the first class to be loaded into JVM Memory.
---------------------------------------------------------------
03-10-2024
-----------
What is Method Chaning in java ?
--------------------------------
It is a technique through which we call multiple methods in a single statement.

In this method chaining, always for calling next method we depend upon last method return type.

The final return type of the method depends upon last method call as shown in the program.

MethodChainingDemo1.java
-------------------------
package com.ravi.method_chaining;

public class MethodChainingDemo1 {

	public static void main(String[] args) 
	{
	   String s1 = "india";
	   char ch =  s1.toUpperCase().concat(" is great").charAt(1);
	   System.out.println(ch);
	}

}

MethodChainingDemo2.java
-------------------------
package com.ravi.method_chaining;

public class MethodChainingDemo2 {

	public static void main(String[] args) 
	{
		String str = "hyderabad";
		int length = str.concat(" is an IT city").toUpperCase().length();
        System.out.println("Length is :"+length);
	}

}
-------------------------------------------------------------
Role of java.lang.Class class in class loading :
----------------------------------------------------
There is a predefined class called Class available in java.lang pacakge.

In JVM memory whenever we load a class then it is loaded in special memory called Method Area and retutn type is java.lang.Class class object.

   java.lang.Class cls = AnyClass.class
   
 java.lang.Class class contains a predefined non static method  called getName() through which we can get the fully qualified name [Package Name + class Name]
 
 public String getName() : Provide fully qualified name of the class. 
---------------------------------------------------------------
WAP that deslang.cribes java.Class will hold any class .class file into JVM Memory.

ClassLoadingReturnType.java
---------------------------
package com.ravi.class_loading;

class Customer{}

class Employee{}

class Player{}


public class ClassLoadingReturnType {

	public static void main(String[] args) 
	{
		java.lang.Class cls = Customer.class;
		System.out.println("class name is :"+cls.getName());
		
        cls = Player.class;
        System.out.println("class name is :"+cls.getName());
        
        cls = Employee.class;
        System.out.println("class name is :"+cls.getName());
	}

}
----------------------------------------------------------------
WAP that describes Application class loader is responsible to 
load the user defined .class file

java.lang.Class class has provided a predefined non static method called getClassLoader(), the return type of this method is ClassLoader class.[Factory Method]

This method will provide the class loader name which is responsible to load the .class file into JVM Memory.

public ClassLoader getClassLoader()

Test.java
-----------
package com.ravi.class_loading;

public class Test 
{
	public static void main(String[] args) 
	{
		System.out.println("Test.class file is loaded by :"+Test.class.getClassLoader());

	}

}
---------------------------------------------------------------
WAP that describes Platform class Loader is the super class for 
Application class loader 

getClassLoader() method return type is ClassLoader so further we can call any method of ClassLoader class, ClassLoader class
has provided a method called getParent() whose return type is again ClassLoader only.

    public ClassLoader getParent();

package com.ravi.class_loading;

public class Demo {

	public static void main(String[] args) 
	{
		ClassLoader parent = Demo.class.getClassLoader().getParent();
		System.out.println(parent);

	}

}
----------------------------------------------------------------
package com.ravi.class_loading;

public class Demo {

	public static void main(String[] args) 
	{
		ClassLoader parent = Demo.class.getClassLoader().getParent().getParent();
		System.out.println(parent); //null

	}

}

Note :- Here we will get the output  as null because it is built in class loader for JVM which is used for internal purpose (loading only predefined .class file) so implementation is not provided hence we are getting null.
----------------------------------------------------------------
verify :-
-------
It ensures the correctness of the .class files, If any suspicious activity is there in the .class file then It will stop the execution immediately by throwing a runtime error i.e java.lang.VerifyError.

There is something called ByteCodeVerifier(Component of JVM), responsible to verify the loaded .class file i.e byte code. Due to this verify module JAVA is highly secure language. 

java.lang.VerifyError is the sub class of java.lang.linkageError

----------------------------------------------------------------
prepare : 
---------
[Static variable memory allocation + static variable initialization with default value even the variable is final]

It will allocate the memory for all the static data members, here all the static data member will get the default values so if we have static int x = 100; then for variable x  memory will be allocated (4 bytes) and now it will initialize with default value i.e 0, even the variable is final.

static Test t = new Test();

Here, t is a static reference variable so for t variable (reference variable) memory will be allocated as per JVM implementation i.e for 32 bit JVM (4 bytes of Memory) and for 64 bit (8 bytes of memory) and initialized with null.
----------------------------------------------------------------
Resolve :
---------
All the symbolic references (#7) will be converted into direct references OR actual reference.

javap -verbose  FileName.class

Note :- By using above command we can read the internal details of .class file.
-----------------------------------------------------------------
04-10-2024
-----------
Initialization :
-----------------
Here class initialization will takes place. All the static data member will get their actual/original value and we can also use static block for static data member initialization.

Here, In this class initialization phase static variable and static block is having same priority so it will executed according to the order.(Top to bottom)

-------------------------------------------------------------
Static Block in java :
-----------------------
It is a special block in java which is automatically executed at the time of loading the .class file.

Example :

static
{

}

Static blocks are executed only once because in java we can load the .class files only once.

If we have more than one static block in a class then it will be executed according to the order [Top to bottom]


The main purpose of static block to initialize the static data member of the class so it is also known as static initializer.


In java, a class is not loaded automatically, it is loaded based on the user request so static block will not be executed everytime, It depends upon whether class is loaded or not. 

static blocks are executed before the main or any static method.

A static blank final field must be initialized inside the static block only.

static final int A;   //static blank final field

static
{
   A = 100;
}

A static blank final field also have default value.

We can't write any kind of return statement inside static block.

If we don't declare static variable before static block body execution then we can perform write operation(Initialization is possible due to prepare phase) but read operation is not possible directly otherwise we will get an error Illegal forward reference, It is possible with class name bacause now compiler knows that variable is coming from class area OR Method area.

Example :

static 
{
   x = 100; //Valid
   System.out.println(x); //Invalid
    System.out.println(ClassName.x); //valid
}
static int x;

If we directly perform direct read and write operation inside a static method.

public static void m1()
{
   y = 200; //Valid
   System.out.println(y); //Valid
}

static int y;

--------------------------------------------------------------
//static block
class Foo
{	
	Foo()
	{
		System.out.println("No Argument constructor..");
	}

	{
		System.out.println("Instance block..");
	}
	static
	{
		System.out.println("Static block...");
	}
	
}
public class StaticBlockDemo 
{	
	public static void main(String [] args) 
	{ 			
        System.out.println("Main Method Executed ");		
	}
	 
}

Here Foo.class file is not loaded into JVM Memory so static block of Foo class will not be executed.
-------------------------------------------------------------
class Test
{
	static int x;

	static
	{
		x = 100;
		System.out.println("x value is :"+x);
	}
	
	static
	{
		x = 200;
		System.out.println("x value is :"+x);
	}

	static 
	{
		x = 300;
		System.out.println("x value is :"+x);
	}

	
}
public class StaticBlockDemo1   
{
	public static void main(String[] args) 
	{
		System.out.println("Main Method");
		System.out.println(Test.x);
	}
}


Note : If a class contains more than 1 static block then it will be executed from top to bottom.
--------------------------------------------------------------
class Foo
{	
	static int x;

    static
	{		
		System.out.println("x value is :"+x);
	}	
}

public class StaticBlockDemo2 
{
	public static void main(String[] args) 
	{
		 new Foo();
	}
}

Note : static variables are also having default value.
--------------------------------------------------------------
class Demo
{
	
	final static int a ;	//Blank static final field

	static
	{	
		a = 100;
		System.out.println(a); 
	}
}	
public class  StaticBlockDemo3
{
	public static void main(String[] args) 
		{		
	         System.out.println("a value is :"+Demo.a);		
	    }
}

Note : A blank static final field must be initialized through static block only.
--------------------------------------------------------------
class  A        
{
	static 
	{
		System.out.println("A");
	}
	 
	{
		System.out.println("B");
	}

	A() 
	{		
		System.out.println("C");
	}
}
class B extends A
{
	static 
	{
		System.out.println("D");
	}

	 
	{
		System.out.println("E");
	}

	B() 
	{		
		System.out.println("F");
	}

}
public class StaticBlockDemo4 
{
	public static void main(String[] args) 
	{
		new B();  
	}
}

Note : Always Parant class will be loaded first then only Child class will be loaded.
--------------------------------------------------------------
//illegal forward reference

class Demo 
{	
    static
	{   
		i = 100;		
	}

    static int i;
}

public class StaticBlockDemo5
{
    public static void main(String[] args) 
	{
        System.out.println(Demo.i);
	}
}

Note : For static variable i, already memory is allocated in the prepare phase so we can initialize (can perform write operation)
in the static block without pre-declaration.
--------------------------------------------------------------
class Demo 
{
    static 
	{   
		i = 100;
		//System.out.println(i); //Invalid
		System.out.println(Demo.i);
    }

    static int i;
}

public class StaticBlockDemo6
{

    public static void main(String[] args) 
	{
		System.out.println(Demo.i);
	}
}

Note : Without declaring the static variable if we try to access(read Operation) static variable value in the static block directly then we will get compilation error, we can access with the help of class name (Class Area) 
--------------------------------------------------------------
class StaticBlockDemo7 
{
	static 
	{
          System.out.println("Static Block");
	  return; 
	}

	public static void main(String[] args) 
	{
		System.out.println("Main Method");
	}
}

Note : We can't write return statement in static and non static block
----------------------------------------------------------
public class StaticBlockDemo8 
{
    final static int x; //Blank static final field

    static
	{
		m1();
		x = 15;
	}

    public static void m1()
	{
		System.out.println("Default value of x is :"+x);
	}

	public static void main(String[] args) 
	{
		System.out.println("After initialization :"+StaticBlockDemo8.x);
	}
}

A blank static final field also has default value.
--------------------------------------------------------------
class Test
{ 

   public static final Test t1 = new Test();  //t1 = null  

   static
	{
	   System.out.println("static block");
	}

	{
	   System.out.println("Non static block");
	}

	Test()
	{
		super();
		System.out.println("No Argument Constructor");
	}
}

public class StaticBlockDemo9 
{
	public static void main(String[] args) 
	{
		new Test();
	}
}

Note : First non static block, constructor then only static block will be executed.
--------------------------------------------------------------
Variable Memory Allocation and Initialization :
-------------------------------------------------
1) static field OR Class variable : 
-----------------------------------
Memory allocation done at prepare phase of class loading and initialized with default value even variable is final.

It will be initialized with Original value (If provided by user at the time of declaration) at class initialization phase.

When JVM will shutdown then during the shutdown phase class will be un-loaded from JVM memory so static data members are destroyed. They have long life.

2) Non static field OR Instance variable 
-----------------------------------------
Memory allocation done at the time of object creation using new keyword (Instantiation) and initialized as a part of Constructor with default values even the variable is final. [Object class-> at the time of declaration -> instance block -> constructor]

When object is eligible for GC then object is destroyed and all the non static data memebers are also destroyed with corresponding object. It has less life in comparison to static data members becuase they belongs to object.

3) Local Variable 
------------------
Memory allocation done at stack area (Stack Frame) and developer is responsible to initialize the variable before use. Once metod execution is over, It will be deleted from stack Frame henec it has shortest life.

4) Parameter variable 
----------------------
Memory allocation done at stack area (Stack Frame)  and end user is responsible to pass the value at runtime. Once metod execution is over, It will be deleted from stack Frame henec it has shortest life.

Note : We can done validation only one parameter variables.
--------------------------------------------------------------
05-10-2024
-----------
Can we write a Java Program without main method ?
--------------------------------------------------
class WithoutMain
{
   static
   {
       System.out.println("Hello User!!");
       System.exit(0);
   }
}

It was possible to write a java program without main method till JDK 1.6V. From JDK 1.7v onwards, at the time of loading the .class file JVM will verify the presence of main method in the .class file. If main method is not available then it will generate a runtime error that "main method not found in so so class".
--------------------------------------------------------------
How many ways we can load the .class file into JVM memory :
-----------------------------------------------------------
There are so many ways to load the .class file into JVM memory but the following are the common examples :

1) By using java command

   public class Test
   {
   }

   javac Test.java
   java Test 

   Here we are making a request to class loader sub system to load Test.class file into JVM memory


2) By using Constructor (new keyword at the time of creating object).

3) By accessing static data member of the class.

4) By using inheritance 

5) By using Reflection API
==============================================================
//Program that describes we can load a .class file by using new keyword (Object creation) OR by accessing static data member of the class.

class Demo
{
	static int x = 10;
	static
	{
		System.out.println("Static Block of Demo class Executed!!! :"+x);
	}
}
public class ClassLoading 
{
	public static void main(String[] args) 
	{	
		System.out.println("Main Method");
		//new Demo();
	    System.out.println(Demo.x);	
	}
}
-------------------------------------------------------------
//Program that describes whenever we try to load sub class, first of all super class will be loaded. [before parent, child can't exist]

class Alpha
{
	static
	{
		System.out.println("Static Block of super class Alpha!!");
	}
}
class Beta extends Alpha 
{
	static
	{
		System.out.println("Static Block of Sub class Beta!!");
	}
}
class InheritanceLoading 
{
	public static void main(String[] args) 
	{
		 new Beta();
	}
}
--------------------------------------------------------------
Loading the .class file by using Reflection API :
-------------------------------------------------
java.lang.Class class has provided a predefined static factory method called forName(String className), It is mainly used to load the given .class file at runtime, The return type of this method is java.lang.Class

public static java.lang.Class forName(String className) throws 
ClassNotFoundException

Note : This method throws a checked execption i.e ClassNotFoundException 

Program :
---------
package com.nit.iq;  //FQN   com.nit.iq.Sample

class Sample
{
	static
	{
		System.out.println("Static Block");
	}
}
public class DynamicLoading 
{
	public static void main(String[] args) throws Exception
	{
		Class.forName("com.nit.iq.Sample"); //FQN
	}
}

NOte : From the above program it is clear that Class.forName(String className) is used to load the given .class file dynamically at runtime.
--------------------------------------------------------------
** What is the difference between java.lang.ClassNotFoundException and java.lang.NoClassDefFoundError 


java.lang.ClassNotFoundException :-
-----------------------------------------
It occurs when we try to load the required .class file at RUNTIME by using Class.forName(String className) statement or loadClass() static of ClassLoader class and if the required .class file is not available at runtime then we will get an exception i.e java.lang.ClassNotFoundException

Note :- It does not have any concern at compilation time, at run time, JVM will simply verify whether the required .class file is available or not available.

class Test
{
	static
	{
		System.out.println("Static Block");
	}
}
public class DynamicLoading 
{
	public static void main(String[] args) throws Exception
	{
		Class.forName("Employee");  
	}
}

Note : Here we will get java.lang.ClassNotFoundException because at runtime class loader is unable to find Employee.class.
--------------------------------------------------------------
java.lang.NoClassDefFoundError :
--------------------------------
It occurs when the class was present at the time of COMPILATION but at runtime the required .class file is not available(manualy deleted by user ) Or it is not available in the current directory (Misplaced) then we will get a runtime error i.e java.lang.NoClassDefFoundError.

class Sample
{
	public void greet()
	{
		System.out.println("Hello Everyone");
	}
}
public class NoClassDefFoundErrorDemo 
{
	public static void main(String[] args) 
	{
		Sample s1 = new Sample();
		s1.greet();
	}
}


After compilation either delete Sample.class or put this .class file in another folder[remove from the current folder]
--------------------------------------------------------------
** A static method does not act on instance variable directly why?
 
 All the static members (static variable, static block, static method, static nested inner class) are loaded/executed at the time of loading the .class file into JVM Memory.

At class loading phase object is not created because object is created in the 2nd phase i.e Runtime data area so at the TIME OF EXECUTION OF STATIC METHOD AT CLASS LOADING PAHSE, NON STATIC VARIABLE WILL NOT BE AVAILABLE BY DEFAULT henec we can't access non static variable from static context[static block, static method and static nested inner class] without creating the object.
  
class Sample 
{
	private int x;
	public Sample(int x)
	{
		this.x = x;
	}
	
	public static void access()
	{
	   System.out.println("x value is :"+x);	
	}
	
}
public class StaticDemo 
{
	public static void main(String[] args) 
	{
		Sample s1 = new Sample(10);
		Sample.access();
	}
}
  
-------------------------------------------------------------- 
07-10-2024
-----------
Runtime Data Areas :
---------------------
It is also known as Memory Area.

Once a class is loaded then based on variable type method type it is divided into different memory areas which are as follows :

1) Method Area 
2) HEAP Area
3) Stack Area
4) PC Register
5) Native Method Stack

Method Area :
-------------
Whenever a class is loaded then the class is dumpped inside method area and returns java.lang.Class class object.

It provides all the information regarding the class, like name of the class, name of the package, static and non static fields available in the class, methods available in the class and so on.

We have only one method area per JVM that means for a single JVM we have only one Method area.

This Method Area OR Class Area is sharable by all the objects.
--------------------------------------------------------------
Program to Show From Method Area we can get complete information of the class. (Reflection API)

2 files :
---------
Test.java
----------
package com.ravi.method_area;

import java.util.Scanner;

public class Test
{
   Scanner sc = new Scanner(System.in);
   int x = 100;
   int z = 900;
   static int y = 200;
   static Scanner scanner = new Scanner(System.in);
   
   public static void show() {}
   public static void m1() {}
   public void accept() {}
   public void display() {}  
   
   
}

ClassDescription.java
-----------------------
package com.ravi.method_area;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class ClassDescription {

	public static void main(String[] args) throws Exception
	{
		Class cls = Class.forName(args[0]);
		
		System.out.println("Class Name is :"+cls.getName());
		
		System.out.println("Package Name is :"+cls.getPackageName());
		
         System.out.println("Available Methods are :");
         int count = 0;
		 Method[] methods = cls.getDeclaredMethods();
		 
		 for(Method method : methods)
		 {
			 System.out.println(method.getName());
			 count++;
		 }
		System.out.println("Total number of methods are :"+count);
         
         System.out.println("Available Fileds are :");
 
           Field[] fields = cls.getDeclaredFields();
           count = 0;
           for(Field field : fields)
           {
        	   System.out.println(field.getName());
        	   count++;
           }	
           System.out.println("Total number of fields are :"+count);

	}

}


Note :- getDeclaredMethods() is a predefined non static method available in java.lang.Class class , the return type of this method is Method array where Method is a predefined class available in java.lang.reflect sub package.

public Method[]  getDeclaredMethods()

getDeclaredFields() is a predefined non static method available in java.lang.Class class , the return type of this method is Field array where Field is a predefined class available in java.lang.reflect sub package.

public Field[]  getDeclaredFields()

Field and Method both the classes are providing getName() method to get the name of the field and Method.
--------------------------------------------------------------
HEAP AREA :
-----------
Whenever we create an object in java then the properties and behavior of the object are strored in a special memory area called HEAP AREA.

We have only one HEAP AREA per JVM.
--------------------------------------------------------------
STACK Area :
------------
All the methods are executed as a part of Stack Area.

Whenever we call a method in java then internally one stack Frame will be created to hold method related information.

Every Stack frame contains 3 parts :
1) Local Variable arrays
2) Frame Data
3) Operand Stack.

We have multiple stack area for a single JVM.

Everytime we create a thread in java then JVM will create a separate Runtime Stack.[Multithreading]
-------------------------------------------------------------
HEAP and STACK Diagram for Static data member and array variables.

class Alpha
{
	int val;

	static int sval = 200;
	static Beta b = new Beta();

	public Alpha(int val)
	{
      this.val = val;
	}
}

public class Beta     
{
	public static void main(String[] args) 
	{
		Alpha am1 = new Alpha(9);
		Alpha am2 = new Alpha(2);

		Alpha []ar = fill(am1, am2); 

		ar[0] = am1; 
        System.out.println(ar[0].val); 
        System.out.println(ar[1].val);
	}

	public static Alpha[] fill(Alpha a1, Alpha a2)
	{
		a1.val = 15;   

        Alpha fa[] = new Alpha[]{a2, a1}; 
			
		return fa;
	}
}
--------------------------------------------------------------
08-10-2024
-----------
PC Register :
-------------
It stands for Program counter Register.

In order to hold the current executing instruction of running thread we have separate PC register for each and every thread.
----------------------------------------------------------------
Native Method Stack :
----------------------
Native method means, the java methods which are written by using native languages like C and C++. In order to write native method we need native method library support.

Native method stack will hold the native method information in a separate stack.
---------------------------------------------------------------------
Execution Engine : [Interpreter + JIT Compiler]

Interpreter 
------------
In java, JVM contains an interpreter which executes the program line by line. Interpreter is slow in nature because at the time of execution if we make a mistake at line number 9 then it will throw the execption at line number 9 and after solving the execption again it will start the execution from line number 1 so it is slow in execution that is the reason to boost up the execution java software people has provided JIT compiler.

JIT Compiler :
--------------
It stands for just in time compiler. The main purpose of JIT compiler to boost up the execution so the execution of the program will be completed as soon as possible.

JIT compiler holds the repeated instruction like method signature, variables, native method code and make it available to JVM at the time of execution so the overall execution becomes very fast.
--------------------------------------------------------------
HAS-A Relation :
----------------
If we use any class (Engine class) as a property to another class (Car class) then it is called HAS-A relation.

class Engine
{
}

class Car
{
   private Engine engine;  //HAS-A relation
}


Association :
---------------
Association is a connection between two separate classes that can be built up through their Objects. 

The association builds a relationship between the classes and describes how much a class knows about another class. 

This relationship can be unidirectional or bi-directional. In Java, the association can have one-to-one, one-to-many, many-to-one and many-to-many relationships.

Example:-
One to One: A person can have only one PAN card
One to many: A Bank can have many Employees
Many to one:  Many employees can work in single department 
Many to Many: A Bank can have multiple customers and a customer can have multiple bank accounts.

3 files :
----------
Student.java
-------------
package com.ravi.association;

public class Student 
{
	private int studentId;
	private String studentName;
	private int studentMarks;

	public Student(int studentId, String studentName, int studentMarks) 
	{
		super();
		this.studentId = studentId;
		this.studentName = studentName;
		this.studentMarks = studentMarks;
	}

	@Override
	public String toString() {
		return "Student [studentId=" + studentId + ", studentName=" + studentName + ", studentMarks=" + studentMarks
				+ "]";
	}

	public int getStudentId() {
		return studentId;
	}

	public String getStudentName() {
		return studentName;
	}

	public int getStudentMarks() {
		return studentMarks;
	}
}

Trainer.java
-------------
package com.ravi.association;

import java.util.Scanner;

public class Trainer 
{
  public static void viewStudentProfile(Student obj)
  {
	  Scanner sc = new Scanner(System.in);
	  System.out.print("Enter Student id :");
	  int id = sc.nextInt();
	  
	  if(id==obj.getStudentId())
	  {
		  System.out.println(obj);
	  }
	  else
	  {
		  System.err.println("Id is not matching");
	  } 
  }
}


AssociationDemo.java
----------------------
package com.ravi.association;

public class AssociationDemo {

	public static void main(String[] args) 
	{
	   Student raj = new Student(1, "Raj",70);
	   Trainer.viewStudentProfile(raj);
	}

}
--------------------------------------------------------------
Composition (Strong reference) :
--------------------------------
Composition in Java is a way to design classes such that one class contains an object of another class. It is a way of establishing a "HAS-A" relationship between classes.

Composition represents a strong relationship between the containing class and the contained class.If the containing object (Car object) is destroyed, all the contained objects (Engine object) are also destroyed.

A car has an engine. Composition makes strong relationship between the objects. It means that if we destroy the owner object, its members  will be also destroyed with it. For example, if the Car is destroyed the engine will also be destroyed as well.

Program Guidelines :
--------------------
One object can't exist without another object
We will not create two separate objects

3 files :
----------
Engine.java
------------
package com.ravi.composition;

public class Engine 
{
	private String engineType;
	private int horsePower;

	public Engine(String engineType, int horsePower) {
		super();
		this.engineType = engineType;
		this.horsePower = horsePower;
	}

	public String getEngineType() {
		return engineType;
	}

	public void setEngineType(String engineType) {
		this.engineType = engineType;
	}

	public int getHorsePower() {
		return horsePower;
	}

	public void setHorsePower(int horsePower) {
		this.horsePower = horsePower;
	}

	@Override
	public String toString() {
		return "Engine [engineType=" + engineType + ", horsePower=" + horsePower + "]";
	}
}


Car.java
---------
package com.ravi.composition;

public class Car 
{
	private String carName;
	private int carModel;
	private final Engine engine; // HAS-A relation [Blank final filed]
	
	public Car(String carName, int carModel)
	{
		super();
		this.carName = carName;
		this.carModel = carModel;
		this.engine = new Engine("Battery", 1200);  //Composition		
	}

	@Override
	public String toString() {
		return "Car [carName=" + carName + ", carModel=" + carModel + ", engine=" + engine + "]";
	}

}

CompositionDemo.java
---------------------
package com.ravi.composition;

public class CompositionDemo {

	public static void main(String[] args) 
	{
		Car car = new Car("Seltos", 2024);
		System.out.println(car);
	}

}


Assignemnts :
--------------
Develop one program based on composition
MotherBoard and Laptop
Department and University.
--------------------------------------------------------------
Aggregation (Weak Referance) :
------------------------------
Aggregation in Java is another form of association between classes that represents a "HAS-A" relationship, but with a weaker bond compared to composition. 

In aggregation, one class contains an object of another class, but the contained object can exist independently of the container. If the container object is destroyed, the contained object can still exist.

3 files :
----------
College.java
-------------
package com.ravi.aggregation;

public class College 
{
	private String collegeName;
	private String collegeLocation;

	public College(String collegeName, String collegeLocation) {
		super();
		this.collegeName = collegeName;
		this.collegeLocation = collegeLocation;
	}

	@Override
	public String toString() {
		return "College [collegeName=" + collegeName + ", collegeLocation=" + collegeLocation + "]";
	}
}


Student.java
-------------
package com.ravi.aggregation;

public class Student 
{
	private int studentId;
	private String studentName;
	private String studentAddress;
	private College college;

	public Student(int studentId, String studentName, String studentAddress, College college) {
		super();
		this.studentId = studentId;
		this.studentName = studentName;
		this.studentAddress = studentAddress;
		this.college = college;
	}

	@Override
	public String toString() {
		return "Student [studentId=" + studentId + ", studentName=" + studentName + ", studentAddress=" + studentAddress
				+ ", college=" + college + "]";
	}
}


AggregationDemo.java
---------------------
package com.ravi.aggregation;

public class AggregationDemo {

	public static void main(String[] args) 
	{
		College clg = new College("VIT", "Vellore");
				
		Student s1 = new Student(1, "A", "Ameerpet", clg);
		System.out.println(s1);

		
		Student s2 = new Student(2, "B", "S.R Nagar", clg);
		System.out.println(s2);
		
	}

}

Note :- IS-A relation is tightly coupled relation so if we modify the content of super class, sub class content will also modify but in HAS-A realtion we are accessing the properties of another class so we are not allowed to modify the content, we can access the content or Properties.
-------------------------------------------------------------
Assignemnts :
-------------
Order and Customer
Person and Address
Account and Customer
--------------------------------------------------------------
Description of System.out.println() :
-------------------------------------
public class System
{
   public final static java.io.PrintStream out = null;  //HAS-A Relation
}


System.out.println();

Internally System.out.println() creates HAS-A relation because System class contains a predefined class called java.io.PrintStream as shown in the above example.

The following program describes that how System.out.println() works internally :

package com.nit.m1;

class Hello
{
	public static String out = "Hyderabad";  //HAS-A Relation
}

public class HasADemo {

	public static void main(String[] args) 
	{
		System.out.println(Hello.out.length());
	}

}
--------------------------------------------------------------
***Polymorphism :
-----------------
Poly means "many" and morphism means "forms".

It is a Greek word whose meaning is "same object having different behavior".

In our real life a person or a human being can perform so many task, in the same way in our programming languages a method or a constructor can perform so many task.

Eg:-

void add(int a, int b)

void add(int a, int b, int c)

void add(float a, float b)

void add(int a, float b)

--------------------------------------------------------------
09-10-2024
-----------
Types of Polymorphism :
-----------------------
Polymorphism can be divided into two types :

1) Static polymorphism OR Compile time polymorphism OR Early binding

2) Dynamic Polymorphism OR Runtime polymorphism OR Late binding
----------------------------------------------------------------
1) Static Polymorphism :
------------------------
The polymorphism which exist at the time of compilation is called Static OR compile time polymorphism.

In static polymorphism, compiler has very good idea that which method is invoked depending upon METHOD PARAMETER.

Here the binding of the method is done at compilation time so, it is known as early binding.

We can achieve static polymorphism by using Method Overloading concept.

Example of static polymorphism : Method Overloading.


2) Dynamic Polymorphism 
-----------------------
The polymorphism which exist at runtime is called Dynamic polymorphim Or Runtime Polymorphism.

*Here compiler does not have any idea about method calling, at runtime JVM will decide which method will be invoked depending upon CLASS TYPE OBJECT.

Here method binding is done at runtime so, it is also called Late Binding.

We can achieve dynamic polymorphism by using Method Overriding.

Example of Dynamic Polymorphism : Method Overriding

-----------------------------------------------------------------
Method Overloading :
--------------------
Writing two or more methods in the same class or even in the super and sub class in such a way that the method name must be same but the argument must be different.

While Overloading a method we can change the return type of the method.

If parameters are same but only method return type is different then it is not an overloaded method.

Method overloading is possible in the same class as well as super and sub class.

While overloading the method the argument must be different otherwise there will be ambiguity problem.

Method Overloading allows us to write two methods with same name but differ in:
1. Number of parameters
2. Data type of parameters
3. Sequence/Order of data type of parameters(int -long and long int)

IQ :
----
Can we overload the main method/static method ?

Yes, we can overload the main method OR static method but the execution of the program will start from main method which accept String [] array as a parameter.

Note :- The advantage of method overloading is same method name we can reuse for different functionality for refinement of the method.

Note :- In System.out.println() or System.out.print(), print()
        and println() methods are best example for Method Overloading.
	
Example :
----------
public void makePayment(Cash c)
{
}
public void makePayment(UPI c)
{
}
public void makePayment(CreditCard c)
{
}
-----------------------------------------------------------------
2 files :
----------
Addition.java
-------------
//Program on Constructor Overloading
package com.ravi.constructor_overloading;

public class Addition 
{
		
   public Addition(int x, int y)
   {	
	   this(10,20,30);
	   System.out.println("Sum of two integer is :"+(x+y));
   }
   
   public Addition(int x, int y, int z)
   {  
	   this(2.3F, 8.9f);
	   System.out.println("Sum of three integer is :"+(x+y+z));
   }
   
   public Addition(float x, float y)
   {
	   System.out.println("Sum of two float is :"+(x+y));
   }   
  
}

Main.java
---------
package com.ravi.constructor_overloading;

public class Main {

	public static void main(String []  args) 
	{
		new Addition(12,90);
	}

}
-----------------------------------------------------------------
Program on Method Overloading :
-------------------------------
2 Files :
---------

Sum.java
---------
package com.ravi.method_overload;

public class Sum
{
 public int add(int x, int y)
 {
	return x + y; 
 }
 
 public String add(String x, String y)
 {
	 return x + y;
 }
 
 public double add(double x, double y)
 {
	 return x + y;
 }
 
 
}
  
 
Main.java
----------
package com.ravi.method_overload;

public class Main 
{
	public static void main(String[] args) 
	{
		Sum s = new Sum();
		double add1 = s.add(2.6, 7.8);
		System.out.println("Addition of two double is :"+add1);
		
		String add2 = s.add("Data", "base");
		System.out.println("Concatenation of two String :"+add2);
		
		int add3 = s.add(12, 24);
		System.out.println("Addition of two integer :"+add3);
	}
}
---------------------------------------------------------------
14-10-2024
-----------
Var-Args :
------------
It was introduced from JDK 1.5 onwards.

It stands for variable argument. It is an array variable which can hold 0 to n number of parameters of same type or different type by using Object class.

It is represented by exactly 3 dots (...) so it can accept any number of argument (0 to nth) that means now we need not to define method body again and again, if there is change in method parameter value.

var-args must be only one and last argument.

We can use var-args as a method/Constructor parameter only.
---------------------------------------------------------------
The program says var args can accept 0 to n number of parameters.

2 files :
----------
Test.java
----------
package com.ravi.var_args;

public class Test 
{
  public void accept(int ...x)
  {
	  System.out.println("Var Args executed");
  }
}

Main.java
----------
package com.ravi.var_args;

public class Main 
{ 
   public static void main(String... args)
   {	   
	 Test t1 = new Test();
	 t1.accept();
	 t1.accept(12);
	 t1.accept(12,89);
	 t1.accept(12,78,56);
   }
	
}
---------------------------------------------------------------
//Program to add sum of parameters passes inside a method using var args

2 files :
---------
Test.java
---------
package com.ravi.var_args1;

public class Test 
{
   public void sumOfParameters(int... values)
   {
	   int sum = 0;
	   
	   for(int value : values)
	   {
		   sum = sum + value;
	   }
	   System.out.println("Sum of parameter is :"+sum);
	   
   }
}



Main.java
---------
package com.ravi.var_args1;

public class Main 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test();
		t1.sumOfParameters(12,24,24);
		t1.sumOfParameters(100,200,300);

	}

}
---------------------------------------------------------------
Program that describes Var args must be only one and last argument .

2 files :
---------
Test.java
---------
package com.ravi.var_args2;

public class Test 
{
	// All commented codes are invalid
	
	/*
	 * public void accept(float ...x, int ...y) { }
	 * 
	 * public void accept(int ...x, int y) { }
	 * 
	 * public void accept(int...x, int ...y) {}
	 */
	  
	 
	public void accept(int x, int... y) // 
	{
		System.out.println("x value is :" + x);
		
		for (int z : y) 
		{
			System.out.println(z);
		}
	}
}

Main.java
---------
package com.ravi.var_args2;

public class Main {

	public static void main(String[] args) 
	{
		new Test().accept(12, 10,20,30,40);

                 
	}
}
---------------------------------------------------------------
//Program to show that var args can hold hetrogeneous elements

Test.java
----------
package com.ravi.var_args3;

public class Test 
{
   public void acceptHetro(Object ...obj)
   {
	   for(Object o : obj)
	   {
		   System.out.println(o);
	   }
   }
}

Main.java
---------
package com.ravi.var_args3;

public class Main {

	public static void main(String[] args) 
	{	
	  new Test().acceptHetro(true,45.90,12,'A', new String("Ravi")); 
		
	}

}
---------------------------------------------------------------
Wrapper classes in java :
-------------------------
We have 8 primitive data types in java i.e byte, short, int, long and so on.

Except these 8 primitive data types, everything in java is an object.

If we remove these 8 primitive data types then only java can become pure object oriented language.

On these primitive data types, we can't assign null or we can't invoke a method.

These primitive data types are unable to move in the network, only objects are moving in the network.

We can't perform serialization and object cloning on primitive data types.

To avoid the above said problems, From JDK 1.5v, java software people has provided the following two concepts :

a) Autoboxing
b) Unboxing

Autoboxing 
--------------
When we convert the primitive data types into corresponding wrapper object then it is called Autoboxing as shown below.

Primitive type		Wrapper Object
----------------             ------------------
byte			-	Byte
short			-	Short
int			-	Integer
long			-	Long
float			-	Float
double			-	Double
char			-	Chracter
boolean			-	Boolean 

Note : ALL THE WRAPPER CLASSES ARE IMMUTABLE(UN-CHANGED) AS WELL AS equals(Object obj) and hashCode() method is overridden 
in all the Wrapper classes.
---------------------------------------------------------------
//Integer.valueOf(int);
public class AutoBoxing1
{
	public static void main(String[] args) 
	{
		int a = 12;
		Integer x = Integer.valueOf(a); //Upto 1.4 version
		System.out.println(x);

		
                int y = 15;
		Integer i = y;   //From 1.5 onwards compiler takes care
		System.out.println(i);		
	}
}
--------------------------------------------------------------
public class AutoBoxing2
	{  
		public static void main(String args[])
			{  
			   byte b = 12;
	   Byte b1 = Byte.valueOf(b);
	   System.out.println("Byte Object :"+b1);
	   
	   short s = 17;
	   Short s1 = Short.valueOf(s);
	   System.out.println("Short Object :"+s1);
	   
	   int i = 90;
	   Integer i1 = Integer.valueOf(i);
	   System.out.println("Integer Object :"+i1);
	   
	  	long g = 12;
		Long h =  Long.valueOf(g);
		System.out.println("Long Object :"+h);
		
		float f1 = 2.4f;
		Float f2 = Float.valueOf(f1);
		System.out.println("Float Object :"+f2);
		
		double k = 90.90;
		Double l = Double.valueOf(k);
		System.out.println("Double Object :"+l);
		
		char ch = 'A';
		Character ch1 = Character.valueOf(ch);
		System.out.println("Character Object :"+ch1);
		
		boolean x = true;
		Boolean x1 = Boolean.valueOf(x);
		System.out.println("Boolean Object :"+x1);
	   
	   
        }   
}  
In the above program we have used 1.4 approach so we are converting primitive to wrapper object manually.
--------------------------------------------------------------
Overloaded valueOf() method :
-----------------------------
1) public static Integer valueOf(int x) : It will convert the given int value into Integer Object.

2) public static Integer valueOf(String str) : It will convert
   the given String into Integer Object.
   [valueOf() method will convert the String into Wrapper object where as parseInt() method will convet the String into primitive type]

3) public static Integer valueOf(String str, int radix/base) :
   It will convert the given String number into Integer object 
   by using the specified radix or base.

 Note :- We can pass base OR radix upto 36
i.e A to Z (26) + 0 to 9 (10) -> [26 + 10 = 36], It can be 
calculated by using Character.MAX_RADIX.
Output will be generated on the basis of radix

//Integer.valueOf(String str)
//Integer.valueOf(String str, int radix/base)
public class AutoBoxing3 
{
	public static void main(String[] args) 
	{
			Integer a = Integer.valueOf(15);
			
			Integer b = Integer.valueOf("25");

            Integer c = Integer.valueOf("111",36); //Here Base we can take upto 36

			System.out.println(a);
			System.out.println(b);
			System.out.println(c);
			
           
	}
}
---------------------------------------------------------------
public class AutoBoxing4 
{
	public static void main(String[] args) 
	{
		Integer i1 = new Integer(100);
		Integer i2 = new Integer(100);
		System.out.println(i1==i2);

		Integer a1 = Integer.valueOf(15);
		Integer a2 = Integer.valueOf(15);
		System.out.println(a1==a2);
	}
}

--------------------------------------------------------------
Converting primtive to String type :
------------------------------------
Integer class has provided a static method toString() which will convert the int value into String type.

//Converting integer value to String
public class AutoBoxing5 
{
	public static void main(String[] args) 
	{
		int x = 12;
		String str = Integer.toString(x);
		System.out.println(str+2);
	}
}
---------------------------------------------------------------
15-10-2024
-----------
Unboxing :
----------------
Converting wrapper object to corresponding primitive type is called Unboxing.

Wrapper            Primitive
Object               type               
----------            ----------
Byte		-	byte

Short		-	short

Integer		-	int

Long		-	long

Float		-	float

Double		-	double

Chracter	-	char

Boolean		-	boolean
-----------------------------------------------------------------
We have total 8 Wrapper classes.

Among all these 8, 6 Wrapper classes (Byte, Short, Integer, Long, Float and Double) are the sub class of Number class which represent numbers (either decimal OR non decimal)
so all the following six wrapper classes (Which are sub class of Number class) are providing the following common methods.

1) public byte byteValue()

2) public short shortValue()

3) public int intValue()

4) public long longValue()

5) public float floatValue()

6) public double doubleValue()
--------------------------------------------------------------
//Converting Wrapper object into primitive
public class AutoUnboxing1
{  
   public static void main(String args[])
	   {  
            Integer obj = 15;   //Upto 1.4
			int x = obj.intValue();
			System.out.println(x);
		}   
}  
--------------------------------------------------------------
public class AutoUnboxing2
{
	public static void main(String[] args) 
	{	
			Integer x = 25; 
			int y = x;        //JDK 1.5 onwards  
			System.out.println(y);  
	}
}
---------------------------------------------------------------
public class AutoUnboxing3
{
	public static void main(String[] args) 
	{	
			Integer i = 15;
			System.out.println(i.byteValue());
			System.out.println(i.shortValue());
			System.out.println(i.intValue());
			System.out.println(i.longValue());
			System.out.println(i.floatValue());
			System.out.println(i.doubleValue());			
	}
}
---------------------------------------------------------------
public class AutoUnboxing4
{
	public static void main(String[] args) 
	{
		Character c1 = 'A';
		char ch = c1.charValue();
		System.out.println(ch);
	}
}
---------------------------------------------------------------
public class AutoUnboxing5
{
	public static void main(String[] args) 
	{
		Boolean b1 = true;
		boolean b = b1.booleanValue();
		System.out.println(b);
	}
}
--------------------------------------------------------------
Unlike primitive types we can't convert one wrapper type object to another wrapper object.

Example :

Long l = 12;  //Invalid

Float f = 90; //Invalid

Double d = 123; //Invalid

package com.ravi.basic;

public class Conversion 
{
	public static void main(String[] args) 
	{
	  long l = 12; //Implicit OR Widening	  
	  byte b = (byte) 12L; //Explicit OR Narrowing
	  
	  Long a = 12L;
	  Double d = 90D;
	  Double d1 = 90.78;
	  Float f = 12F;
	}

}
---------------------------------------------------------------
Ambiguity issue while overloading a method :
---------------------------------------------
When we overload a method then compiler is selecting appropriate method among the available methods based on the following types.

1. Different number of parameters 
2. Different data type of parameters 
3. Different sequence(order) of data type of parameters

In case of ambiguity where compiler can select more than one method then compiler will provide the priority in the following
order :

1) Most Specific Type :
-----------------------
Compiler alwyas provide more priority to most specific data type or class type.

double > float [Here float is the most specific type]
float > long 
long > int
int > char
int > short  //[No relation between short and char]
short > byte

2) WAV [Widening ->  Autoboxing  -> Var Args]

   Compiler gives the priority to select appropriate method by using the following sequence :
   Widening ---> Autoboxing  ----> Var args

3) Nearest Data type or Nearest class (sub class) 
   
   While selecting the appropriate method in ambiguity issue compiler provides priority to nearest data type or nearest class i.e sub class
---------------------------------------------------------------
class Test
{
	public void accept(double d)
	{
		System.out.println("double");
	}
	public void accept(float d)
	{
		System.out.println("float");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept(6);

	}
}

Here float will be executed because float is the nearest type.
--------------------------------------------------------------
class Test
{
	public void accept(int d)
	{
		System.out.println("int");
	}
	public void accept(char d)
	{
		System.out.println("char");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept(6);



	}
}

Here int will be executed because int is the nearest type.
--------------------------------------------------------------
class Test
{
	public void accept(int ...d)
	{
		System.out.println("int");
	}
	public void accept(char ...d)
	{
		System.out.println("char");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept();
	}
}

Here char will be executed because char is the most specific type
--------------------------------------------------------------
class Test
{
	public void accept(short ...d)
	{
		System.out.println("short");
	}
	public void accept(char ...d)
	{
		System.out.println("char");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept();
	}
}
Here we will get compilation error because there is no relation between char and short based on the specific type rule.
--------------------------------------------------------------
class Test
{
	public void accept(short ...d)
	{
		System.out.println("short");
	}
	public void accept(byte ...d)
	{
		System.out.println("byte");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept();
	}
}

Here byte will be executed because byte is the specific type.
--------------------------------------------------------------
class Test
{
	public void accept(double ...d)
	{
		System.out.println("double");
	}
	public void accept(long ...d)
	{
		System.out.println("long");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept();
	}
}
Here long will be executed because long is the most specific type.
--------------------------------------------------------------
class Test
{
	public void accept(byte d)  
	{
		System.out.println("byte");
	}
	public void accept(short s)
	{
		System.out.println("short");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t1 = new Test();
		t1.accept(15);
		t1.accept(byte(15));
	}
}
Here value 15 is of type int so, we can't assign directly to byte and short, If we want, explicit type casting is reqd.
---------------------------------------------------------------
class Test
{
	public void accept(int d)
	{
		System.out.println("int");
	}
	public void accept(long s)
	{
		System.out.println("long");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept(9);  

	}
}
Note : Here int will be executed because int is the nearest type
--------------------------------------------------------------
class Test
{
	public void accept(int d, long l)
	{
		System.out.println("int-long");
	}
	public void accept(long s, int i)
	{
		System.out.println("long-int");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept(9,9); 
	}
}
Here We will get ambiguity issue.
--------------------------------------------------------------
class Test
{
	public void accept(Object s)
	{
		System.out.println("Object");
	}
	public void accept(String s)
	{
		System.out.println("String");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept(9);  

	}
}
Here Object will be executed
--------------------------------------------------------------
class Test
{
	public void accept(Object s)
	{
		System.out.println("Object");
	}
	public void accept(String s)
	{
		System.out.println("String");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept("NIT");
	}
}
Here String will be executed
--------------------------------------------------------------
class Test
{
	public void accept(Object s)
	{
		System.out.println("Object");
	}
	public void accept(String s)
	{
		System.out.println("String");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept(null);  

	}
}
String will executed because String is the nearest type.
--------------------------------------------------------------
class Test
{
	public void accept(Object s)
	{
		System.out.println("Object");
	}
	public void accept(String s)
	{
		System.out.println("String");
	}	
	public void accept(Integer i)
	{
		System.out.println("Integer");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept(null);        
    }
}
Here We will get compilation error
---------------------------------------------------------------
class Alpha
{
}
class Beta extends Alpha
{
}
class Test
{	
	public void accept(Alpha s)
	{
		System.out.println("Alpha");
	}	
	public void accept(Beta i)
	{
		System.out.println("Beta");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept(null);        

       
    }
}
Here Beta will be executed.
--------------------------------------------------------------
class Test
{	
	public void accept(Number s)
	{
		System.out.println("Number");
	}	
	public void accept(Integer i)
	{
		System.out.println("Integer");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept(12);        

	}
}

Here Integer will be executed.
--------------------------------------------------------------
class Test
{	
	public void accept(long s)
	{
		System.out.println("Widening");
	}	
	public void accept(Integer i)
	{
		System.out.println("Autoboxing");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept(12);        
    }
}
Here widening is having more priority
--------------------------------------------------------------
class Test 
{	
	public void accept(int ...s)
	{
		System.out.println("Var args");
	}	
	public void accept(Integer i)
	{
		System.out.println("Autoboxing");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept(12);        
     
    }
}
Here Autoboxing will be executed.
--------------------------------------------------------------
16-10-2024
-----------
***Method Overriding :
----------------------
Writing two or more non static methods in super and sub class in such a way that method name along with method parameter (Method Signature) must be same is called Method Overriding.

Method Overriding is not possible without inheritance.

Generally we can't change the return type of the method while overriding a method but from JDK 1.5v there is a concept called Co-variant (In same direction) through which we can change the 
return type of the method.

Example :
---------
class Super
{
	public void m1()
	{
	}
}
class Sub extends Super
{
	public void m1() //Overridden Method
	{
		
	}
}

Method overriding is mainly used to replacing the implementation 
of super class method by sub class method body.

Advantage of Method Overriding :
---------------------------------
The advantage of Method Overriding is, each sub class is specifying its own specific behavior.
---------------------------------------------------------------
**What is upcasting and downcasting ?
--------------------------------------
Upcasting :- 
------------
It is possble to assign sub class object to super class reference variable (up) using dynamic polymorphism. It is known as Upcasting.

Example:-    Animal a = new Lion();  //valid [upcasting]

Downcasting :
-------------
By default we can't assign super class object to sub class reference variable.

       Lion l = new Animal();  //Invalid

  Even if we type cast Animal to Lion type then compiler will allow but at runtime JVM will not convert Animal object (Generic type) into Lion object (Specific type) and it will throw an exception java.lang.ClassCastException

   Lion l = (Lion) new Animal(); //At runtime we will get
                                   java.lang.ClassCastException

Note : To avoid this ClassCastException we should use instanceof opertor.
-----------------------------------------------------------------
AnimalDemo.java
----------------
package com.ravi.mo;

class Animal
{
	public void eat()
	{
		System.out.println("Generic Animal is eating");
	}
}
class Lion extends Animal
{
	public void eat()
	{
		System.out.println("Lion Animal is eating");
	}
}
class Horse extends Animal
{
	public void eat()
	{
		System.out.println("Horse Animal is eating");
	}
}

public class AnimalDemo {

	public static void main(String[] args) 
	{
          Animal a1 = null;
          
          a1 = new Lion(); a1. eat();  //Dynamic Method Dispatch
          
          a1 = new Horse(); a1. eat(); //Dynamic Method Dispatch
          
	}

}
-----------------------------------------------------------------
@Override Annotation :
--------------------------
In Java we have a concept called Annotation, introduced from JDK 1.5 onwards. All the annotations must be start with @ symbol.

@Override annotation is metadata (Giving information that method is overridden) and it is optional but it is always a good practice to write @Override annotation before the Overridden method so compiler as well as user will get the confirmation that the method is overridden method and it is available in the super class.

If we use @Override annotation before the name of the overridden method in the sub class and if the method is not available in the super class then it will generate a compilation error so it is different from comments because comment will not generate any kind of compilation error if method is not an overridden method, so this is how it is different from comment.

package com.ravi.mo;

class Bird
{
	public void fly()
	{
		System.out.println("Genric Bird is flying");
	}
}
class Parrot extends Bird
{
	@Override
	public void fly()  
	{
		System.out.println("Parrot Bird is flying");
	}
}
class Peacock extends Bird
{
	@Override
	public void fly()  
	{
		System.out.println("Paecock Bird is flying");
	}
}


public class MethodOverridingDemo1 {

	public static void main(String[] args) 
	{
		Bird b = null;
		b = new Parrot(); b.fly();
		b = new Peacock(); b.fly();
	}

}
----------------------------------------------------------------
Method Overloading is also possible in super and sub class as shown below

package com.ravi.mo;

class Bird
{
	public void fly()
	{
		System.out.println("Genric Bird is flying");
	}
	
	public void roam()
	{
		System.out.println("Generic Bird is roamig");
	}
	
	
}
class Parrot extends Bird
{
	//Method Overloading
	public int fly(double height)
	{
		System.out.println("Parrot is flying with :"+height);
		return 0;
	}
	
	@Override
	public void roam()
	{
		System.out.println("Parrot Bird is roamig");
		
	}
}
public class MethodOverridingDemo1 {

	public static void main(String[] args) 
	{
		Parrot p = new Parrot();
		p.fly(15.6);
		p.roam();
	}

}
----------------------------------------------------------------
18-10-2024
-----------
Variable Hiding concept in upcasting :
---------------------------------------
class Super
{
   int x = 100;
 
}
class Sub exetnds Super
{
   int x = 200;  //Variable Hiding
}

Only non static methods are overridden in java but not the variables[variables are not overridden in java] because behavior will change but not the property(variable).

Note : In upcasting, variable will be always executed besed on the current reference class variable.


Note : static variable, non static variable and static method 
       are always executed using current reference.


package com.ravi.method_overriding;

class Vehicle
{
	protected String name = "Generic Vehicle"; 
	
	public String run()
	{
		return "Generic Vehicle is running";
	}
}
class Car extends Vehicle
{
	protected String name = "Car Vehicle";  //Variable Hiding
	
	@Override
	public String run()
	{
		return "Car Vehicle is running";
	}
}
public class VariableHiding 
{
	public static void main(String[] args) 
	{
	   Vehicle v = new Car(); 
	   System.out.println(v.name+" : "+v.run());
	   
	   System.out.println(".................");
	   Car c1 = new Car();  
	   Vehicle v1 = c1;
	   System.out.println(c1.name +" : "+v1.name);
	   
	   
	   
	}
}
-----------------------------------------------------------------
Can we override private method ?
--------------------------------
No, We can't override private method because private methods are not visible (not available) to the sub class hence we can't override.

We can't use @Override annotation on private method of sub class because it is not overridden method, actually it is re-declared by sub class developer.

package com.ravi.method_overriding;

class Super
{
	private void m1()
	{
		System.out.println("Private method of super class");
	}
}
class Sub extends Super
{	
        //It is not an overridden method
	private void m1() //Re-declare m1 method is sub class
	{
		System.out.println("Private method of Sub class");
	}
}

public class PrivateMethodOverriding {

	public static void main(String[] args)
	{
		
	}

}


Note :- private method of super class is not available or not inherited in the sub class so if the sub class declare the method with same signature then it is not overridden method, actually it is re-declared in the sub class. 
-----------------------------------------------------------------
Role of access modifier while overriding a method :
---------------------------------------------------
While overriding the method from super class, the access modifier of sub class method must be greater or equal in comparison to access modifier of super class method otherwise we will get compilation error.

In terms of accessibility, public is greater than protected, protected is greater than default (public > protected > default)
[default < protected < public]

**So the conclusion is we can't reduce the visibility of the method while overriding a method.

Note :- private method is not availble (visible) in sub class so it is not the part of method overriding.

package com.ravi.method_overriding;

class RBI
{
	public void loan()
	{
		System.out.println("Instruction to provide loan");
	}
}
class SBI extends RBI
{
	@Override
	protected void loan() //error due to protected
	{
		System.out.println("SBI provides loan @ 9.2%");
	}
}
public class AccessibilityLevel {

	public static void main(String[] args) {
		RBI r = new SBI();
        r.loan();
	}
}

Note : We can't reduce the visibility.
----------------------------------------------------------------
Co-variant in java : 
--------------------
In general we cann't change the return type of method while overriding a method. if we try to change it will generate compilation error because in method overriding, return type of both the methods must be compaitable as shown in the program below.

class Animal
{
	public void sleep()
	{
	}
}

class Dog extends Animal
{
	@Override
	public int sleep()  //error 
	{
		return 0;
	}
}

public class MethodOverriding 
{
	public static void main(String[] args) 
	{	
			
	}
}

Note : error, return type int is not compaitable with void.
----------------------------------------------------------------
But from JDK 1.5 onwards we can change the return type of the method in only one case that the return type of both the METHODS(SUPER AND SUB CLASS METHODS) MUST BE IN INHERITANCE RELATIONSHIP (IS-A relationship so it is compatible) called Co-Variant as shown in the program below.

Note :- Co-variant will not work with primitive data type, it will work only with classes.


class Alpha
{
}
class Beta extends Alpha
{
}

class Animal
{
	
	public Alpha sleep()
	{
		System.out.println("Sleep method of super class");
		return new Beta();
	}
}

class Dog extends Animal
{	
	@Override
	public Beta sleep()
	{
		System.out.println("Sleep method of Sub class");
		return null;
	}
}

public class CoVariantDemo1 
{
	public static void main(String[] args) 
	{	
		Animal a1 = new Dog();
		a1.sleep();
	}
}
-----------------------------------------------------------------
package com.ravi.method_return_type;

import java.io.IOException;

class Alpha
{
	public Object m1()
	{
		System.out.println("Super class m1 method");
		return new String();
	}
}
class Beta extends Alpha
{
	public Double m1()
	{
		System.out.println("Sub class m1 method");
		return null;
	}
}


public class CoVariant2 
{
	public static void main(String[] args) throws IOException  
	{
		Alpha a = new Beta();
		a.m1();
	}

}
----------------------------------------------------------------
21-10-2024
-----------
package com.ravi.co_variant;

class Vehicle
{
   public Vehicle run()
   {
	   System.out.println("Generic Vehicle is Running");
	   return this;
   }
}
class Car extends Vehicle
{
	 @Override
	 public Car run()
	 {
		   System.out.println("Car Vehicle is Running");
		   return this;
	 }
}

public class CoVariantDemo3 
{
	public static void main(String[] args) 
	{
		Vehicle vehicle = new Car();
		vehicle.run();

	}

}
----------------------------------------------------------------
While working with co-variant (In the same direction), sub class method return type object, if we can assign to super class  method return then only it is compatible and it is co-variant as shown in the program.

package com.ravi.co_variant;

class Bird
{
	public Object fly()
	{
		System.out.println("Generic Bird is flying");
		return null;
	}
}
class Sparrow extends Bird
{
	@Override
	public String fly()
	{
		System.out.println("Sparrow Bird is flying");
		return "NIT";
	}
}

public class CoVariantDemo4 {

	public static void main(String[] args) 
	{
		Bird b = new Sparrow();
		Object str = b.fly();
		System.out.println(str);

	}

}

Note : According to Liskov substitution principle (LSP), super class object can be replace by sub class object but to support co-variant (In the same direction) sub class object we can assign super class object i.e super class methdo return type i.e in one direction.
----------------------------------------------------------------
**What is Method Hiding in java ?
           OR
Can we override static method ?
           OR
Can we override main method ?


While working with method hiding we have all different cases :

Case 1 :
--------
A public static method of super class by default available to sub class so, from sub class we can call super class static method with the help of Class name as well as object reference as shown in the below program

class Super
{
	public static void m1()
	{
		System.out.println("Static Method of Super class..");
	}
}
class Sub extends Super
{
	
}

public class StaticMethodDemo1 
{
	public static void main(String[] args) 
	{
		Sub.m1();
		System.out.println("..........");
		Sub s1 = new Sub();
		s1.m1();
		
	}
}
----------------------------------------------------------------
Case 2 :
-------
We can't override a static method with non static method because static method belongs to class and non static method belongs to object, If we try to override static method with non static method then it will generate an error i.e overridden method is static as shown below.


class Super
{
	public static void m1()
	{
		System.out.println("Static Method of Super class..");
	}
}
class Sub extends Super
{
	public void m1() //error
	{
		System.out.println("Non Static Method of Sub class..");	
	}
	
}

public class StaticMethodDemo2 
{
	public static void main(String[] args) 
	{
		
		
	}
}
----------------------------------------------------------------
Case 3 :
--------
We can't override any non static method with static method, If we try then it will generate an error, Overriding method is static.

class Super
{
	public void m1()
	{
		System.out.println("Non Static Method of Super class..");
	}
}
class Sub extends Super
{
	public static void m1() //error
	{
		System.out.println("Static Method of Sub class..");	
	}	
}

public class StaticMethodDemo1 
{
	public static void main(String[] args) 
	{
		
		
	}
}

So, the conclusion is we cannot overide static with non static method as well as non-static with static method because static method belongs to class and non-static method belongs to object.
----------------------------------------------------------------
Case 4 :
-------
Program that describes method hiding as well as  sub class method can't hide super class method because return type is not compaitable

class Super
{
	public static void m1()
	{
		System.out.println("Non Static Method of Super class..");
	}
}
class Sub extends Super
{
	public static int  m1()
	{
		System.out.println("Static Method of Sub class..");	
		return 0;
	}	
}

public class StaticMethodDemo1 
{
	public static void main(String[] args) 
	{
		
		
	}
}

Note : sub class method can't hide super class method
===============================================================
Case 5 :
---------
We can't override static method because It belong to class but not object, If we write static method in the sub class with same signature and compaitable return type then It is Method Hiding but not Method Overriding here compiler will search the method of super class and JVM will also execute the method of super class because method is not overridden.[Single copy and belongs to class area and common for all the objects]

Note :- 1) We can't apply @Override annotation on static methods.

        2) Static methods can't be overridden so behavior is 
	   same for all the Objects hence it is Static Polymorphism.

class Animal
{
	public static void m1()
	{
		System.out.println("Animal");
	}
}
class Dog extends Animal
{
	//Method Hiding
	public static void  m1()
	{
		System.out.println("Dog");		
	}	
}

class Horse extends Animal
{
	//Method Hiding
	public static void  m1()
	{
		System.out.println("Horse");		
	}	
}
public class StaticMethodDemo1 
{
	public static void main(String[] args) 
	{
		Animal a = new Horse();
		a.m1();
	}
}

Note : Here we assign Dog object or Horse Object, Output will be same i.e Animal.

Note : static variable, instance variable and static method of super class are not overridden so we will get super class output.
----------------------------------------------------------------
Progrm that describes Polymorphic behaviour of sub classes :
-----------------------------------------------------------
package com.ravi.polymorphic_behavior;

class Animal
{
	public void sleep()
	{
		System.out.println("Generic Animal is sleeping");
	}
}
class Lion extends Animal
{
	@Override
	public void sleep()
	{
		System.out.println("Lion is sleeping");
	}
}
class Dog extends Animal
{
	@Override
	public void sleep()
	{
		System.out.println("Dog is sleeping");
	}
}
public class AnimalDemo 
{
	public static void main(String[] args) 
	{
		Animal lion = new Lion();
		Animal dog = new Dog();
		
		callSleepingAnimal(lion);
		callSleepingAnimal(dog);	
		
	}
	
	public static void callSleepingAnimal(Animal a1)
	{
		a1.sleep();
	}

}

Note : From above program it is clear that based on the runtime object appropriate method is invoked.
---------------------------------------------------------------
package com.ravi.polymorphic_behavior;

class Animal
{
	public void sleep()
	{
		System.out.println("Generic Animal is sleeping");
	}
}
class Lion extends Animal
{
	@Override
	public void sleep()
	{
		System.out.println("Lion is sleeping");
	}
	
	public void roar()
	{
		System.out.println("Lion is Roaring");
	}
	
}
class Dog extends Animal
{
	@Override
	public void sleep()
	{
		System.out.println("Dog is sleeping");
	}
	
	public void bark()
	{
		System.out.println("Dog is Barking");
	}
	
}

class Tiger extends Animal
{
	@Override
	public void sleep()
	{
		System.out.println("Tiger is sleeping");
	}
	
	public void roar()
	{
		System.out.println("Tiger is Roaring");
	}
	
}
public class AnimalDemo 
{
	public static void main(String[] args) 
	{
		Animal lion = new Lion();
		Animal dog = new Dog();
		
		callSleepingAnimal(lion);
		callSleepingAnimal(dog);		
		
	}
	
	public static void callSleepingAnimal(Animal a1)
	{
		 Lion lion = (Lion)a1;
		 lion.sleep(); lion.roar();
	}

}

Note : Here we will get java.lang.ClassCastException because Dog object can't be converted into lion type.
----------------------------------------------------------------
22-10-2024
-----------
package com.ravi.dynamic_method_dispatch;

class Person
{
	public int getAge()
	{
		return 32;
	}
	
	public void printInfo()
	{
		System.out.println(this.getAge());
	}	
}
class Student extends Person
{
	@Override
	public int getAge()
	{
		return 22;
	}
}
public class DynamicMethodDispatch 
{
	public static void main(String[] args)
	{
		new Student().printInfo();
	}

}
----------------------------------------------------------------
package com.ravi.dynamic_method_dispatch;

class Person
{
	public int getAge()
	{
		return 32;
	}
	
	public void printInfo()
	{
		System.out.println(this.getAge());
	}	
}
class Student extends Person
{
	@Override
	public int getAge()
	{		
		return 22;		
	}
	
	public void printInfo()
	{
		System.out.println(super.getAge());
	}	
	
	
}
public class DynamicMethodDispatch 
{
	public static void main(String[] args)
	{
		new Student().printInfo();
	}

}
---------------------------------------------------------------
package com.ravi.dynamic_method_dispatch;

class Bird
{
	protected int weathers = 2;
	
	public static void fly()
	{
		System.out.println("Bird is flying");
	}	
}
class Parrot extends Bird
{
   protected int weathers = 4;
	
	public static void fly()
	{
		System.out.println("Parrot is flying");
	}	
}

public class IQ {

	public static void main(String[] args) 
	{
		Parrot p = new Parrot();
		Bird b = p;
		System.out.println(p.weathers); //4
		p.fly();
		System.out.println(b.weathers); //2
		b.fly();

	}

}
----------------------------------------------------------------
instanceof operator :
---------------------
It is a relational operator so it returns boolean value.
It is also a keyword.
It is used to describe whether a reference variable is holding an object of particular type or not.
There must be an IS-A relation between reference variable and partcular class OR interface type.
It is used to avoid java.lang.ClassCastException.

Programs :
-----------
package com.ravi.instance_of;

class Bird
{	
}

class Fish 
{	
}

public class InstanceOfDemo {

	public static void main(String[] args) 
	{
		Fish f = new Fish();
		
		if(f instanceof Fish)
		{
			System.out.println("f is pointing to Fish Object");
		}
		
		else if(f instanceof Bird)  //error
		{
			
		}	
		

	}

}
----------------------------------------------------------------
package com.ravi.instance_of;

class Test
{
	
}

public class InstanceOfDemo1 
{
	public static void main(String[] args) 
	{
	   Test t1 = new Test();
	   
	   if(t1 instanceof Test)
	   {
		   System.out.println("t1 is the instance of Test");
	   }
	   
	   else if(t1 instanceof Object)
	   {
		   System.out.println("t1 is the instance of Object");
	   }
	   
	   
	}

}
---------------------------------------------------------------
package com.ravi.instance_of;

public class InstanceDemo2 {

	public static void main(String[] args) 
	{
		Integer i = 45;
		
		if(i instanceof Integer)
		{
			System.out.println("i is pointing Integer Object");
		}
		
		else if(i instanceof Number)
		{
			System.out.println("i is pointing to Number Object");
		}		

	}

}
----------------------------------------------------------------
package com.ravi.instance_of;

class A{}

class B extends A{}

class C extends B{}

class D extends C{}

public class InstanceOfDemo3 
{
	public static void main(String[] args) 
	{
	   D d1 = new D();
	   
	   if(d1 instanceof D)  //Here instead of D we can take A,B,C Object
	   {
		   
	   }   

	}

}
================================================================
package com.ravi.polymorphic_behavior;

class Animal
{
	public void sleep()
	{
		System.out.println("Generic Animal is sleeping");
	}
}
class Lion extends Animal
{
	@Override
	public void sleep()
	{
		System.out.println("Lion is sleeping");
	}
	
	public void roar()
	{
		System.out.println("Lion is Roaring");
	}
	
}
class Dog extends Animal
{
	@Override
	public void sleep()
	{
		System.out.println("Dog is sleeping");
	}
	
	public void bark()
	{
		System.out.println("Dog is Barking");
	}
	
}

class Tiger extends Animal
{
	@Override
	public void sleep()
	{
		System.out.println("Tiger is sleeping");
	}
	
	public void roar()
	{
		System.out.println("Tiger is Roaring");
	}
	
}

class Cat extends Animal
{
	public void sleep()
	{
		System.out.println("Cat is sleeping");

    }
	
	public void meow()
	{
		System.out.println("Meow Meow");
	}
}





public class AnimalDemo 
{
	public static void main(String[] args) 
	{
		Animal lion = new Lion();
		Animal dog = new Dog();
		Animal tiger = new Tiger();
		Animal cat = new Cat();
		
		callSleepingAnimal(lion);
		callSleepingAnimal(dog);	
		callSleepingAnimal(tiger);
		callSleepingAnimal(cat);
		
	}
	
	public static void callSleepingAnimal(Animal a1)
	{
	   if(a1 instanceof Lion)
	   {
		   Lion lion = (Lion)a1;
		   lion.sleep();
		   lion.roar();
	   }
	   else if(a1 instanceof Dog)
	   {
		   Dog d1 = (Dog) a1;
		   d1.sleep(); d1.bark();
	   }
	   else if(a1 instanceof Tiger)
	   {
		   Tiger t1 = (Tiger) a1;
		   t1.sleep(); t1.roar();
	   }
	   else if(a1 instanceof Cat)
	   {
		   Cat c1 = (Cat) a1;
		   c1.sleep(); c1.meow();
	   }
	   
		
	}

}
================================================================
*What is the limitation of 'new' keyword ?
                       OR
What is the difference between new keyword and newInstance() method?
                      OR
How to create the Object for the classes which are coming dynamically from the database or from some file at runtime.

The limitation with new keyword is, It demands the class name at the begning or at the time of compilation so new keyword is not suitable to create the object for the classes which are coming from database or files at runtime dynamically.

In order to create the object for the classes which are coming at runtime from database or files, we should use newInstance() method available in java.lang.Class class.

newInstance() method creates the object internally by using new keyword only and the class must contain either default OR no
argument constructor.

Methods :
----------
public Object newInstance() : Predefined non static method of 
                              java.lang.Class. It is used to 
			      create the object for dynmacilly 
			      loaded classes.
			      
public native java.lang.Class getClass() :Predefined non static method of Object class. The return type of this method is java.lang.Class so further we can call any method of java.lang.Class class object

          getClass().getName();
           
------------------------------
----------------------------------
class Student
{
}
class Employee
{
}
public class ObjectAtRuntime 
{
	public static void main(String[] args) throws Exception
	{
		Object obj = Class.forName(args[0]).newInstance();
		System.out.println("Object created for :"+obj.getClass().getName());
	}
}

Methods :
---------

Note : We can pass any class at runtime, newInstance() method will create the Object.
----------------------------------------------------------------
class Ravi
{
	public void hi()
	{
		System.out.println("Hello Hyderabad");
	}
}

class Sample
{
	public void greet()
	{
		System.out.println("Hello India");
	}
}
public class ObjectAtRuntime1
{
	public static void main(String[] args) throws Exception
	{
     Object  obj = Class.forName(args[0]).newInstance();
	 
	 if(obj instanceof Sample)
	 {
		 Sample s = (Sample)obj;
		 s.greet();
	 }
	 
	 else if(obj instanceof Ravi)
	 {
		 Ravi r = (Ravi) obj;
		 r.hi();
	 }
	 
	}
}
===============================================================
 final keyword in java :
-----------------------
It is used to provide some kind of restriction in our program.
We can use final keyword in ways 3 ways in java.

1) To declare a class as a final. (Inheritance is not possible)
2) To declare a method as a final (Overriding is not possible)
3) To declare a variable (Field) as a final (Re-assignment is not possible)    
     
1) To declare a class as a final :
-----------------------------------
Whenever we declare a class as a final class then we cann't extend or inherit that class otherwise we will get a compilation error.

We should declare a class as a final if the composition of the class (logic of the class) is very important and we don't want to share the feature of the class to some other developer to modify the original behavior of the existing class, In that situation we should declare a class as a final.

Declaring a class as a final does not mean that the variables and methods declared inside the class will also become as a final, only the class behavior is final that means we can modify the variables value as well as we can create the object for the final classes.

Note :- In java String and All wrapper classes are declared as final class.
 
--------------------------------------------------------------
final class A
{
	private int x = 100;

	public void setData()
	{
		x = 120;
		System.out.println(x);
	}
}
class B extends A 
{   
}
public class FinalClassEx
{
	public static void main(String[] args)
	{
		B b1 = new B();
		b1.setData();		
	}
}
Here A class is final so, we can't inherit class A hence we will get compilation error.
-------------------------------------------------------------
final class Test
{
	private int data = 100;

	public Test(int data)
	{
		this.data = data;
		System.out.println("Data value is :"+data);
	}
}
public class FinalClassEx1 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test(200);
		
	}
}

Note : If a class contains private constructor then we should declare that class with final access modifier.
---------------------------------------------------------------
Sealed class in Java :
-----------------------
It is a new feature introduced from java 15v (preview version) and become the integral part of java from 17v.

It is an improvement over final keyword.

By using sealed keyword we can declare classes and interfaces as sealed.

It is one kind of restriction that describes which classes and interfaces can extend or implement from Sealed class Or interface.

It is similar to final keyword with less restriction because here we can permit the classes to extend from the original Sealed class.

The class which is inheriting from the sealed class must be final, sealed or non-sealed.

The sealed class must have atleast one sub class.

We can also create object for Sealed class.

It provides the following modifiers :

1) sealed : Can be extended only through permitted class.

2) non-sealed : Can be extended by any sub class, if a user wants to give permission to its sub classes.

3) permits : We can provide permission to the sub classes, which are inheriting through Sealed class.

4) final : we can declare permitted sub class as final so, it cannot be extended further.

---------------------------------------------------------------
Programs :
-----------
SealedDemo1.java
------------------
package com.ravi.m1;

sealed class Bird permits Parrot,Sparrow
{
	public void fly()
	{
		System.out.println("Generic Bird is flying");		
	}
}
non-sealed class Parrot extends Bird
{
	@Override
	public void fly()
	{
		System.out.println("Parrot Bird is flying");		
	}
}
final class Sparrow extends Bird
{
	@Override
	public void fly()
	{
		System.out.println("Sparrow Bird is flying");		
	}
}

public class SealedDemo1
{
	public static void main(String[] args)
	{
		Bird b = null;
		b = new Parrot(); b.fly();
		b = new Sparrow(); b.fly();

	}

}
--------------------------------------------------------------
SealedDemo2.java
-----------------
package com.ravi.m1;

sealed class OnlineClass permits Mobile,Laptop
{
	public void attendOnlineJavaClass()
	{
		System.out.println("Online java class!!!");
	}
}
final class Mobile extends OnlineClass
{
	@Override
	public void attendOnlineJavaClass()
	{
		System.out.println("Attending Java class through mobile.");
	}
}
final class Laptop extends OnlineClass
{
	@Override
	public void attendOnlineJavaClass()
	{
		System.out.println("Attending Java class through Laptop.");
	}
}
public class SealedDemo2 
{
	public static void main(String[] args) 
	{
		OnlineClass c = null;
		c = new Mobile(); c.attendOnlineJavaClass();
		c = new Laptop(); c.attendOnlineJavaClass();
	}

}
---------------------------------------------------------------
2) To declare a method as a final (Overriding is not possible)
---------------------------------------------------------------
Whenever we declare a method as a final then we can't override that method in the sub class otherwise there will be a compilation error.

We should declare a method as a final if the body of the method i.e the implementation of the method is very important and we don't want to override or change the super class method body by sub class method body then we should declare the super class method as final method.

class A
{
	protected int a = 10;
	protected int b = 20;

     public final void calculate()
	 {
		int sum = a+b;
		System.out.println("Sum is :"+sum);
	 } 
}
class B extends A
{	
	@Override
	public void calculate() 
	{
		int mul = a*b;
		System.out.println("Mul is :"+mul);	
	}
}
public class FinalMethodEx 
{
	public static void main(String [] args) 
	{
		 A a1 = new B();
		 a1.calculate();
	}
}

Note : We can't oevrride final method in the sub class.
--------------------------------------------------------------
class Alpha
{
	private final void accept()
	{
		System.out.println("Alpha class accept method");
	}
}
class Beta extends Alpha
{
	protected void accept()
	{
		System.out.println("Beta class accept method");
	}
}
public class FinalMethodEx1 
{
	public static void main(String [] args) 
	{
		new Beta().accept();
	}
}

Note : Here Program will compile and execute because private method of super class is not available to sub class.
--------------------------------------------------------------
3) To declare a variable/Field as a final :
--------------------------------------------
In older langugaes like C and C++ we use "const" keyword to declare a constant variable but in java, const is a reserved word for future use so instead of const we should use "final" keyword.

If we declare a variable as a final then we can't perform re-assignment (i.e nothing but re-initialization) of that variable.

In java It is always a better practise to declare a final variable by uppercase letter according to the naming convention.

class A
{
	final int A = 10;           
	public void setData()
	{
		 A = 10; //error 
		 System.out.println("A value is :"+A);
	}
}
class FinalVarEx 
{
	public static void main(String[] args) 
	{
		A a1 = new A();
		a1.setData();
	}
}
--------------------------------------------------------------
class Student 
{
	private int rollNumber;
	private String studentName;
	
	public Student(int rollNumber, String studentName)
	{
		this. rollNumber = rollNumber;
		this.studentName = studentName;
	}
	
}
class FinalVarEx1 
{
	public static void main(String[] args) 
	{
		final Student s1 = new Student(111,"Scott");		
		s1 = new Student(222,"Smith"); //error
	}
}
--------------------------------------------------------------
24-10-2024
----------
Nested classes in java :
-------------------------
In java it is possible to define a class (inner class) inside another class (outer class) called nested class.

In the same way, It is also possible to define a class/interface/enum/
annotation/record inside another class/interface/enum/annotation and record as shown below.

Programs that describes all different possible combinations :
-------------------------------------------------------------
package com.ravi.inner_class_concept;

public class Demo1 
{
    public class Test
    {
    	//class
    }
    
    interface Drawable
    {
    	//interface
    }
    
    enum Direction
    {
    	
    }
    
    record Student()
    {
    	
    }
    
    @interface Hello
    {
    	
    }
    
    
}
-------------------------------------------------------------
package com.ravi.inner_class_concept;

public interface Demo2 
{
   public class Test
   {	   
   }
   
   enum Direction
   {	   
   }
   
   record Student()
   {
	   
   }
   
   @interface Hello
   {
	   
   } 
   
   
}
--------------------------------------------------------------
package com.ravi.inner_class_concept;

public enum Demo3 
{
   A,B;  //Enum constants
   class Test
   {	   
   }
   
   interface Printable
   {
	   
   }
   
   record Student()
   {
	   
   }
   
   @interface Hello
   {
	   
   }
   
   
}
--------------------------------------------------------------
package com.ravi.inner_class_concept;

public record Demo4() 
{
   class Test
   {
	   
   }
   
   interface Drawable
   {
	   
   }
   
   enum Season
   {
	   
   }
   
   @interface Hello
   {
	   
   }
   
   
}
--------------------------------------------------------------
package com.ravi.inner_class_concept;

public @interface Demo5 
{
  class Test
  {
	  
  }
  
  interface Moveable
  {
	  
  }
  
  enum Color
  {
	  
  }
  
  record Employee()
  {
	  
  } 
  
}
--------------------------------------------------------------
Inner classes in Java create a strong encapsulation and  HAS-A  relationship between the inner class and its outer class.

An inner class, .class file will be represented by $ symbol.

Advantages of inner class :
--------------------------------
1) It is a way of logically grouping classes that are only used in one place.

2) It is used to achieve strong encapsulation.

3) It enhance the readability and maintainability of the code.

Types of Inner classes in java :
--------------------------------
There are 4 types of inner classes in java :

1) Non Static Nested class OR Regular class 
2) Static Nested class
3) Method / Method local class
4) Anonymous inner class 

Non static Nested class :
-------------------------
If a non static class declared inside the Outer class but outside of the method then it is called non static nested class.

We can apply private, default, protected, public, abstract and final modifiers on non static nested class.

With the help of outer class we can load inner class also, If inner class contains non static member then object is required for Outer class as well as inner class.

Inner class we can't represent directly, we need to take the support of Outer class because inner class is a non static member of Outer class.

It is also known as Regular OR Mebmer class.
--------------------------------------------------------------
class Outer 
{
	private int a = 15;

	class Inner 
	{
		public void displayValue() 
		{
			System.out.println("Value of a is " + a);
		}
	}
}
public class Test1
{
	public static void main(String... args)  
	{		
		Outer out = new Outer();

		Outer.Inner in = out.new Inner();

		in.displayValue();
		
	}
}

Note : An inner class can directly access the private data of Outer class.
--------------------------------------------------------------
class MyOuter
{
      private int x = 7;
      public void makeInner()
      {
            MyInner in = new MyInner();
			System.out.println("Inner y is "+in.y);
            in.seeOuter();
      }

      class MyInner
      {
		    private int y = 15;
            public void seeOuter()
            {
                  System.out.println("Outer x is "+x);
            }
      }
}
public class Test2
{
      public static void main(String args[])
      {
            MyOuter m = new MyOuter();
            m.makeInner();   
      } 
}
-------------------------------------------------------------
Variable Shadow in Nested class :
----------------------------------
If outer class and inner class variable names are same then inner class variable will be access with inner class object (Variable Shadow bacause in the same scope), If we want to access Outer class variable from inner class then we need ClassName.this.variableName.

package com.ravi.inner_class;

class Outer1
{
	private int x = 100;
	
	public class Inner1
	{
		private int x = 200; //Variable Shadow
		
		public void show()
		{
			System.out.println(Outer1.this.x);
			System.out.println(this.x);
		}
		
	}
}
public class InnerClassDemo2 
{
  public static void main(String[] args) 
  {
	 Outer1.Inner1 in = new Outer1().new Inner1();
	 in.show();
  }
}
--------------------------------------------------------------
class MyOuter
{
      private int x = 15;
      class MyInner
      {
            public void seeOuter()
            {
                  System.out.println("Outer x is "+x);
            }
      }
}
public class Test3
{
      public static void main(String args[])
      {
		  //Creating inner class object in a single line
           MyOuter.MyInner m = new MyOuter().new MyInner();
			m.seeOuter();
      } 
}
--------------------------------------------------------------
class MyOuter  
{
      static int x = 7;
	  class MyInner
      {
            public static void seeOuter()  //MyInner.seeOuter();
            {
                  System.out.println("Outer x is "+x);
            }
      }
}

public class Test4
{
      public static void main(String args[])
      {
          MyOuter.MyInner.seeOuter();
      } 
}
-------------------------------------------------------------
class Car 
{    
    private String make;
    private String model;
    private Engine engine; 

   public Car(String make, String model, int horsePower) 
   {
        this.make = make;
        this.model = model;
        this.engine = new Engine(horsePower);
    }

   //Inner class
   private class Engine 
   {
      private int horsePower;

       public Engine(int horsePower)
	   {
            this.horsePower = horsePower;
        }

        public void start() 
		{
            System.out.println("Engine started! Horsepower: " + horsePower);
        }

        public void stop() 
	    {
            System.out.println("Engine stopped.");
        }
    }

    public void startCar() 
	{
        System.out.println("Starting " + make + " " + model);
        this.engine.start();
    }

    public void stopCar() 
	{
        System.out.println("Stopping " + make + " " + model);
        this.engine.stop();
    }
}
public class Test5
{

    public static void main(String[] args) {
        
        Car myCar = new Car("Swift", "Desire", 1200);

        myCar.startCar();

        myCar.stopCar();
    }
}
-----------------------------------------------------------------
25-10-2024
-----------
class Laptop 
{
    private String brand;
    private String model;
    private Motherboard motherboard;

    public Laptop(String brand, String model, String motherboardModel, String chipset) 
	{
        this.brand = brand;
        this.model = model;
        this.motherboard = new Motherboard(motherboardModel, chipset);
    }

    
    public void switchOn()
	{
        System.out.println("Turning on " + brand + " " + model);
        this.motherboard.boot();
    }

   //Motherboard inner class
   public class Motherboard 
   {
        private String model;
        private String chipset;
        
        public Motherboard(String model, String chipset) 
		{
            this.model = model;
            this.chipset = chipset;
        }

        
        public void boot() 
		{
            System.out.println("Booting " + brand + " " + model + " with " + chipset + " chipset");
        }
    }
}
public class Test6
{
    public static void main(String[] args) 
	{
        
        Laptop laptop = new Laptop("HP", "ENVY", "IRIS", "Intel");

        laptop.switchOn();
    }
}
--------------------------------------------------------------
class Person
{
    private String name;
    private int age;
    private Heart heart;

    public Person(String name, int age)
	{
        this.name = name;
        this.age = age;
        this.heart = new Heart();
    }

    public void describe() 
	{
        System.out.println("Name: " + name);
        System.out.println("Age: " + age);
        System.out.println("Heart beats per minute: " + this.heart.getBeatsPerMinute());
    }

    // Inner class representing the Heart
    private class Heart 
	{
        private int beatsPerMinute;

        public Heart() 
		{
            this.beatsPerMinute = 72; 
        }

        public int getBeatsPerMinute() 
		{
            return this.beatsPerMinute;
        }

        public void setBeatsPerMinute(int beatsPerMinute) 
		{
            this.beatsPerMinute = beatsPerMinute;
        }
    }
}
public class Test7
{
    public static void main(String[] args)
	{
        Person person = new Person("Virat", 30);
        person.describe();
    }
}
-------------------------------------------------------------
class University 
{
    private String name;

    public University(String name)
	{
        this.name = name;
    }
    
    public void displayUniversityName()
	{
        System.out.println("University Name: " + name);
    }

    public class Department 
	{
        private String name;
        private String headOfDepartment;

        public Department(String name, String headOfDepartment) 
		{
            this.name = name;
            this.headOfDepartment = headOfDepartment;
        }

        // Method to display department details
        public void displayDepartmentDetails()
		{
			displayUniversityName();
            System.out.println("Department Name: " + name);
            System.out.println("Head of Department: " + headOfDepartment);
            
        }
    }
}
public class Test8
{
    public static void main(String[] args) 
	{
       
        University university = new University("JNTU");

       University.Department cs = university.new Department("Computer Science", "Dr. John");

        University.Department ee = university.new Department("Electrical Engineering", "Dr. Scott");

       
        cs.displayDepartmentDetails();
        ee.displayDepartmentDetails();
    }
}
---------------------------------------------------------------
class OuterClass 
{
	private int x = 200;
	
	class InnerClass
	{
		public void display()  //Inner class display method
		{
		System.out.println("Inner class display method");
		}
		
		public void getValue()
		{
			display();
			System.out.println("Can access outer private var :"+x);
		}
	}
       
		public void display()  //Outer class display method
		{
			System.out.println("Outer class display");
		}	
}
public class Test9
{
	public static void main(String [] args)
	{
		OuterClass.InnerClass inobj = new OuterClass().new InnerClass();
		inobj.getValue();
		
		new OuterClass().display();

	}
}

Note : From inner class object, we can access inner class display() method, If we want to call Outer class display method
then Outer class Object is reqd.
---------------------------------------------------------------
class OuterClass 
{
	int x;
	abstract class InnerClass  
	{                        
		int x;
	}
}
public class Test10
{
}


Note : In a non static nested inner class we can apply private, default, protected, public, abstract and final modifiers.
---------------------------------------------------------------
static nested inner class :
----------------------------
It is class level nested class.

If we decalre a static class inside another class then it is called Static nested inner class.

For static nested inner class, Outer class object is not required.

If static nested inner class contains only static memebr then inner class object is also not required.

If static nested inner class contains non static member then inner class object is required.

We cann't access non static member of Outer class from static nested inner class [Static context].
---------------------------------------------------------------
//static nested inner class
class BigOuter  
{
     static class Nest   //static nested inner class   
     {
          void go()  //Instance method of static inner class
          {
               System.out.println("Hello welcome to static nested class");  
          }  
     }
}
class Test11
{    
      public static void main(String args[])
      {
          BigOuter.Nest n = new BigOuter.Nest();
          n.go();
			
			
      } 
}
---------------------------------------------------------------
class Outer
{  
	  static int x = 15;  

	  static class Inner
	  {  
			    void msg()
				{
					System.out.println("x value is  "+x);
				}  
	  }
}
class Test12
{  
	public static void main(String args[])
	{  
		Outer.Inner obj=new Outer.Inner();  
		obj.msg();  
	}  
}  
---------------------------------------------------------------
class Outer    
{  
	  static int x = 25; 
	   
	  static class Inner 
	  {  
			static void msg()
				{
					System.out.println("x value is  "+x);					
				}		
	  }	  
}
class Test13
{  
	public static void main(String args[])
	{  
		Outer.Inner.msg();
	}  
}  
---------------------------------------------------------------
class Outer
{  
	  int x=15;  //error (not possible because try to access instance variable)
	  static class Inner
	  {  
			void msg()
				{
					System.out.println("x value is  "+x);
				}  
	  }
}
class Test14
{  
	public static void main(String args[])
	{  
		Outer.Inner obj=new Outer.Inner();  
		obj.msg();  
	}  
}  
---------------------------------------------------------------
package com.ravi.m1;

class Outer
{
    static int x = 200;	
	static
	{
		System.out.println("Outer class static block");
	}
	
	static class Inner
	{
		static
		{
			System.out.println("Inner class static block");
		}
		
		public static void m1()
		{
			System.out.println("Inner class Static Method :"+x);
		}	
	}	
}

public class StaticNestedDemo 
{
	public static void main(String[] args) 
	{		
		Outer.Inner.m1();
	}

}

Here We are accessing inner class static method from main method so, first of all inner class static block will be executed and from inner class static method, we are accessing Outer class static variable so Outer class will be loaded and static block will be executed.
===============================================================
Method level inner class :
--------------------------
Local OR Method Local Inner class :
------------------------------------
If we define a class with class name inside the method body then it is called Local OR Method local inner class.

public void m1()
{
   class Inner
   {
   }
}

The Scope of this method local inner class within the same stack frame only so we can't use local inner class outside of the method.

It is used to perform some opertion within the method only.

We can't apply any kind of access modifier on method local inner class except final and abstract.
---------------------------------------------------------------
//program on method local inner class
class MyOuter3
{
      private String x = "Outer class private data";

      public void doSttuff()
      { 
           String z = "local variable";  

           class MyInner  //Only final and abstract applicable
           {
                 public void seeOuter()
                 {
                      System.out.println("Outer x is "+x);
                      System.out.println("Local variable z is : "+z);
                 }
           }
		  MyInner mi = new MyInner();
          mi.seeOuter();
	   
      }	   
	 
}
public class Test15
{
      public static void main(String args[])
      {
            MyOuter3 m = new MyOuter3();
            m.doSttuff();  
      } 
}
---------------------------------------------------------------
//local inner class we can't access outside of the method
class MyOuter3
{
      private String z = "Outer class Data";

      public void doSttuff()
      { 
           String x = "local variable";  

            class MyInner        
            {
				 String z = "CLASS instance variable"; 
                 public void seeOuter()
                 {
                      System.out.println("Outer x is "+MyOuter3.this.z);
                      System.out.println("Class variable z is : "+this.z);
					    System.out.println("Local variable  is : "+x);
                 }
           }
		  
		         
	  } 
	    MyInner mi = new MyInner();
	        mi.seeOuter();	
	  
}
public class Test16
{
      public static void main(String args[])
      {
            MyOuter3 m = new MyOuter3();
            m.doSttuff();  
      } 
}

Note : Method local inner class we can't access outside of the method.
--------------------------------------------------------------
26-10-2024
----------
Anonymous inner class
----------------------
If we decalre a class inside a method without any name then it 
is called Anonymous inner class.

The main purpose of anonymous inner class to extend a class or implement an interface.

The anonymous inner class declaration (without name) and object creation both will be done in the same line.

We can create only object for anonymous inner class so it is a singleton class.

*A normal class can extend a class as well as implement many number of interfaces but an anonymous inner can either extend
a class or implement an interface.

Inside an anoymous inner class we can write static and non static variable, static and non static block. We can't define constructor as well as we can't declare abstract method.
--------------------------------------------------------------
package com.ravi.anonymous_demo;

class Vehicle
{
	public void run()
	{
		System.out.println("Generic Vehicle is Running");
	}
}

public class AnonymousInnerDemo1 
{
	public static void main(String[] args) 
	{
		//Anonymous inner class (Hidden class)
		Vehicle car = new Vehicle()       
		{
			@Override
			public void run()
			{
				System.out.println("Car is running");
			}
		};
		car.run();
		
		        //Anonymous inner class (Hidden class)
				Vehicle bike = new Vehicle()
				{
					@Override
					public void run()
					{
						System.out.println("Bike is running");
					}
				};
				bike.run();

	}

}
--------------------------------------------------------------
package com.ravi.anonymous_demo;

class Card
{
	public void payment()
	{
		System.out.println("Payment through Generic card");
	}
	
}

public class AnonymousInnerDemo2 {

	public static void main(String[] args) 
	{
		Card creditCard = new Card()
		{			
			@Override
			public void payment()
			{
				System.out.println("Payment through Credit card");
			}		
		};
		
		creditCard.payment();
		
	}

}
=============================================================
Abstraction : [Hiding the complexcity]
---------------------------------------
Showing the essential details without showing the background details is called abstraction.

In order to achieve abstraction we use the following two 
concepts :
       
       1) Abstract class (we can achieve 0 - 100% abstraction)
       2) Interface (we can achieve 100 % abstraction)

=============================================================
Abstract class and abstract methods :
-------------------------------------------
A class that does not provide complete implementation (partial implementation) is defined as an abstract class.

An abstract method is a common method which is used to provide easiness to the programmer because the programmer faces complexcity to remember the method name.

An abstract method observation is very simple because every abstract method contains abstract keyword, abstract method does not contain any method body and at the end there must be a terminator i.e ; (semicolon)

In java, whenever action is common but implementations are different then we should use abstract method, Generally we declare abstract method in the super class and its implementation must be provided in the sub classes.

if a class contains at least one method as an abstract method then we should compulsory declare that class as an abstract class.

Once a class is declared as an abstract class we can't create an object for that class.

*All the abstract methods declared in the super class must be overridden in the sub classes otherwise the sub class will become as an abstract class hence object can't be created for the sub class as well.

In an abstract class we can write all abstract method or all concrete method or combination of both the method. 

It is used to acheive partial abstraction that means by using abstract classes we can acheive partial abstraction(0-100%).

*An abstract class may or may not have abstract method but an abstract method must have abstract class.

Note :- We can't declare an abstract method as final, private and static (illegal combination of modifiers)

We can't declare an abstract class as a final.

--------------------------------------------------------------
AbstractDemo1.java
-------------------
abstract class Bird
{
	public abstract void fly();
	
}
class Parrot extends Bird
{
	@Override
	public void fly()
	{
		System.out.println("Parrot Bird is flying");
	}
}
class Sparrow extends Bird
{
	@Override
	public void fly()
	{
		System.out.println("Sparrow Bird is flying");
	}
}

public class AbstractDemo1 
{
	public static void main(String[] args) 
	{
		Bird b ;
		b = new Parrot(); b.fly();
		b = new Sparrow(); b.fly();
	}
}
---------------------------------------------------------------
package com.ravi.abstract_demo;

abstract class Bike
{
	protected int speed = 90;
	
	public Bike()
	{
		System.out.println("Bike class Constructor");
	}
	
	public void getBikeDetails()
	{
		System.out.println("It has two wheels");
	}
	
	public abstract void run();	
	
}

class Unicorn extends Bike
{
	@Override
	public void run() 
	{
		System.out.println("Bike is running");		
	}	
}
public class IQ 
{
	public static void main(String[] args)
	{
		Bike b = new Unicorn();
		System.out.println(b.speed);
		b.getBikeDetails();
		b.run();

	}

}
-------------------------------------------------------------
28-10-2024
------------
How to initialize the abstract class properties :
--------------------------------------------------
package com.ravi.abstract_demo;

abstract class Shape
{
	protected String shapeType;

	public Shape(String shapeType) 
	{
		super();
		this.shapeType = shapeType;
	}
	
	public abstract void draw();
}

class Rectangle extends Shape
{
	public Rectangle(String shapeType)
	{
		super(shapeType);
	}
	
	@Override
	public void draw()
	{
		System.out.println("Drawing "+shapeType);
	}
}

class Square extends Shape
{
	public Square(String shapeType)
	{
		super(shapeType);
	}
	
	@Override
	public void draw()
	{
		System.out.println("Drawing "+shapeType);
	}
}

public class AbstractDemo1 {

	public static void main(String[] args)
	{
		Rectangle rr = new Rectangle("Rectangle");
		rr.draw();
		
		Square ss = new Square("Square");
		ss.draw();

	}

}
-------------------------------------------------------------
IQ :
----
What is the advantage of taking instance variable OR writing constructor inside abstract class ?

As we know we can't create an object for abstract class but still we can take object properties (Instance variable) and 
constructor, To call the abstract class constructor for initialization of instance variable we should use sub class object (Using super keyword)
-------------------------------------------------------------
Anonymous inner class using abstract method :
----------------------------------------------
package com.ravi.abstract_demo;

abstract class Vehicle
{
	public abstract void run();
}

public class AbstractDemo2 
{
	public static void main(String[] args) 
	{
		Vehicle car = new Vehicle() 
		{
			@Override
			public void run() 
			{
				System.out.println("Car is running");				
			}		
		};
		car.run();

		Vehicle bike = new Vehicle() 
		{
			@Override
			public void run() 
			{
				System.out.println("Bike is running");				
			}		
		};
		bike.run();
		
			
	}

}
------------------------------------------------------------
package com.ravi.abstract_demo;

abstract class Alpha
{
	public abstract void show();
	public abstract void demo();
}

abstract class Beta extends Alpha
{
	@Override
	public void show() //demo();
	{
		System.out.println("Show method overridden");
	}	
}
class Gamma extends Beta
{
	@Override
	public void demo() 
	{
		System.out.println("Demo method overridden");
		
	}	
}

public class AnonymousDemo3 {

	public static void main(String[] args) 
	{
		Gamma g = new Gamma();
		g.show();
		g.demo();

	}

}

Note : From the above program it is clear that all the abstract methods must be overridden in the sub classes otherwise sub class will become as an abstract class so, object will not be created.
-------------------------------------------------------------
Polymorphism with Array :
--------------------------
package com.ravi.abstract_demo;

abstract class Animal
{
	public abstract void checkup();
}
class Dog extends Animal
{
	@Override
	public void checkup() 
	{
		System.out.println("Dog Animal Checkup");		
	}	
}
class Lion extends Animal
{
	@Override
	public void checkup() 
	{
		System.out.println("Lion Animal Checkup");		
	}	
}
class Horse extends Animal
{
	@Override
	public void checkup() 
	{
		System.out.println("Horse Animal Checkup");		
	}	
}

public class AnimalChecking 
{
	public static void main(String[] args) 
	{
		Dog dogs[] = {new Dog(), new Dog(), new Dog()};
		
		Lion lions[] = {new Lion(), new Lion()};
		
		Horse horses[] = {new Horse(), new Horse(), new Horse()};
		
		animalCheck(dogs);
		System.out.println("..........");
		animalCheck(lions);
		System.out.println("..........");
		animalCheck(horses);
	
	}
	
	public static void animalCheck(Animal ...animals)
	{
		for(Animal animal : animals)
		{
			animal.checkup();
		}
	}
}
-----------------------------------------------------------
30-10-2024
-----------
interface :
------------
interface upto java 1.7
------------------------
An interface is a keyword in java which is similar to a class which defines working functionality of a class.

Upto JDK 1.7 an interface contains only abstract methods that means there is a guarantee that inside an interfcae we don't have concrete or general or instance methods.

From java 8 onwards we have a facility to write default and static methods.

By using interface we can achieve 100% abstraction concept because it contains only abstract methods.

In order to implement the member of an interface, java software people has provided implements keyword.

All the methods declared inside an interface is by default public and abstract so at the time of overriding we should apply public access modifier to sub class method.

All the variables declared inside an interface is by default public, static and final.

We should override all the abstract methods of interface to the sub classes otherwise the sub class will become as an abstract class hence object can't be created.

We can't create an object for interface, but reference can be created.

By using interface we can acheive multiple inheritance in java.

We can achieve loose coupling using interface.

Note :- inside an interface we can't declare any blocks (instance, static), instance variables (No properties) as well as we can't write constructor inside an interface.

-----------------------------------------------------------
package com.ravi.interface_demo;

interface Moveable 
{
	int SPEED = 120;  //public + static + final
	
	void move(); //public + abstract
}

class Car implements Moveable
{
	@Override
	public void move()
	{
		//SPEED = 120;  Invalid
		System.out.println("Car Speed is :"+SPEED);
	}
}

public class InterfaceDemo1 
{
	public static void main(String[] args)
	{
		Moveable m = new Car();
		m.move();
		System.out.println("Speed of Car is :"+Moveable.SPEED);

	}

}
-----------------------------------------------------------
BankApplication.java
---------------------
package com.ravi.interface_demo;

interface Bank
{
	void deposit(double amount);
	void withdraw(double amount);
}
class Customer implements Bank
{
	private double balance;
	
	public Customer(double balance)
	{
		super();
		this.balance = balance;
	}

	@Override
	public void deposit(double amount) 
	{		
	  if(amount <=0)
	  {
		  System.err.println("Amount can't be deposited!!");
	  }
	  else
	  {
		  this.balance = this.balance + amount;
		  System.out.println("Amount after deposit is :"+this.balance);
	  }
	}

	@Override
	public void withdraw(double amount) 
	{		
		if(amount > this.balance)
		{
			System.err.println("Insufficient Balance!!");
		}
		else
		{
			this.balance = this.balance - amount;
			System.out.println("Amount after Withdraw is :"+this.balance);
		}
		
	}	
}
public class BankApplication 
{
	public static void main(String[] args) 
	{
		Bank b = new Customer(1000);
		b.deposit(10000);
		b.withdraw(5000);

	}

}
-----------------------------------------------------------
Program on loose coupling :
----------------------------
Loose Coupling :- If the degree of dependency from one class object to another class is very low then it is called loose coupling. [interface id reqd]

Tightly coupled :- If the degree of dependency of one class to another class is very high then it is called Tightly coupled.

According to IT industry standard we should always prefer loose coupling so the maintenance of the project will become easy.

High Cohesion [Encapsulation]:
------------------------------
Our private data must be accessible via public methods (setter and getters) so, in between data and method we must have high cohesion.
(tight coupling) so, validation of outer data is possible.

6 files :
-----------
HotDrink.java
---------------
package com.ravi.loose_coupling;

public class Restaurant 
{
   public static void acceptObject(HotDrink hd) 
   {
	   hd.prepare();
   }
}

Tea.java
---------
package com.ravi.loose_coupling;

public class Tea implements HotDrink 
{
	@Override
	public void prepare()
    {
		System.out.println("Preparing Tea");
	}

}

Coffee.java
------------
package com.ravi.loose_coupling;

public class Tea implements HotDrink 
{
	@Override
	public void prepare()
    {
		System.out.println("Preparing Tea");
	}

}

Restaurant.java
---------------
package com.ravi.loose_coupling;

public class Restaurant 
{
   public static void acceptObject(HotDrink hd) 
   {
	   hd.prepare();
   }
}

Horlicks.java
---------------
package com.ravi.loose_coupling;

public class Horlicks implements HotDrink 
{
	@Override
	public void prepare() 
	{
		System.out.println("Preparing Horlicks");

	}

}

LooseCoupling.java
-------------------
package com.ravi.loose_coupling;

public class LooseCoupling {

	public static void main(String[] args)
	{
		Restaurant.acceptObject(new Tea());
		Restaurant.acceptObject(new Coffee());
		Restaurant.acceptObject(new Horlicks());

	}

}
-----------------------------------------------------------
Method retutn type as a interface :
-----------------------------------
It is always better to take method return type as interface so we can return any implementer class object as shown in the example below

public HotDrink accept()
{
   return new Tea() OR new Coffee() OR new Horlicks() OR any future
   implementer class object...........................
}
-----------------------------------------------------------
Multiple Inheritance by using interface :
-----------------------------------------
In a class we have a constructor so, it is providing ambiguity issue but inside an interface we don't have constructor so multiple inheritance is possible using interface.

The sub class constructor's super keyword will directly move to Object class constructor.(29-OCT)

package com.ravi.mi;

interface A
{
	void m1();
}
interface B
{
	void m1();
}

class C implements A,B
{
	@Override
	public void m1() 
	{
		System.out.println("Multiple Inheritance");		
	}	
}

public class MultipleInheritance 
{
	public static void main(String[] args) 
	{
		C c1 = new C();
		c1.m1();

	}

}
-----------------------------------------------------------
Extending interface :
---------------------
One interface can extends another interface, it cannot implement because interface cannot provide implementation for the abstract method.

package com.ravi.interface_demo;

interface Alpha
{
	void m1();
}
interface Beta extends Alpha
{	
	void m2();
}

class Implementer implements Beta
{
	@Override
	public void m1() 
	{
	 System.out.println("M1 method Implemented!!");		
	}

	@Override
	public void m2() 
	{
		System.out.println("M2 method Implemented!!");	
	}	
}

public class InterfaceDemo 
{
	public static void main(String[] args)
	{
		Implementer i = new Implementer();
		i.m1(); i.m2();

	}

}
-----------------------------------------------------------
interface from JDK 1.8 onwards :
--------------------------------
Limitation of abstract method :
           OR
Maintenance problem with interface in an Industry upto JDK 1.7

The major maintenance problem with interface is, if we add any new abstract method at the later stage of development inside an existing interface then all the implementer classes have to override that abstract method otherwise the  implementer class will become as an abstract class so it is one kind of boundation.

We need to provide implementation for all the abstract methods available inside an interface whether it is required or not?

To avoid this maintenance problem java software people introduced default method inside an interface.
--------------------------------------------------------------
What is default Method inside an interface?
------------------------------------------------
default method is just like concrete method which contains method body and we can write inside an interface from java 8 onwards.

default method is used to  provide  specific implementation for the implementer classes which are implmenting from interface because we can override default method inside the sub classes to provide our own specific implementation.

*By using default method there is no boundation to override the default method in the sub class, if we really required it then we can override to provide my own implementation.

by default, default method access modifier is public so at the time of overriding we should use public access modifier.

default method we can write inside an interface only but not inside a class.
-------------------------------------------------------------
4 files :
----------
Vehicle.java(I)
----------------
package java8;

public interface Vehicle 
{
   void run();
   void horn();
   
   default void digitalMeter()  //JDK 1.8
   {	
	   System.out.println("Digital Meter Facility");
   }   
}


Car.java(C)
-----------
package java8;

public class Car implements Vehicle {

	@Override
	public void run()
	{
		System.out.println("Car is running");
	}

	@Override
	public void horn() 
	{
		System.out.println("Car has horn");		
	}
	
	@Override
	public void digitalMeter()  
	{	
	System.out.println("Car has Digital Meter Facility");
	}
}

Bike.java(C)
-------------
package java8;

public class Bike implements Vehicle 
{
	@Override
	public void run() 
	{
		System.out.println("Bike is running");
	}

	@Override
	public void horn() 
	{
		System.out.println("Bike has horn");		
	}

}


Main.java
----------
package java8;

public class Main {

	public static void main(String[] args) 
	{
		Vehicle v = null;
		v = new Car(); v.run(); v.horn(); v.digitalMeter();
		v = new Bike(); v.run(); v.horn();
		
	}
}


Note :- abstract method is a common method which is used to provide easiness to the programmer so, by looking the abstract method we will get confirmation that this is common behavior for all the sub classes and it must be implemnted in all the sub classes.

Common method [Behavior] -> abstract method
Uncommon method [Behavior] -> default method
--------------------------------------------------------------
Priority of deafult and concrete method :
-----------------------------------------
While working with class and interface, default method is having low
priority than concrete method, In the same way class is more powerfult than interface.

class C extends B implements A  {}  //Valid

class C implements A extends B {} //Invalid

MethodPriority.java
-------------------
package java8;

interface A
{
	default void m1()
	{
		System.out.println("Default Method of interface A");
	}
}
class B
{
	public void m1()
	{
		System.out.println("Concrete Method of class B");
	}
}

class C extends B implements A 
{
	
}
public class MethodPriority 
{
	public static void main(String[] args) 
	{
		C c1 = new C();
		c1.m1();

	}

}

Output : Concrete Method of class B
==============================================================
Can we achieve multiple inheritance using default method :
----------------------------------------------------------
Multiple inheritance is possible in java by using default method inside an interface, here we need to use super keyword to differenciate the super interface methods.
Before java 1.8, we have abstract method inside an interface but now we can write method body(default method) so, to execute the default method inside an interface we need to take super keyword with interface name(Alpha.super.m1()).


package java8;

interface Alpha
{
	public default void m1()
	{
		System.out.println("Default method of Alpha interface");
	}
}

interface Beta
{
	public default void m1()
	{
		System.out.println("Default method of Beta interface");
	}
}

class C implements Alpha,Beta
{
	@Override
	public void m1() 
	{
	   Alpha.super.m1();
	   Beta.super.m1();
	   System.out.println("Multiple Inheritance is Possible!!");	
	}	
}

public class MultipleInheritance 
{
	public static void main(String[] args) 
	{
		C c1 = new C();
		c1.m1();

	}

}
------------------------------------------------------------
What is static method inside an interface?
------------------------------------------
We can define static method inside an interface from java 1.8 onwards.

static method is only available inside the interface, It is not available to the implementer classes.

It is used to provide common functionality which we can apply/invoke from any BLC/ELC class.

By default static method of an inetrafce contains public  access modifier.
--------------------------------------------------------------
2 files :
----------
Calculate.java
-----------------
package com.ravi.java8;

public interface Calculate 
{
   static double getSquare(double num)
   {
	   return num*num;
   }
   
   static double getCube(double num)
   {
	   return num*num*num;
   }
}

Main.java
----------
package com.ravi.java8;

public class Main {

	public static void main(String[] args) 
	{
		System.out.println(Calculate.getSquare(4));
		System.out.println(Calculate.getCube(5));

	}

}
-------------------------------------------------------------
Program that describe that static method of an interface is only available to interface only that means we can access the static method of an interface by using only one way i.e interface name.

interface Hello  
{
	public static void m1()
	{
		System.out.println("m1 static method");
	}
}

public class Test implements Hello
{
	public static void main(String [] args)
	{
           Test t1 = new Test();  
	   t1.m1(); //error [Only possible way to call static 
	                     method using interafce name]	
	}
}
--------------------------------------------------------------
02-11-2024
------------
Can we write main method inside an interface ?
----------------------------------------------
interface is implicitly an abstract class, From java 8v onwards we can write static method so we can also write main method, Since it is a class so main method will be executed from interface body also.

package com.ravi.interface_demo;

public abstract interface Printable 
{
  public static void main(String[] args) 
  {
	  System.out.println("interface main method");
  }
}
--------------------------------------------------------------
Interface Static Method:
------------------------
   a) Accessible using the interface name.
   b) Cannot be Hidden by implementing classes.(Not Available)
   c) Can be called using the interface name only.

Class Static Method:
--------------------
   a) Accessible using the class name.
   b) Can be hidden (not overridden) in subclasses by redeclaring a static method with the same signature.
   c) Can be called using the super class, sub class name as well as sub class object also as shown in the program below.

package com.ravi.interface_demo;

class A
{
	public static void m1()
	{
		System.out.println("Static method A");
	}
}
class B extends A
{
	
}
public class Demo
{
	public static void main(String [] args)
	{
		   A.m1();
                   B.m1();  //valid
	           new B().m1(); //valid
	}
}
--------------------------------------------------------------
Interface from java 9v version
-------------------------------
Yes, From java 9 onwards we can also write private static and private non-static methods inside an interface.

The folowing are the advantages of writing private methods :
  a) Code Reusability
  b) Hiding the implementation details by writing the logic
     inside private method (We can achieve 100% abstraction)

These private methods will improve code re-usability inside interfaces.

For example, if two default methods needed to share common and confidential code, a private method would allow them to do so, but without exposing that private method to it’s implementing classes.

Using private methods in interfaces have four rules :

1) private interface method cannot be abstract.
2) private method can be used only inside interface.
3) private static method can be used inside other static and non-static interface methods.
4) private non-static methods cannot be used inside private static methods.


package com.ravi.interface_demo;

interface Acceptable
{
	void m1();  //[Abstract Method, JDK 1.0] 
	
	default void m2() //[default Method, JDK 1.8]
	{
		System.out.println("Default Method of an interface");
		m4();
		m5();
	}
	
	static void m3() //[static Method, JDK 1.8]
	{
		System.out.println("Static Method of an interface");
		m5();		
	}
	
	private void m4()  //[Private non static method, JDK 9]
	{
		System.out.println("Private non Static Method of an interface");
	}
	
	private static void m5()  //[Private static method, JDK 9]
	{	
		System.out.println("Private Static Method of an interface");
	}	
	
	/*default void m6()
	{
		System.out.println("Another Default method");
		m4();  //Re-Using our private methods
		m5();
	}*/
	
	
}
class Implementer implements Acceptable
{
	@Override
	public void m1() 
	{
		System.out.println("Abstract method Implemented");		
	}
	
}
public class InterfaceMember 
{
	public static void main(String[] args) 
	{
		Acceptable a1 = new Implementer();
		a1.m1();
		a1.m2();	
		Acceptable.m3();
		//a1.m6();

	}

}

Note : We can achieve 100% abstraction by using private method inside interface.
--------------------------------------------------------------
Can an interface extend a class [Oracle Documentation 9.2]:
------------------------------------------------------------
An interface can't extend a class, It can extend only interface.

Every public method of Object class is implicitly re-declared inside every interface as an abstract method to support upcasting if interface does not extend any super interface.

We can't override any public method of object class as a
default method inide interface.

package com.ravi.interface_class;

interface Acceptable 
{
	
}

public class InterfaceMethods {

	public static void main(String[] args) 
	{
		Acceptable a = null;
		a.hashCode();
		a.toString();
		a.equals(null);

	}

}
--------------------------------------------------------------
package com.ravi.interface_class;

interface Hello
{	
	public default String toString() //error
	{
		return null;
	}
}
public class InterfaceMethods1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}

We can't override public non final method of Object class
as a default method inside interface.
-------------------------------------------------------------
package com.ravi.interface_class;

interface Hello
{	
	@Override
	public String toString();
	
	@Override
	public boolean equals(Object obj);
	
	@Override
	public int hashCode();	
	
}
public class InterfaceMethods1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}

The above program is valid but now compiler will not add these 3 public methods of Object class.
--------------------------------------------------------------
Anonymous inner class with interface:
--------------------------------------
package com.ravi.anonymous_inner_class;

@FunctionalInterface
interface Student
{
	void writeExam();
}

public class AnonymousInnerDemo 
{
	public static void main(String[] args) 
	{
		Student science = new Student()
		{
			@Override
			public void writeExam() 
			{
				System.out.println("Science Students are Writing exam");						
			}
			
		};
		science.writeExam();
		
		Student arts = new Student()
		{
			@Override
			public void writeExam() 
			{
				System.out.println("Arts Students are Writing exam");						
			}
			
		};
		arts.writeExam();
	}

}
---------------------------------------------------------------
Introduction to Functional Programming :
----------------------------------------
What is Lambda Expression in java ?
------------------------------------
It is a new feature introduced in java from JDK 1.8 onwards.
It is an anonymous function i.e function without any name.
In java it is used to enable functional programming.
It is used to concise our code as well as we can remove boilerplate code.
It can be used with functional interface only.
If the body of the Lambda Expression contains only one statement then curly braces are optional.
We can also remove the variables type while defining the Lambda Expression parameter.
If the lambda expression method contains only one parameter then we can remove () symbol also.

In lambda expression return keyword is optional but if we use return keyword then {} are compulsory.

Independently Lamda Expression is not a statement.

It requires a target variable i.e functional interface reference only.

Lamda target can't be class or abstract class, it will work with functional interface only.
-------------------------------------------------------------
Program on Lambda Expression :
------------------------------
package com.ravi.lambda_expression;

@FunctionalInterface
interface Printable
{
	void print();	
}
public class LambdaDemo1 
{
	public static void main(String[] args) 
	{
		Printable p = ()-> System.out.println("Printing");
		p.print();
	}

}
----------------------------------------------------------------------
package com.ravi.lambda_expression;

interface Vehicle
{
	void run();
}
public class LambdaDemo2 {

	public static void main(String[] args) 
	{
		Vehicle car = ()-> System.out.println("Car is Running");
		Vehicle bike = ()-> System.out.println("Bike is Running");
		Vehicle bus = ()-> System.out.println("Bus is Running");
		
		car.run(); bike.run(); bus.run();
	}

}
-----------------------------------------------------------------------
package com.ravi.lambda_expression;

@FunctionalInterface
interface Calculate
{
	void doSum(int x, int y);
}


public class LambdaDemo3 
{
	public static void main(String[] args) 
	{
		Calculate calc = (c,d) -> System.out.println(c+d);
		calc.doSum(12, 24);
	}

}
-----------------------------------------------------------------------
package com.ravi.lambda_expression;

@FunctionalInterface
interface Length
{
	int getStringLength(String str);
}
public class LambdaDemo4 {

	public static void main(String[] args) 
	{
      Length l = str -> str.length();      
      System.out.println("Length is :"+l.getStringLength("India"));
	}

}
-----------------------------------------------------------------------
package com.ravi.lambda_expression;

import java.util.Scanner;

/* If the input number is 0 or negative return -1
 * If the input number is even return square of the number
 * If the input number is even return cube of the number
 *  */

@FunctionalInterface
interface Calculator
{
	double getSquareAndCube(int num);
}


public class LambdaDemo5 {

	public static void main(String[] args) 
	{
		Calculator calc = num -> 
		{
			if(num<=0)
			{
				return -1;
			}
			else if(num % 2== 0)
			{
				return (num*num);
			}
			else
			{
				return (num*num*num);
			}			
		};
		
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter a number :");
		int no = sc.nextInt();
		
		System.out.println(calc.getSquareAndCube(no));
		
		
	}

}
-----------------------------------------------------------------------
What is type parameter<T> in java ?
------------------------------------
It is a technique through which we can make our application indepenedent of data type. It is represented by <T>

In java we can pass Wrapper classes as well as User-defined classes (reference classe) to this type parameter.

We cannot pass any primitive type to this type parameter.


package com.ravi.lambda_expression;

class Accept<T>
{
	private T x;

	public Accept(T x)
	{
		super();
		this.x = x;
	}

	public T getX() 
	{
		return x;
	}
}

public class TypeParameterDemo 
{
	public static void main(String[] args) 
	{
		Accept<Integer> intType = new Accept<Integer>(12);
		System.out.println("Integer type :"+intType.getX());
		
		Accept<String> strType = new Accept<String>("NIT");
        System.out.println("String type :"+strType.getX());
        
        Accept<Student> stdType = new Accept<Student>(new Student(111));
        System.out.println(stdType.getX());
	}

}

record Student(Integer studentId)
{
	
}
-----------------------------------------------------------------------
30-07-2024
-----------

Working with predefined functional interfaces :
------------------------------------------------------
In order to help the java programmer to write concise  java code in day to day programming java software people has provided the following predefined functional interfaces

1) Predicate<T>          boolean test(T x);
2) Consumer<T>           void accept(T x); 
3) Function<T,R>         R apply(T x);
4) Supplier<T>           T get();
5) BiPredicate<T,U>      boolean test(T x, U y);
6) BiConsumer<T, U>      void accept(T x, U y);
7) BiFunction<T,U,R>     R apply(T x, U y);
8) UnaryOperator<T>      T apply(T x)
9) BinaryOperator<T>     T apply(T x, T y)

Note :-
-------
All these predefined functional interfaces are provided as a part of java.util.function sub package.

Predicate<T> functional interface  :
-------------------------------------------
It is a predefined functional interface available in java.util.function sub package.

It contains an abstract method test() which takes type parameter <T> and returns boolean value. The main purpose of this interface to test one argument boolean expression.

@FunctionalInterface
public interface Predicate<T>   
{
  boolean test(T x);
}


Note :- Here T is a "type parameter" and it can accept any type of User defined class as well as  Wrapper class like Integer, Float, Double and so on.

We can't pass primitive type.
----------------------------------------------------------------
Programs on Predicate<T> functional interface :
------------------------------------------------
package com.ravi.functional_interface_demo;

import java.util.Scanner;
import java.util.function.Predicate;

public class PredicateDemo1 
{
	public static void main(String[] args)
	{
		//Verify whether a number is even or add
		Predicate<Integer> p1 = num -> num%2==0;
		
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter a number to verify even/odd :");
		int no = sc.nextInt();
		
		System.out.println("Is "+no+" even number ?"+p1.test(no));
		sc.close();
		

	}

}
----------------------------------------------------------------------
package com.ravi.functional_interface_demo;

import java.util.Scanner;
import java.util.function.Predicate;

public class PredicateDemo2 {

	public static void main(String[] args) 
	{
		// Verify my name starts with 'A' or not ? 
		Predicate<String> p2 = name -> name.startsWith("A");
		
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter your Name :");
		String name = sc.nextLine();
		
		System.out.println(name+ " starts with character A :"+p2.test(name));
		sc.close();

	}

}
-----------------------------------------------------------------------
package com.ravi.functional_interface_demo;

import java.util.Scanner;
import java.util.function.Predicate;

public class PredicateDemo3 {

	public static void main(String[] args) 
	{
		//Verify my name is Ravi or not 
		Predicate<String> p3 = str -> str.equals("Ravi");
		
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter your Name :");
		String name = sc.nextLine();
		
		System.out.println("Are you Ravi ?"+p3.test(name));
	}

}
-----------------------------------------------------------------------
Assignments :
-------------
1) Using Predicate verify whether a person is eligible for vote or not?

2) Using Predicate verify a year a leap year or not?
-----------------------------------------------------------------------
Consumer<T> functional interface :
-----------------------------------------
It is a predefined functional interface available in java.util.function sub package.

It contains an abstract method accept() and returns nothing. It is used to accept the parameter value or consume the value.

@FunctionalInterface
public interface Consumer<T>
{
    void accept(T x);
}
-----------------------------------------------------------------------
package com.ravi.functional_interface_demo;

import java.util.function.Consumer;

record Employee(Integer employeeId, String employeeName)
{
	
}


public class ConsumerDemo1 {

	public static void main(String[] args) 
	{
		Consumer<Integer> c1 = num -> System.out.println(num);
		c1.accept(12);
		
		Consumer<String> c2 = str -> System.out.println(str);
		c2.accept("NIT");
		
		Consumer<Double> c3 = num -> System.out.println(num);
		c3.accept(12.89);
		

		Consumer<Employee> c4 = emp -> System.out.println(emp);
		c4.accept(new Employee(111, "Scott"));
		
		Consumer<String> c5  = str -> System.out.println(str.toUpperCase());
		c5.accept("India");
	}

}
-----------------------------------------------------------------------
Function<T,R> functional interface :
-----------------------------------------
Type Parameters:
T - the type of the input to the function.
R - the type of the result of the function.

It is a predefined functional interface available in java.util.function sub package.

It provides an abstract method apply that accepts one argument(T) and produces a result(R).

Note :- The type of T(input) and the type of R(Result) both will be decided by the user.

@FunctionalInterface
public interface Function<T,R>
{
   public abstract R apply(T x);        
}
----------------------------------------------------------------------
package com.ravi.functional_interface_demo;

import java.util.Scanner;
import java.util.function.Function;

public class FunctionaDemo1 {

	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		
	  //Finding the square of the number 
	  Function<Integer, Integer> fn1 = num -> num*num;
	  System.out.print("Enter a number to find the square :");
	  int no = sc.nextInt();
	  System.out.println("Square of "+no+" is :"+fn1.apply(no));
	  
	 
	  
	  //Finding the length of my city name
	  Function<String,Integer> fn2 = str -> str.length();
	  System.out.print("Enter your city name :");
	  String cityName = sc.nextLine();
	  cityName = sc.nextLine();
	  System.out.println("Length of "+cityName+" is :"+fn2.apply(cityName));
	  
	  
	  //getting String value
	  Function<String,String> fn3 = str -> 50 + 50 + str + 40 + 40;
	  System.out.println(fn3.apply("India"));
	  
	  sc.close(); 

	}
}
-----------------------------------------------------------------------
Supplier<T> Functional Interface :
----------------------------------
Supplier<T> prdefined functional interface :
--------------------------------------------
It is a predefined functional interface available in java.util.function sub package. 

It provides an abstract method get() which does not take any argument but produces/supply/return a value of type T.

@FunctionalInterface
public interface Supplier<T>
{
   T get();
}
-----------------------------------------------------------------------
package com.ravi.functional_interface_demo;

import java.util.Scanner;
import java.util.function.Supplier;

record Product(Integer productId, String productName, Double productPrice)
{
	
}

public class SupplierDemo1 
{
	public static void main(String[] args) 
	{
	  Supplier<Product>	s1 = ()->
	  {
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter Product Id :");
		int id = sc.nextInt();
		
		System.out.print("Enter Product Name :");
		String name = sc.nextLine();
		name = sc.nextLine();
		
		System.out.print("Enter Product Price :");
		double price = sc.nextDouble();
		
		return new Product(id, name, price);
	  };
	  
	  Product product = s1.get();
	  System.out.println(product); 
	  
	}

}
-----------------------------------------------------------------------
package com.ravi.functional_interface_demo;

import java.util.function.Supplier;

public class SupplierDemo2 {

	public static void main(String[] args) 
	{
		Supplier<String> s1 = ()-> 50 + 50 + "NIT" + 40 + 40;
		System.out.println(s1.get());

	}

}
-----------------------------------------------------------------------
31-07-2024
-----------
How to create our own functional interfaces with Type parameter :
-----------------------------------------------------------------
package com.ravi.functional_interface_ex;

@FunctionalInterface
interface TriFunction<T,U,V,R>
{
	R apply(T t, U u, V v);
}


public class UserDefinedFunctionalInterface 
{
	public static void main(String[] args) 
	{
		TriFunction<Integer,String,Integer,String> fn = (a,b,c)-> a + b + c;
		System.out.println(fn.apply(12, " NIT ", 18));
	}

}
-----------------------------------------------------------------------
BiPredicate<T,U> functional interface :
-----------------------------------
It is a predefined functional interface available in java.util.function sub package.

It is a functional interface in Java that represents a predicate (a boolean-valued function) OF TWO ARGUMENTS.

The BiPredicate interface has method named test, which takes two parameters and returns a boolean value, basically this BiPredicate is same with the Predicate, instead, it takes 2 arguments for the metod test.


@FunctionalInterface
public interface BiPredicate<T, U> 
{
    boolean test(T t, U u);
}

Type Parameters:

T - the type of the first argument to the predicate
U - the type of the second argument the predicate
Note : return type is boolean.
-----------------------------------------------------------------------
import java.util.function.*;
public class Lambda11 
{
	public static void main(String[] args)   
    {
        BiPredicate<String, Integer> filter = (x, y) -> 
		{
            return x.length() == y;  
        };

        boolean result = filter.test("Ravi", 4);
        System.out.println(result);  

        result = filter.test("Hyderabad", 10);
        System.out.println(result);
	}
}
-----------------------------------------------------------------------
import java.util.function.BiPredicate;

public class Lambda12
{
  public static void main(String[] args) 
  {
    // BiPredicate to check if the sum of two integers is even
    BiPredicate<Integer, Integer> isSumEven = (a, b) -> (a + b) % 2 == 0;

        System.out.println(isSumEven.test(2, 3));    
        System.out.println(isSumEven.test(5, 7));   
    }
}
-----------------------------------------------------------------------
BiConsumer<T, U> functional interface :
---------------------------------------
It is a predefined functional interface available in java.util.function sub package.

It is a functional interface in Java that represents an operation that accepts two input arguments and returns no result.

It takes a method named accept, which takes two parameters and performs an action without returning any result.

@FunctionalInterface
public interface BiConsumer<T, U> 
{
    void accept(T t, U u);
}
-----------------------------------------------------------------------
import java.util.function.BiConsumer;

public class Lambda13
{
   public static void main(String[] args) 
   {
     BiConsumer<Integer, String> updateVariables =  (num, str) -> 
		 {
            num = num * 2;
            str = str.toUpperCase();
            System.out.println("Updated values: " + num + ", " + str);
        };

        
        int number = 15;
        String text = "nit";

        updateVariables.accept(number, text);

        // Values after the update (note that the original values are unchanged)
        System.out.println("Original values: " + number + ", " + text);
    }
}
-----------------------------------------------------------------------
BiFunction<T, U, R> Functional interface :   
---------------------------------
It is a predefined functional interface available in java.util.function sub package.

It is a functional interface in Java that represents a function that accepts two arguments and produces a result R.

The BiFunction interface has a method named apply that takes two arguments and returns a result of type R.

@FunctionalInterface
public interface BiFunction<T, U, R> 
{
    R apply(T t, U u);
}
-----------------------------------------------------------------------
import java.util.function.BiFunction;

public class Lambda14
{
  public static void main(String[] args) 
  {
        // BiFunction to concatenate two strings
    BiFunction<String, String, String> concatenateStrings = (str1, str2) -> str1 + str2;

        String result = concatenateStrings.apply("Hello", " Java");
        System.out.println(result);  


      // BiFunction to find the length two strings
    BiFunction<String, String, Integer> concatenateLength = (str1, str2) -> str1.length() + str2.length();

        Integer result1 = concatenateLength.apply("Hello", "Java");
        System.out.println(result1);  


  }
}
----------------------------------------------------------------------
UnaryOperator<T> :
------------------
It is a predefined functional interface available in java.util.function sub package.

It is a functional interface in Java that represents an operation on a single operand that produces a result of the same type as its operand. This is a specialization of Function for the case where the operand and result are of the same type.

It has a single type parameter, T, which represents both the operand type and the result type.

@FunctionalInterface
public interface UnaryOperator<T> extends Function<T,R>
{
  public abstract T apply(T x);
}
-----------------------------------------------------------------------
import java.util.function.*;
public class Lambda15  
{
	public static void main(String[] args) 
	{
		UnaryOperator<Integer> square = x -> x * x;
        System.out.println(square.apply(5));

		UnaryOperator<String> concat = str -> str.concat("base");
		 System.out.println(concat.apply("Data"));
	}
}
--------------------------------------------------------------------
BinaryOperator<T>
-----------------
It is a predefined functional interface available in java.util.function sub package.

It is a functional interface in Java that represents an operation upon two operands of the same type, producing a result of the same type as the operands. 

This is a specialization of BiFunction for the case where the operands and the result are all of the same type.

It has two parameters of same type, T, which represents both the operand types and the result type.

@FunctionalInterface
public interface BinaryOperator<T> extends BiFunction<T,U,R>
{
  public abstract T apply(T x, T y);
}
----------------------------------------------------------------------
import java.util.function.*;
public class Lambda16  
{
	public static void main(String[] args) 
	{
		BinaryOperator<Integer> add = (a, b) -> a + b;
        System.out.println(add.apply(3, 5));  
	}
}
--------------------------------------------------------------
*What is marker interface in java ?
-----------------------------------
A marker interface is an interface which does not contain any field or method, basically a marker interface is an empty interface or tag interface.

public interface Drawable  //Marker interface
{

}

The main purpose of Marker interface to provide additional information to the JVM regarding the object like object is Serilizable, Clonable OR 
randomly accessible or not.

In java we have 3 predefined marker interfaces : java.io.Serilizable,
java.lang.Cloneable, java.util.RandomAccess.

Note : We can create our own marker interface by using instanceof operator.
--------------------------------------------------------------
 ****What is difference between abstract class and interface ?
----------------------------------------------------------------
The following are the differences between abstract class and interface.

1) An abstract class can contain instance variables but interface variables are by default public , static and final.

2) An abstract class can have state (properties) of an object but interface can't have state of an object.

3) An abstract class can contain constructor but inside an interface we can't define constructor.

4) An abstract class can contain instance and static blocks but inside an interface we can't define any blocks.

5) Abstract class can't refer Lambda expression but using Functional interface we can refer Lambda Expression.	

6) By using abstract class multiple inheritance is not possible but by using interface we can achieve multiple inheritance.

------------------OOPs Completed..............................

Exception Handling :
--------------------
What is an execption ?
----------------------
An execption is a runtime error.

An execption is an abnormal situation or un-expected situation in a normal execution flow.

An exception encounter due to dependency, if one part of the program is dependent to another part then there might be a chance of getting Exception.

AN EXCEPTION ALSO ENCOUNTER DUE TO WRONG INPUT GIVEN BY THE USER.
---------------------------------------------------------------
Different Crieteria of Exception :
----------------------------------
The following are the different criteria for exception :

1) java.lang.ArithmeticException

   Whenever we divide a number by 0 (an int value) then we will get java.lang.ArithmeticException

   int x = 10;
   int y = 0;
   int z = x/y;
   System.out.println(z);
   
2) java.lang.ArrayIndexOutOfBoundsException
   If we try to access the index of the array where element is not available then we will get java.lang.ArrayIndexOutOfBoundsException

   int []arr = {10,20,30};
   System.out.println(arr[3]); //No value available for 3rd index

3) java.lang.NagativeArraySizeException
   Whenever we create an array and if we pass some negative value as 
   a size of an array then we will will get java.lang.NagativeArraySizeException

   int []arr = new int[-10];

4) java.lang.NullPointerException
   Whenever we want to call any non static method on the reference
   variable which is pointing to null then we will get
   java.lang.NullPointerException

   String str = null;
   System.out.println(str.length());

5) java.lang.NumberFormatException
   If we try to convert any String into numeric format but the String 
   value is not in a proper format then we will get 
   java.lang.NumberFormatException

   String str = "NIT";
   int no = Integer.parseInt(str);
   System.out.println(no);


6) java.util.InputMismatchException
  At the time of taking the input from the Scanner class if input is 
  not valid from user then we will get java.util.InputMismatchException
   
  Scanner sc = new Scanner(System.in);
  System.out.println("Enter your Roll :");
  int roll = sc.nextInt(); //Eleven
---------------------------------------------------------------
13-11-2024
-----------
Exception Hierarchy :
--------------------
This Exception hierarchy is available in the diagram (Exception_Hierarchy.png)

Note :- As a developer we are responsibe to handle the Exception. System admin is responsibe to handle the error because we cannot recover from error.

-------------------------------------------------------------------
Exception format :
------------------
The java software people has provided the format of exception so whenever we print exception object by using toString() then the format is 

Fully Qualified Name : errorMesage

Package Name + Class Name : errorMessage
-------------------------------------------------------------------
WAP to show that java.lang.Exception is the super class for all the exceptions (Checked + Unchecked)

package com.ravi.basic;

import java.io.IOException;

public class ExceptionSuper 
{
	public static void main(String[] args) 
	{		
	  Exception e = new IOException("Input/Output Exception");
	  System.out.println(e);
	  
	  Exception e1 = new ArithmeticException("Divide by zero problem");
	  System.out.println(e1);
	}
}
--------------------------------------------------------------------
WAP that describes that whenever an exception is encounter in the program then program will be terminated in the middle.

package com.ravi.basic;

import java.util.Scanner;

public class AbnormalTermination 
{
	public static void main(String[] args) 
	{
		System.out.println("Main method Started!!!");
		
		Scanner sc = new Scanner(System.in);
		
		System.out.print("Enter the value of x :");
		int x = sc.nextInt();
		
		System.out.print("Enter the value of y :");
		int y = sc.nextInt();
		
		int result = x/y;
		System.out.println("Result is :"+result);
		
		System.out.println("Main method Completed!!!");
		sc.close();		
	}
}

In the above program, If we put the value of y as 0 then program will be terminated in the middle, IT IS CALLED ABNORMAL TERMINATION.
Actually JVM has a default exception handler which is responsible to handle the execption and terminate the program in the middle abnormaly.
--------------------------------------------------------------------
In order to work with exception, java software people has provided the following keywords :

1) try block
2) catch block
3) finally block [Java 7 try with resourses]
4) throw
5) throws
====================================================================
Key points to remember :
--------------------------------
-> With try block we can write either catch block or finally block or both.
-> In between try and catch we can't write any kind of statement.
-> try block will trace our program line by line.
-> If we have any exception inside the try block,With the help of JVM, try block will automatically  create the appropriate Exception object and then throw the Exception Object to the nearest catch block.
-> In the try block whenever we get an exception the control will directly jump to the nearest catch block so the remaining code of try block will not be executed.
 -> catch block is responsible to handle the exception.
 -> catch block will only execute if there is an exception inside try block.
 --------------------------------------------------------------
try block :
-----------
Whenever our statement is error suspecting statement OR Risky statement then we should write that statement inside the try block.

try block must be followed either by catch block or finally block or both.

*try block is responsible to trace our code line by line, if any execption encounter then with the help of JVM, TRY BLOCK WILL CREATE APPROPRIATE EXECPTION OBJECT, AND THROW THIS EXCEPTION OBJECT to the nearest catch block.

After the execption in the try block, the remaining code of try block will not be executed because control will directly transfer to the catch block.

In between try and catch block we cannot write any kind of statement.

catch block :
--------------
The main purpose of catch block to handle the exception which is thrown by try block.

catch block will only executed if there is an exception in the try block.

-------------------------------------------------------------------
package com.ravi.basic;

import java.util.Scanner;

public class TryDemo 
{
	public static void main(String[] args)  
	{		
		   System.out.println("Main method started....");	
		   Scanner sc = new Scanner(System.in);
		   
		   try
		   {
			   System.out.print("Enter the value of x :");
			   int x = sc.nextInt();
			   
			   System.out.print("Enter the value of y :");
			   int y = sc.nextInt();
			   
			   int result = x/y;
			   System.out.println("Result is :"+result);
			   System.out.println("End of try block");
			   
		   }
		   catch(Exception e)
		   {
			  System.out.println("Inside Catch Block");
			  System.err.println(e); 
		   }
		   System.out.println("Main method ended....");
		   sc.close();
	}
}

In the above program if we put the value of y as 0 but still program will be executed normally because we have used try-catch so it is a 
normal termination even we have an exception in the program.
--------------------------------------------------------------------
public class Test  
{
	public static void main(String [] args)
	{
	  try
	  {
	       // System.out.println(10/0);
		         // OR
		throw new ArithmeticException("Ravi is dividing be zero");	
	  }
	  catch (Exception e)
	  {
		  System.out.println("Inside Catch Block");
		  System.err.println(e);
	  }
	}
}

From the above program it is clear that try block implicitly creating the exception object with the help of JVM and throwing the execption object to the nearest catch block.
--------------------------------------------------------------------
The main purpose of Exception handling to provide user-friendly message to our end user as shown in the program.

package com.ravi.basic;

import java.util.Scanner;

public class CustomerDemo 
{
	public static void main(String[] args) 
	{
		System.out.println("Hello Client, Welcome to my application");
		
		Scanner sc = new Scanner(System.in);
		try
		{
			System.out.print("Enter the value of a :");
			int a = sc.nextInt();
			
			System.out.print("Enter the value of b :");
			int b = sc.nextInt();
			
			int result = a/b;
			System.out.println("Result is :"+result);
			
		}
		catch(Exception e)
		{
			System.err.println("Sir, don't put zero");
		}
		sc.close();
		System.out.println("Thank you for Visiting my application..");
	}
}

Exception handlinag = No Abnormal Termination + User-friendly message on wrong input given by the client.
====================================================================
14-11-2024
----------
Throwable class Method to print Exception :
--------------------------------------------
Throwable class has provided the following three methods :

1) public String getMessage() :- It will provide only error message.

2) public void printStackTrace() :-  It will provide the complete details regarding exception like exception class name, exception error message, exception class location, exception method name and exception line number.

3) public String toString() :- It will convert the exception Object into String representation.


package com.ravi.basic;

public class PrintStackTrace 
{
	public static void main(String[] args) 
	{
		System.out.println("Main method started...");		
		try
		{
			String x = "NIT";
			int y = Integer.parseInt(x); 
			System.out.println(y);	
		}
		catch(Exception e)
		{
			e.printStackTrace(); //For complete Exception details
			System.out.println("---------------------------");
			System.out.println("............................");
			System.err.println(e.getMessage()); //only for Exception message	
			System.out.println("..............");
			System.err.println(e.toString());
		}
		System.out.println("Main method ended...");		

	}

}
--------------------------------------------------------------------
Working with Specific Exception :
---------------------------------
While working with exception, in the corresponding catch block we can take Exception (super class) which can handle any type of Exception.

On the other hand we can also take specific type of exception (ArithmetiException, InputMismatchException and so on) which will handle only one type i.e specific type of exception.

public class Test  
{
	public static void main(String [] args)
	{
        try
        {
			System.out.println(10/0);
        }
        catch (ArithmeticException e) //Specific Exception
        {
			System.err.println("Divide by zero Problem");
        }
		System.out.println("Completed");
  	}
}

--------------------------------------------------------------------
public class Test  
{
	public static void main(String [] args)
	{
        try
        {
			throw new OutOfMemoryError();
        }
        catch (Error e) //Specific
        {
			System.err.println("Some User message");
        }
		System.out.println("Completed");
  	}
}

Note : From the try block we are throwing the OutOfmemoryError so , Error OR Throwable is required in the catch block for handling purpose, If we pass Exception then catch block will not be executed.
--------------------------------------------------------------------
Working with Infinity and Not a number(NaN) :
---------------------------------------------
10/0    -> Infinity (Java.lang.ArithmeticException)
10/0.0  -> Infinity  (POSITIVE_INFINITY)

0/0     -> Undefined (Java.lang.ArithmeticException)
0/0.0   -> Undefined  (NaN)

While dividing a number with Integral literal in both the cases i.e Infinity (10/0) and Undefined (0/0) we will get java.lang.ArithmeticException because java software people has not provided any final, static variable support to deal with Infinity and Undefined.

On the other hand while dividing a number with with floating point literal in the both cases i.e Infinity (10/0.0) and Undefined (0/0.0) we have final, static variable support so the program will not be terminated in the middle which are as follows

10/0.0 = POSITIVE_INFINITY
-10/0.0 = NEGATIVE_INFINITY
0/0.0 = NaN

package com.ravi.basic;

public class InfinityFloatingPoint 
{	
	public static void main(String[] args) 
	{
	   System.out.println("Main Started");
	   System.out.println(10/0.0); 
	   System.out.println(-10/0.0);
	   System.out.println(0/0.0);  
	   System.out.println(10/0); 
	   System.out.println("Main Ended");
	}

}
-------------------------------------------------------------------
Working with multiple try catch :
---------------------------------
According to our application requirement we can provide multiple try-catch in my application to work with multiple execptions.

package com.ravi.basic;
public class MultipleTryCatch 
{
	public static void main(String[] args) 
	{
	  System.out.println("Main method started!!!!");
	  
	  try
	  {
		  int arr[] = {10,20,30};
		  System.out.println(arr[3]);
	  }
	  catch(ArrayIndexOutOfBoundsException e)
	  {
		  System.err.println("Array index is out of limit!!!");
	  }
	  
	  try
	  {
		 String str = null;
		 System.out.println(str.length());
	  }
	  catch(NullPointerException e)
	  {
		  System.err.println("ref variable is pointing to null");
	  } 
	  
	  System.out.println("Main method ended!!!!");	
	}
}
--------------------------------------------------------------------
* Single try with multiple catch block :
-----------------------------------------
According to industry standard we should write try with multiple catch blocks so we can provide proper information for each and every exception to the end user.

While working with multiple catch block always the super class catch block must be last catch block.

From java 1.7v this multiple exceptions we can write in a single catch block by using | symbol.

If try block is having more than one exception then always try block will entertain only first exception because control will transfer to the nearest catch block.


package com.ravi.basic;
public class MultyCatch 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Started...");		
		try
		{
			int c = 10/0;			
			System.out.println("c value is :"+c);	
			
			int []x = {12,78,56};
			System.out.println(x[4]);			
		}
		
		
		catch(ArrayIndexOutOfBoundsException e1)
		{
			System.err.println("Array is out of limit...");
		}
		catch(ArithmeticException e1)
		{
			System.err.println("Divide By zero problem...");
		}
		catch(Exception e1)
		{
			System.out.println("General");
		}	
								
		System.out.println("Main Ended...");
	}
}
--------------------------------------------------------------------
package com.ravi.basic;

public class MultyCatch1 
{
	public static void main(String[] args) 
	{
		System.out.println("Main method started!!!");
		try
		{
		   String str1 = "null";
		   System.out.println(str1.toUpperCase());
		   
		   String str2 = "Ravi";
		   int x = Integer.parseInt(str2);
		   System.out.println("Number is :"+x);
		}
		catch(NumberFormatException  | NullPointerException  e)
		{
			e.printStackTrace();
		}

		System.out.println("Main method ended!!");
	}

}
-------------------------------------------------------------------
finally block [100% Guaranteed for Exceution]
---------------------------------------------
finally is a block which is meant for Resource handling purposes.

According to Software Engineering, the resources are memory creation, buffer creation, opening of a database, working with files, working with network resourses and so on.

Whenever the control will enter inside the try block always the finally block would be executed.

We should write all the closing statements inside the finally block because irrespective of exception finally block will be executed every time.

If we use the combination of try and finally then only the resources will be handled but not the execption, on the other hand if we use try-catch and finally then execption and resourses both will be handled.


package com.ravi.basic;

public class FinallyBlock 
{
	public static void main(String[] args) 
	{
		System.out.println("Main method started");
		
		try
		{		
			System.out.println(10/0);
			
		}		
		finally
		{	
			System.out.println("Finally Block");
		}
		
		System.out.println("Main method ended");
	}

}

Note :- In the above program finally block will be executed, even we have an exception in the try block but here only the resourses will be handled but not the exception.
---------------------------------------------------------------

package com.ravi.basic;

public class FinallyWithCatch 
{
	public static void main(String[] args) 
	{		
		try
		{			
		    int []x = new int[-2];	
		    x[0] = 12;
		    x[1] = 15;
		    System.out.println(x[0]+" : "+x[1]);	   
		   
		}
		catch(NegativeArraySizeException e)
		{		
			System.err.println("Array Size is in negative value...");
			 
		}
		finally
		{
		   System.out.println("Resources will be handled here!!");		   
		}
		System.out.println("Main method ended!!!");
	}
}


In the above program exception and resourses both are handled because we have a combination of try-catch and finally.

Note :- In the try block if we write System.exit(0) and if this line is executed then finally block will not be executed.
--------------------------------------------------------------------
Limitation of finally Block :
------------------------------
The following are the limitation of finally block :

1) In order to close the resourses, user is responsible to write finally block manually.

2) Due to finally block the length of the program will be increased.

3) In order to close the resourses inside the finally block, we need  to declare the resourses outside of try block.


package com.ravi.basic;

import java.util.InputMismatchException;
import java.util.Scanner;

public class FinallyLimitation 
{
	public static void main(String[] args) 
	{
		Scanner sc = null;
		try
		{
			sc = new Scanner(System.in);   
			System.out.print("Enter your Age :");  
			int age = sc.nextInt();
			System.out.println("Your Age is :"+age);
		}
		catch(InputMismatchException e)  
		{
			System.err.println("Please provide numberic value only ");
		}
		finally
		{
			System.out.println("Inside finally block");
			sc.close();			
		}
	}
}
--------------------------------------------------------------------
try with resources :
--------------------
To avoid all the limitation of finally block, Java software people introduced a separate concept i.e try with resources from java 7 onwards.

Case 1:
-------
try(resource1 ; resource2)  //Only the resources will be handled
{
}

Case 2 :
----------
//Resources and Exception both will be  handled
try(resource1 ; resource2) 
{                          
}
catch(Exception e)
{
}

Case 3 :
----------
try with resourses enhancement from java 9v

Resourse r1 = new Resourse();
Resourse r2 = new Resourse();

try(r1; r2)
{
}
catch(Exception e)
{
}


There is a predefined interface available in java.lang package called AutoCloseable which contains predefined abstract method i.e close() which throws Exception.

There is another predefined interface available in java.io package called Closeable, this Closeable interface is the sub interface for AutoCloseable interface.

public interface java.lang.AutoCloseable
{
   public abstract void close() throws Exception;
}
public interface java.io.Closeable extends java.lang.AutoCloseable
{
   void close() throws IOException;
}

Whenever we pass any resourse class object as part of try with resources as a parameter then that class must implements either Closeable or AutoCloseable interface so, try with resourses will automatically call the respective class
close() method even an exception is encountered in the try block.

ResourceClass rc = new ResourceClass();
try(rc)  
{                                              
}                                               
catch(Exception e)                             
{                                          

}

This ResourceClass must implements either Closeable or AutoCloseable interface so, try block will automatically call the close() method as well as try block will get the guarantee of close() method support in the respective class.


The following program explains how try block is invoking the close() method available in DatabaseResource class and FileResourse class.

3 files :
----------
DatabaseResourse.java
-----------------------
package com.ravi.try_with_resourse;

public class DatabaseResourse implements AutoCloseable
{
	@Override
	public void close() throws Exception 
	{
		System.out.println("Database Resourse Closed...");		
	}

}

FileResourse.java
------------------
package com.ravi.try_with_resourse;

import java.io.Closeable;
import java.io.IOException;

public class FileResourse implements Closeable
{
	@Override
	public void close() throws IOException
	{
		System.out.println("File Resourse Closed..");
		
	}

}

Main.java
-----------
package com.ravi.try_with_resourse;

public class Main {

	public static void main(String[] args) throws Exception
	{
		var dr = new DatabaseResourse();
		var fr = new FileResourse();
		try(dr;fr)
		{
			System.out.println(10/0);
		}

	}

}
--------------------------------------------------------------------
//Program to close Scanner class automatically using try with resourses

package com.ravi.try_with_resourse;

import java.util.InputMismatchException;
import java.util.Scanner;

public class TryWithResourse1 {

	public static void main(String[] args)
	{
		Scanner sc = new Scanner(System.in);
		
		try(sc)
		{
			System.out.print("Enter your Roll :");
			int roll = sc.nextInt();
			System.out.println("Your Roll is :"+roll);
		}
		catch(InputMismatchException e)
		{
			System.err.println("Please provide numeric value");
		}
		System.out.println("Execution Completed");

	}

}

Note :- Scanner class internally implementing Closeable interface so it is providing auto closing facility from java 1.7, as a user we need to pass the reference of Scanner class inside try with resources try()


Whenver we write try with resourses then automatically compiler will generate finally block internally to close the resourses automatically.
====================================================================
16-11-2024
-----------
Nested try block :
------------------
If we write a try block inside another try block then it is called Nested try block.

try  //Outer try             
{
  statement1;
     try  //Inner try
     {
        statement2;
     }
     catch(Exception e) //Inner catch
     {
     }
}
catch(Exception e) //Outer Catch
{
}

The execution of inner try block depends upon outer try block that means if we have an exception in the Outer try block then inner try block will not be executed.
--------------------------------------------------------------------
package com.ravi.basic;

public class NestedTryBlock 
{
	public static void main(String[] args) 
	{		
	      try  //outer try
	      {
	    	    String x = null;
	    	    System.out.println("It's length is :"+x.length());
	    	        
		    	  try  //inner try
		    	  {
		    		 String y = "NIT"; 
		    		 int z = Integer.parseInt(y);
		    		 System.out.println("z value is :"+z);	    				    		  
		    	  }
		    	  catch(NumberFormatException e)
		    	  {
		    		System.err.println("Number is not in a proper format");  
		    	  }
	      }
	      catch(NullPointerException e)
	      {
	    	  System.err.println("Null pointer Problem"); 	    	 
	      }	      
	}
}
------------------------------------------------------------------
Writing try-catch inside catch block :
---------------------------------------
We can write try-catch inside catch block but this try-catch block will be exceuted if the catch block will executed that means if we have an exception in the try block.

package com.ravi.basic;

import java.util.InputMismatchException;
import java.util.Scanner;

public class TryWithCatchInsideCatch 
{	
	public static void main(String[] args)
	{
		Scanner sc = new Scanner(System.in);
		
		try(sc )
		{			
			System.out.print("Enter your Roll number :");
			int roll = sc.nextInt();
			System.out.println("Your Roll is :"+roll);			
			
		}	
		catch(InputMismatchException e)
		{
			System.err.println("Provide Valid input!!");
			
			try
			{
				System.out.println(10/0);
			}
			catch(ArithmeticException e1)
			{
			  System.err.println("Divide by zero problem");	
			}
			
		}
		finally
		{
			try
			{
				throw new ArrayIndexOutOfBoundsException("Array is out of bounds");
			}
			catch(ArrayIndexOutOfBoundsException e)
			{
				System.err.println("Array is out of Bounds");
			}
		}
	}

}

Note : inside finally block we can write try catch block.
--------------------------------------------------------------------
try-catch with return statement
-------------------------------
If we write try-catch block inside a method and that method is returning some value then we should write return statement in both the places i.e inside the try block as well as inside the catch block.

We can also write return statement inside the finally block only, if the finally block is present. After this return statement we cannot write any kind of statement. (Unrechable)

Always finally block return statement having more priority then try-catch return statement.

-------------------------------------------------------------------
package com.ravi.advanced;
public class ReturnExample
{
    public static void main(String[] args) 
    {     	
       System.out.println(methodReturningValue());        
    }	
	
	
	public static int methodReturningValue()
    {
        try
        {
            System.out.println("Try block");
            return 10/0;    
        }
        catch (Exception e)
        {
            System.out.println("catch block");         
           return 20;  //return statement is compulsory  
        }
        
               
    }
}
--------------------------------------------------------------------
package com.ravi.advanced;

public class ReturnExample1 {

	public static void main(String[] args)
	{
		System.out.println(m1());
	}

	@SuppressWarnings("finally")
	public static int m1()
	{	
		try
		{
			System.out.println("Inside try");
			return 100;
		}
		catch(Exception e)
		{
			System.out.println("Inside Catch");
			return 200;
		}
		finally
		{
			System.out.println("Inside finally");
			return 300;
		}
		
		// System.out.println("....");   Unreachable line
	}
}
--------------------------------------------------------------------
Initialization of a variable in try and catch :
-----------------------------------------------
A local variable must be initialized inside try block as well as catch block OR at the time of declaration.

If we initialize inside the try block only then from catch block we cannot access local variable value, Here initialization is compulsory inside catch block.
--------------------------------------------------------------------
package com.ravi.basic;

public class VariableInitialization 
{
	public static void main(String[] args)
	{      
	   int x;
	   try
	   {		   
		 x = 100;
		 System.out.println(x);
	   }
	   catch(Exception e)
	   {
		   x = 200;
		   System.out.println(x);
	   }      
       System.out.println("Main completed!!!");
	}

}
--------------------------------------------------------------------
**Difference between Checked Exception and Unchecked Exception :
----------------------------------------------------------------
Checked Exception :
----------------------
A checked exception is a common exception that must be throws or handled by the application code where it is thrown, Here compiler takes very much care and wanted the clarity regarding the exception by saying that, by using this code you may face some problem at runtime and you did not report me how would you handle this situation at runtime are called Checked exception, so provide either try-catch or declare the method as throws.

Except RuntimeException, all the checked exceptions are directly sub class of java.lang.Exception OR Throwable.

Eg:
---
FileNotFoundException, IOException, InterruptedException,ClassNotFoundException, SQLException, CloneNotSupportedException, EOFException and so on

Unchecked Exception :-
--------------------------
An unchecked exception is rare and any exception that does not need to be throw by throws keyword or handled by the application code where it is thrown, here compiler does not take any care are called unchecked exception.

Unchecked exceptions are directly entertain by JVM because they are rarely occurred in java.

All the un-checked exceptions are sub class of RuntimeException

RuntimeException is also Unchecked Exception.

All the Errors comes under Unchecked Exception.

Eg:
---
ArithmeticException, ArrayIndexOutOfBoundsException, NullPointerException, NumberFormatException, ClassCastException, ArrayStoreException and so on.
-----------------------------------------------------------------
Some Bullet points regarding Checked and Unchecked :
-----------------------------------------------------
Checked Exception :
------------------
  1) Common Exception
  2) Compiler takes care (Will not compile the code)
  3) Handling is compulsory (try-catch OR throws)
  4) Directly the sub class of java.lang.Exception OR Throwable

Unchecked Exception :
----------------------
  1) Rare Exception
  2) Comiler will not take any care
  3) Handling is not Compulsory
  4) Sub class of RuntimeException

When to provide try-catch or declare the method as throws :-
-----------------------------------------------------------
try-catch
----------
We should provide try-catch if we want to handle the exception in the method where checked exception is encountered, as well as if we want to provide user-defined messages to the client.

throws :
--------
throws keyword describes that the method might throw an Exception, It also might not. It is used only at the end of a
method declaration to indicate what exceptions it supports OR what type of Exception it might throw which will be handled by JVM (not recommended) or caller method.

Note :- It is always better to use try catch so we can provide appropriate user defined messages to our client.

--------------------------------------------------------------------
*Why compiler takes very much care regarding the checked Exception ?
---------------------------------------------------------------
As we know Checked Exceptions are very common exception so in case of checked exception "handling is compulsory" because checked Exception depends upon other resources as shown below.

IOException (we are depending upon System Keyboard OR Files )
FileNotFoundException(We are depending upon the file)
InterruptedException (Thread related problem)
ClassNotFoundException (class related problem)
SQLException (SQL related or database related problem)
CloneNotSupportedException (Object is the resourse)
EOFException(We are depending upon the file)
--------------------------------------------------------------------
18-11-2024
-----------
* What is the difference between throw and throws :
----------------------------------------------------
throw [THROWING THE EXCEPTION OBJCET EXPLICITLY.]
------------------------------------------------------
We should use throw keyword to throw the exception object explicitly, In case of try block, try block is responsible to create the exception object with JVM as well as throw the exception object to the nearest catch block 
but if a developer wants to throw exception object explicitly then we use throw keyword.

           throw new ArithmeticException();
	   throw new LowBalanceException();

after using throw keyword the control will transfer to the nearest catch block so after throw keyword statement, the remaining statements are un-reachable.

throws :- 
---------
throws keyword describes that the method might throw an Exception, It also might not. It is used only at the end of a
method declaration to indicate what exceptions it supports OR what type of Exception it might throw.

It is used to skip from the current situation so now the execption will be propagated to the caller method OR JVM for 
handling purpose.

It is mainly used to work with Checked Exception.
--------------------------------------------------------------------
Types of exception in java :
-------------------------------
Exception can be divided into two types :

1) Predefined Exception OR Built-in Exception

2) Userdefined Exception OR Custom Exception

Predefined Exception :-
-------------------------
The Exceptions which are already defined by Java software people for some specific purposes are called predefined Exception or Built-in exception.
Ex :
----
IOException, ArithmeticException and so on

Userdefined Exception :-
---------------------------
The exceptions which are defined by user according to their own use and requirement are called User-defined Exception.

Ex:-
----
InvalidAgeException, GreaterMarksException
-----------------------------------------------------------------------
How to develop User-defined Exceptions :
-----------------------------------------
As a developer we can develop user-defined checked and user-defined unchecked exception.

If we want to develop checked exception then our user-defined class must extends from java.lang.Exception, on the other hand if we want to develop un-checked exception then our user-defined class must extends from java.lang.RuntimeException.

In the user-defined exception class, we should write No argument constructor(in case if we don't want to pass any error message) and we should write parameterized constructor with String errorMessage as a parameter (in case if we  want to pass any error message) with super keyword.

In order to throw the exception object explicitly we should use throw keyword as well as our user-defined class object must be of Throwable type.
--------------------------------------------------------------------
class Test extends Throwable
{
	public Test(String errorMessage)
	{
	  super(errorMessage);
	}
}

public class CustomDemo 
{
	public static void main(String[] args) 
	{		
		try
		{
			throw new Test("Test Problem");
		}
		catch(Throwable e)
		{			
		}

	}

}


Here Test class is extending from Throwable class so it is throwable type of Object hence we can use throw keyword and it is also Checked Exception so handling is compulsory.
--------------------------------------------------------------------
//Program to develop user-defined Checked Exception :
----------------------------------------------------
package com.ravi.myexception;

import java.util.Scanner;

@SuppressWarnings("serial")
class InvalidAgeException extends Exception
{
	public InvalidAgeException()
	{
		
	}
	public InvalidAgeException(String errorMessage)
	{
		super(errorMessage);
	}
}

public class CustomCheckedException {

	@SuppressWarnings("resource")
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		try(sc)
		{
			System.out.print("Enter your Age :");
			int age = sc.nextInt();
			
			if(age < 18)
			{
				throw new InvalidAgeException("Age is Invalid");
			}
			else
			{
				System.out.println("You can vote");
			}
		}
		catch(InvalidAgeException e)
		{
			System.err.println(e);
		}

		System.out.println("Main method completed");
		
	}

}

--------------------------------------------------------------------
//Program to develop Unchecked Exception :
-------------------------------------------
package com.ravi.myexception;

import java.util.Scanner;

@SuppressWarnings("serial")
class GreaterMarksException extends RuntimeException
{
	public GreaterMarksException()
	{
		
	}
	public GreaterMarksException(String errorMessage)
	{
		super(errorMessage);
	}
}

public class CustomUnchecked {

	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		try(sc)
		{
			System.out.print("Enter your Marks :");
			int marks = sc.nextInt();
			
			if(marks > 100)
			{
				throw new GreaterMarksException("Invalid Marks");
			}
			else
			{
				System.out.println("Your Marks is :"+marks);
			}
		}
		catch(GreaterMarksException e)
		{
			System.err.println(e);
			System.out.println("............");
			e.printStackTrace();
			System.out.println("............");
			System.err.println(e.getMessage());
			
		}
		System.out.println("Main method Completed");

	}

}
--------------------------------------------------------------------
Some Basic rule we should follow while dealing with Checked Exception :

a) If the try block does not throw any checked exception then in the corresponding catch block we can't handle checked exception.It will generate compilation error i.e "exception never thrown from the corresponding try statement"

Example :-

public class Test 
{
	public static void main(String[] args) 
	{
		try
		{
	          //try block is not throwing checked exception
		  //i.e. InterruptedException
		}
		catch (InterruptedException e) //error
		{
		}

	}

}

Note :- The above rule is not applicable for Unchecked Exception

               try
		{
			
		}
		catch(ArithmeticException e)  //Valid
		{
			e.printStackTrace();
		}
-----------------------------------------------------------------------
b) If the try block does not throw any exception then in the corresponding catch block we can write Exception OR Throwable because both are the super classes for all types of Exception whether it is checked or unchecked.

package com.ravi.method_related_rule;

import java.io.EOFException;
import java.io.FileNotFoundException;

public class CatchingWithSuperClass 
{
	public static void main(String[] args) 
	{		
		try
		{
			
		}
		catch(Exception e)  //Exception OR Throwable both are allowed
		{
          e.printStackTrace();			
		}

	}

}
--------------------------------------------------------------------
c) At the time of method overriding if the super class method does not reporting or throwing checked exception then the overridden method of sub class not allowed to throw checked exception otherwise it will generate compilation error but overridden method can throw Unchecked Exception.


package com.ravi.method_related_rule;

class Super
{
	public void show()  
	{
		System.out.println("Super class method not throwing checked Exception");
	}
}
class Sub extends Super
{
	@Override
	public void show() // throws InterruptedException
	{
		System.out.println("Sub class method should not throw checked Exception");
	}
}

public class MethodOverridingWithChecked {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
--------------------------------------------------------------------
d) If the super class method declare with throws keyword to throw a checked exception, then at the time of method overriding, sub class method may or may not use throws keyword.
               If the Overridden method is also using throws
 keyword to throw checked exception then it must be either same exception class or sub class, it should not be super class as well as we can't add more exceptions in the overridden method.

package com.ravi.method_related_rule;

import java.io.FileNotFoundException;
import java.io.IOException;

class Base
{
	public void show() throws FileNotFoundException
	{
		System.out.println("Super class method ");
	}
}
class Derived extends Base
{
	public void show() //throws IOException
	{
		System.out.println("Sub class method ");
	}
}

public class MethodOverridingWithThrows 
{
	public static void main(String[] args) 
	{
	  System.out.println("Overridden method may or may not throw checked exception but if it is throwing then must be same or sub class");	
	}

}

e) Just like return keyword we can't use throw keyword inside static and non static block  to throw an exception because all initializers must be executed normally.

We can use throw keyword in the protection of try-catch so the code will be executed normally.


public class Test  
{	
	static
	{
		try
		{
			throw new ArithmeticException();
		}
		catch (Exception e)
		{
		}
	}
	
	public static void main(String [] args) 
	{		
       
  	}
}
-------------------------------------------------------------------
Sunday : 9:30AM to 11AM  Object class and its Method, record class

                         enum, I/O, File Handling, FI
			 

Multithreading, Collections [Generics, Concurrent Collection +
                              Stream API]
			      
Logical Session : Arrays and String
----------------------------------------------------------------------
19-11-2024
----------
Exception propagation [Propagation of Exception from Callee to Caller]
------------------------------------------------------------------
Whenever we call a method and if the the callee method contains any kind of exception (checked OR Unchecked) and if callee method doesn't contain any kind of exception handling mechanism (try-catch OR throws) then JVM will propagate the exception to caller method for handling purpose. This is called Exception Propagation.

If the caller method also does not contain any exception handling mechanism then JVM will terminate the method from the stack frame hence the remaining part of the method(m1 method) will not be executed even if we handle the exception in another caller method like main.

If any of the the caller method does not contain any exception handling mechanism then exception will be handled by JVM, JVM has default exception handler which will provide the exception message and terminates the program abnormally.[19-NOV]

//Exception Propagation with checked exception :

package com.ravi.exception_propagation;

public class ExceptionPropagationDemo1 {

	public static void main(String[] args) throws InterruptedException
	{
		System.out.println("Main method started....");
		m1();
		System.out.println("Main method ended....");
	}

	public static void m1() throws InterruptedException
	{
		System.out.println("m1 method started....");
		m2();
		System.out.println("m1 method ended....");
	}
	
	public static void m2() throws InterruptedException
	{		
		throw new InterruptedException();
		
	}
	
}
Note : Here we have checked exception so, to compile the program we need to handle the exception or declare (throws), Here we are decalring throws so exception will be propagated to the caller method for handling purpose, any of the called method is not hanling the InterruptedException so, JVM will handle and terminate the program
abonormally.

//Program on unchecked using Exception propagation
package com.ravi.exception_propagation;

public class ExceptionPropagationDemo1 {

	public static void main(String[] args) 
	{
		System.out.println("Main method started....");
		try
		{
			m1();
		}
		catch(ArithmeticException e)
		{
			System.out.println("Handled in main");
		}
		System.out.println("Main method ended....");
	}

	public static void m1() 
	{
		System.out.println("m1 method started....");
		m2();
		System.out.println("m1 method ended....");
	}
	
	public static void m2() 
	{		
		System.out.println(10/0);
		
	}
	
}
-----------------------------------------------------------------------
Calling methods with checked and un-checked exception :
--------------------------------------------------------
package com.ravi.exception_propagation;

public class MethodCalling {

	public static void main(String[] args) throws InterruptedException
	{
		m1();
	}
	
	public static void m1() throws InterruptedException
	{
	
	}

}

In the above program, Compiler will not generate any error but exception will be un-handled (handled by JVM default exception handler)
----------------------------------------------------------------------
package com.ravi.exception_propagation;

public class MethodCalling {

	public static void main(String[] args) 
	{
		System.out.println("Main");
		try
		{
			m1();
		}
		catch(InterruptedException e)
		{
		  System.out.println("Handled By user");	
		}
	}
	
	public static void m1() throws InterruptedException
	{
	
	}

}
-----------------------------------------------------------------------
Multithreading :
-----------------

Uniprocessing :- 
----------------
In uniprocessing, only one process can occupy the memory So the major drawbacks are 

1) Memory is westage
2) Resources are westage
3) Cpu is idle

To avoid the above said problem, multitasking is introduced.

In multitasking multiple tasks can concurrently work with CPU so, our task will be completed as soon as possible.

Multitasking is further divided into two categories.

a) Process based Multitasking
b) Thread based Multitasking


Process based Multitasking :
----------------------------
If a CPU is switching from one subtask(Thread) of one process to another subtask of another process then it is called Process based Multitasking.

Thread based Multitasking :
---------------------------
If a CPU is switching from one subtask(Thread) to another subtask within the same process then it is called Thread based Multitasking.


20-11-2024
-----------
What is Thread in java ?
-------------------------
A thread is light weight process and it is the basic unit of CPU which can run concurrently with another thread within the same context (process).

It is well known for independent execution. The main purpose of multithreading to boost the execution sequence.

A thread can run with another thread concurrently within the same process so our task will be completed as soon as possible.

In java whenever we define main method then JVM internally creates a thread called main thread under main group.

Program that describes that main is a Thread :
-----------------------------------------------
Whenever we define main method then JVM will create main thread internally under main group, the purpose of this main thread to execute the entire main method code.

In java there is a predefined class called Thread available in java.lang package, this class contains a predefined static factory method currentThread() which will provide currently executing Thread Object.

  public native static Thread currentThread()

Thread t = Thread.currentThread(); //static Factory Method

Thread class has provided predefined method getName() to get the name of the Thread.
                 
		 public String getName();

MainThread.java
----------------
package com.ravi.thread;

public class MainThread {

	public static void main(String[] args)
	{
		//String threadName = Thread.currentThread().getName();
		//System.out.println("Current Thread Name is :"+threadName);

		                    //OR
		  Thread thread = Thread.currentThread();
		  System.out.println("Current Thread name is :"+thread.getName());
	}

}
----------------------------------------------------------------------
How to create user-defined thread ?
-----------------------------------
We can create user-defined thread by using the following two packages 

  1) By using java.lang package [JDK 1.0]
  2) By using java.util.concurrent sub package [JDK 1.5]

Creating user-defind Thread by using java.lang package :
--------------------------------------------------------
By using java.lang package we can create user-defined thread by using any one of the following two approaches :

 1) By extending java.lang.Thread class
 2) By implementing java.lang.Runnable interface 

 Note :- Thread is a predefined class available in java.lang package where as Runnable is a predefined interface available in java.lang Package.
 ------------------------------------------------------------------

Creating a user thread by extends Thread class approach :
----------------------------------------------------------
 
 package com.ravi.thread;

class Test extends Thread
{
	@Override
	public void run()
	{
		System.out.println("Child Thread is running in a separate Stack Memory");
	}
}

public class UserThread
{
	public static void main(String[] args) 
	{
	   System.out.println("Main Thread started");
	   Test t1 = new Test();
	   t1.start();  
	   System.out.println("Main Thread ended");
	}
}



In the above program, we have two threads, main thread which is responsible to execute main method and Thread-0 thread which is responsible to execute run() method. [20-NOV-24]

In entire Multithreading start() is the only method which is responsible to create a new thread.
-----------------------------------------------------------------
public synchronized void start() :
-----------------------------------
start() is a predefined non static method of Thread class which internally performs the following two tasks :

1) It will make a request to the O.S to assign a new thread for concurrent execution.

2) It will implicitly call run() method on the current object.
-----------------------------------------------------------------
21-11-2024
-----------
public final boolean isAlive() :-
-----------------------------
It is a predefined non static method of Thread class through which we can find out whether a thread has started or not ?

As we know a new thread is created/started after calling start() method so if we use isAlive() method before start() method, it will return false but if the same isAlive() method if we invoke after the start() method, it will return true.

We can't restart a thread in java if we try to restart then It will generate an exception i.e java.lang.IllegalThreadStateException

package com.ravi.basic;

class Foo extends Thread
{
	@Override
	public void run()
	{
		System.out.println("Child thread is running...");
		System.out.println("It is running with separate stack");		
	}	
}
public class IsAlive 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Thread started...");
		
		Foo f1 = new Foo();
		System.out.println("Is Thread alive : "+f1.isAlive()); //false
		f1.start();
		System.out.println("Thread is alive or not : "+f1.isAlive()); //true
		
		f1.start();  //java.lang.IllegralThreadStateException
		
		System.out.println("Main Thread ended...");
		
		
	}
}
-----------------------------------------------------------------
package com.ravi.basic;

class Stuff extends Thread
{
	@Override
	public void run() 
	{		
		System.out.println("Child Thread is Running!!!!");
	}	
}
public class ExceptionDemo 
{
	public static void main(String[] args)
	{		
		System.out.println("Main Thread Started");			
				
		Stuff s1 = new Stuff(); 
		Stuff s2 = new Stuff(); 
		
		
		s1.start();
		s2.start();
		
		System.out.println(10/0);
		
		System.out.println("Main Thread Ended");
	}

}

Note :- Here main thread is interrupted due to AE but still child thread will be executed because child threads are executing with separate Stack
----------------------------------------------------------------
package com.ravi.basic;

class Sample extends Thread
{
	
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName();	//Thread-0		

		for(int i=1; i<=10; i++)
		{
			System.out.println(i+" by "+name+" Thread ");
		}
	}
}

public class ThreadLoop 
{	
	public static void main(String[] args) 
	{	
	   Sample s1 = new Sample();
	   s1.start();
	   
	   
	   String name = Thread.currentThread().getName();	//Main	

		for(int i=1; i<=10; i++)
		{
			System.out.println(i+" by "+name+" Thread ");
		}
		
		int x = 1;
		do
		{
			System.out.println("India");
			x++;
		}
		while(x <=10);
	   
	   
	}
}

Note : Here processor is frequently switching from main thread to Thread-0 thread so output is un-predicatable
-----------------------------------------------------------------
How to set and get the name of the Thread : 
--------------------------------------------------
Whenever we create a userdefined Thread in java then by default JVM assigns the name of thread is Thread-0, Thread-1, Thread-2 and so on.

If a user wants to assign some user defined name of the Thread, then Thread class has provided a predefined method called setName(String name) to set the name of the Thread.

On the other hand we want to get the name of the Thread then Thread class has provided a predefined method called getName().

public final void setName(String name)  //setter

public final String getName()  //getter
-----------------------------------------------------------------
package com.ravi.basic;
class DoStuff extends Thread  
{
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName();
		System.out.println(name +" thread is running Here!!!!");
	}
}
public class ThreadName 
{
	public static void main(String[] args) throws InterruptedException 
	{
		DoStuff t1 = new DoStuff(); 
		DoStuff t2 = new DoStuff(); 
		
		t1.start();			
		t2.start();	
		
			
	System.out.println(Thread.currentThread().getName()+" thread is running.....");
	}
}

Note :- If we don't provide our user-defined name for the thread then by default the name would be Thread-0, Thread-1, Thread-2 and so on.
-----------------------------------------------------------------
package com.ravi.basic;
class Demo extends Thread
{
	@Override
	public void run()
	{
		System.out.println(Thread.currentThread().getName()+" thread is running.....");	
	}
}
public class ThreadName1 
{
	public static void main(String[] args) 
	{
	  Thread t =  Thread.currentThread();
	  t.setName("Parent"); //Changing the name of the main thread
	  
	   Demo d1 = new Demo();
	   Demo d2 = new Demo();
	   
	   d1.setName("Child1");
	   d2.setName("Child2");
	   
	   d1.start();  d2.start();
	   
	   String name = Thread.currentThread().getName();
	   System.out.println(name + " Thread is running Here..");
	}
}

In the above program we have assigned user-defined name to the Thread so it will take the name given by the user.
-----------------------------------------------------------------
package com.ravi.basic;

import java.util.InputMismatchException;
import java.util.Scanner;

class BatchAssignment extends Thread
{
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName();
		
		if(name !=null && name.equalsIgnoreCase("Placement"))
		{
			this.placementBatch();
		}
		else if(name !=null && name.equalsIgnoreCase("Regular"))
		{
			this.regularBatch();
		}
		else
		{
			throw new NullPointerException("Name can't be null");
		}
	}
	
	public void placementBatch()
	{
		System.out.println("I am a placement batch student.");
	}
	
	public void regularBatch()
	{
		System.out.println("I am a Regular batch student.");
	}
}


public class ThreadName2 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);	
		try(sc)
		{
			System.out.print("Enter your Batch Title :");
			String title = sc.next();
			
			BatchAssignment b = new BatchAssignment();
			b.setName(title);
			
			b.start();
		}
		catch(InputMismatchException e)
		{
			System.out.println("Invalid Input");
		}
		
		
	}

}
-----------------------------------------------------------------
Thread.sleep(long millisecond) :
-------------------------------
If we want to put a thread into temporarly waiting state then we should use sleep() method.

The waiting time of the Thread depends upon the time specified by the user in millisecond as parameter to sleep() method.

It is a static method of Thread class.

Thread.sleep(1000); //Thread will wait for 1 second


It is throwing a checked Exception i.e InterruptedException because there may be chance that this sleeping thread may be interrupted by a thread so provide either try-catch or declare the method as throws.
------------------------------------------------------------------
package com.ravi.basic;

class Sleep extends Thread
{
   @Override
   public void run() 
   {
	 
	   for(int i=1; i<=10; i++)
	   {
		   System.out.println("i value is :"+i);
		   try
		   {
			   Thread.sleep(1000);
		   }
		   catch(InterruptedException e)
		   {
			   e.printStackTrace();
		   }
	   }
   }
   
}
public class SleepDemo 
{
	public static void main(String[] args)  
	{
	  	Sleep s = new Sleep();
	  	s.start();
	  	  
	}
}
------------------------------------------------------------------
package com.ravi.basic;

class MyTest extends Thread 
{	
	
	@Override
	public void run()  
	{		
		System.out.println("Child Thread id is :"+Thread.currentThread().getId());  
		
		for(int i=1; i<=5; i++) 
		{
			System.out.println("i value is :"+i); //11  22  33  44  55 
			try
			{
				Thread.sleep(1000);		
				
			}
			catch(InterruptedException e)
			{
				System.err.println("Thread has Interrupted");
			}
		}
	}
}
public class SleepDemo1 
{
	public static void main(String[] args) 
	{		
		System.out.println("Main Thread id is :"+Thread.currentThread().getId());  //1
		
		MyTest m1 = new MyTest();		
		MyTest m2 = new MyTest();
		
		m1.start();
		m2.start();	
		
	}
}
------------------------------------------------------------------
Assignment :
--------------
Thread.sleep(long millis, int nanos) 
===============================================================
Thread life cycle :
-------------------
As we know a thread is well known for Independent execution and it contains a life cycle which internally contains 5 states (Phases). 

During the life cycle of a thread, It can pass from thses 5 states. At a time a thread can reside to only one state of the given 5 states.

1) NEW State (Born state)

2) RUNNABLE state (Ready to Run state) [Thread Pool]

3) RUNNING state

4) WAITING / BLOCKED state

5) EXIT/Dead state

----------------------------------------------------------------------
New State :-
-------------
Whenever we create a thread instance(Thread Object) a thread comes to new state OR born state. New state does not mean that the Thread has started yet only the object or instance of Thread has been created.

Runnable state :-
-------------------
Whenever we call start() method on thread object, A thread moves to Runnable state i.e Ready to run state. Here Thread schedular is responsible to select/pick a particular Thread from Runnable state and sending that particular thread to Running state for execution.

Running state :-
-----------------
If a thread is in Running state that means the thread is executing its own run() method in a separate stack Memory.

From Running state a thread can move to waiting state either by an order of thread schedular or user has written some method(wait(), join() or sleep()) to put the thread into temporarly waiting state.

From Running state the Thread may also move to Runnable state directly, if user has written Thread.yield() method explicitly.

Waiting state :-
------------------
A thread is in waiting state means it is waiting for it's time period to complete OR in some cases it is also waiting for lock (monitor) OR another thread to complete. Once the time period will be completed then it will re-enter inside the Runnable state to complete its remaining task.

Dead or Exit :
----------------
Once a thread has successfully completed its run method in the corresponding stack then the thread will move to dead state. Please remember once a thread is dead we can't restart a thread in java.
---------------------------------------------------------------------
IQ :- If we write Thread.sleep(1000) then exactly after 1 sec the Thread will re-start?

Ans :- No, We can't say that the Thread will directly move from waiting state to Running state. 

The Thread will definetly wait for 1 sec in the waiting state and then again it will re-enter into Runnable state which is control by Thread Schedular so we can't say that the Thread will re-start just after 1 sec.
------------------------------------------------------------------
Anonymous inner class by using Thread class :
----------------------------------------------
 1) Anonymous inner class with reference variable :
 ---------------------------------------------------
package com.ravi.anonymous_thread;

public class AnonymousThreadWithReference 
{
	public static void main(String[] args) 
	{
		Thread t1 = new Thread()
		{
			@Override
			public void run()
			{
				String name = Thread.currentThread().getName();
				System.out.println("Anonymous Thread name is :"+name);
			}
			
		};
		t1.start();
		
		

	}

}

2) Anonymous inner class without reference variable :
-------------------------------------------------------
package com.ravi.anonymous_thread;

public class AnonymousWithoutReference {

	public static void main(String[] args) 
	{
		new Thread()
		{
		   @Override
		   public void run()
		   {
			   String name = Thread.currentThread().getName();
			   System.out.println("Running thread name is :"+name);
		   }
		}.start();
		

	}

}
---------------------------------------------------------------
25-11-2024
-----------
25-11-2024
-----------
join() method of Thread class :
-------------------------------
The main purpose of join() method to put the current thread into waiting state until the other thread finish its execution.

Here the currently executing thread stops its execution and the thread goes into the waiting state. The current thread remains in the wait state until the thread on which the join() method is invoked has achieved its dead state.

It also throws checked exception i.e InterruptedException so better to use try catch or declare the method as throws.

It is a non static method so we can call this method with the help of Thread object reference.

package com.ravi.basic;

class Join extends Thread
{
	@Override
	public void run()
	{
		for(int i=1; i<=5; i++)
		{
			System.out.println("i value is :"+i);
			try
			{
				Thread.sleep(1000);
			}
			catch(InterruptedException e)
			{
				e.printStackTrace();
			}
		}
	}
}

public class JoinDemo 
{
	public static void main(String[] args) throws InterruptedException 
	{
		System.out.println("Main Thread Started!!!!!");
				
		Join j1 = new Join();
		Join j2 = new Join();
		Join j3 = new Join();
		
		j1.start();		
		
		j1.join();
		
		j2.start();
		j3.start();		
						
		System.out.println("Main Thread Ended");
	}

}

Note : Here Thread-0 (j1) thread will complete its task then only 
       main thread will wake up to start Thread-1(j2) and Thread-2
       (j3) thread.
-------------------------------------------------------------------
package com.ravi.basic;

class Alpha extends Thread   
{
	@Override
	public void run()
	{
		Thread t = Thread.currentThread();
		String name = t.getName();	//Alpha_Thread is current thread		
		
		Beta b1 = new Beta();
		b1.setName("Beta_Thread");
        b1.start();  
        try 
        {
			b1.join(); //Alpha thread is waiting 4 Beta Thread to complete
		
			System.out.println("Alpha thread re-started");
		} 
        catch (InterruptedException e) 
        {			
			e.printStackTrace();
		}
		
		for(int i=1; i<=10; i++)
		{
			System.out.println(i+" by "+name);
		}
		
	}
}

public class JoinDemo2 
{
	public static void main(String[] args) 
	{
		Alpha a1 = new Alpha();
		a1.setName("Alpha_Thread");
		a1.start();
	}
}

class Beta extends Thread
{
	@Override
	public void run()
	{
		Thread t = Thread.currentThread();
		String name = t.getName();	
		
		for(int i=1; i<=20; i++)
		{
			System.out.println(i+" by "+name);
			try
			{
				Thread.sleep(500);
			}
			catch(InterruptedException e) {
				
			}
		}
		System.out.println("Beta Thread Ended");
	}
}

Note : Alpha Thread will wait till the completion of Beta Thread.
-------------------------------------------------------------------

package com.ravi.basic;

public class JoinDemo1 
{
	public static void main(String[] args) throws InterruptedException 
	{
       System.out.println("Main Thread started");
       
       Thread t = Thread.currentThread();
       
       for(int i=1; i<=10; i++)
       {
    	   System.out.println(i+" by "+t.getName());
       }
       
       t.join(); //Deadlock
       
       System.out.println("Main Thread completed");
	}
}
--------------------------------------------------------------------
Here, It is a deadlock state because main thread is waiting for main thread to complete.
--------------------------------------------------------------------
Assignment :

join(long millis)
join(long millis, long nanos)
-------------------------------------------------------------------
26-11-2024
-----------
Assigning target by Runnable interface :[Loose Coupling]
----------------------------------------------------------
By using Runnable interface approach we can assign different target to our threads.

RunnableDemo.java
------------------

package com.ravi.multithreading;

class UserThread implements Runnable
{
	@Override
	public void run()
	{
		System.out.println("Work performed by the Thread...");		
	}	
}
public class RunnableDemo 
{
	public static void main(String[] args)
	{
		System.out.println("Main Thread started");
		UserThread ut = new UserThread();
		
		Thread t1 = new Thread(ut);
		t1.start();
		System.out.println("Main Thread started");
		
	}

}

--------------------------------------------------------------------
Assigning different Target by multiple thread :
------------------------------------------------
package com.ravi.multithreading;

class PlacementBatch implements Runnable
{
	@Override
	public void run() 
	{
		System.out.println("Placement Batch Student");		
	}	
}

class RegularBatch implements Runnable
{
	@Override
	public void run() 
	{
		System.out.println("Regular Batch Student");		
	}	
}


public class RunnableDemo1
{
	public static void main(String[] args) 
	{
		Thread t1 = new Thread(new PlacementBatch());
        t1.start();
        
        Thread t2 = new Thread(new RegularBatch());
        t2.start();
        
	}

}
--------------------------------------------------------------------
Thread class constructor :
---------------------------
We have total 10 constructors in the Thread class, The following are commonly used constructor in the Thread class

1) Thread t1 = new Thread();

2) Thread t2 = new Thread(String name);

3) Thread t3 = new Thread(Runnable target);

4) Thread t4 = new Thread(Runnable target, String name);

5) Thread t5 = new Thread(ThredGroup tg, String name);

6) Thread t6 = new Thread(ThredGroup tg, Runnable target);

7) Thread t7 = new Thread(ThredGroup tg, Runnable target, String name);
--------------------------------------------------------------------
Working with Anonymous inner class using Runnable interface :
-------------------------------------------------------------
Case 1 :
--------
package com.ravi.anonymous_runnable;

public class AnonymousDemo1 {

	public static void main(String[] args) 
	{
		Runnable r1 = new Runnable() 
		{		
			@Override
			public void run() 
			{
				String name = Thread.currentThread().getName();
				System.out.println("Current Thread is :"+name);
			}
		};
		Thread t1 = new Thread(r1);  t1.start();
		Thread t2 = new Thread(r1);  t2.start();

	}

}
--------------------------------------------------------------------
Case 2 :
--------
package com.ravi.anonymous_runnable;

public class AnonymousDemo1 {

	public static void main(String[] args) 
	{
		Thread t1 = new Thread(new Runnable()
		{			
			@Override
			public void run() 
			{
				String name = Thread.currentThread().getName();
				System.out.println(name);
			}
		});
		
		t1.start();

	}

}
-------------------------------------------------------------------
Case 3 :
--------
package com.ravi.anonymous_runnable;

public class AnonymousDemo1 {

	public static void main(String[] args) 
	{
		new Thread(new Runnable()
		{			
			@Override
			public void run() 
			{
				String name = Thread.currentThread().getName();
				System.out.println(name);
			}
		}).start();
		
		

	}

}
-------------------------------------------------------------------
Case 4 :
---------
package com.ravi.anonymous_runnable;

public class AnonymousDemo1 {

	public static void main(String[] args) 
	{
		new Thread(()-> System.out.println(Thread.currentThread().getName())).start();
		
		
		new Thread(()-> System.out.println(Thread.currentThread().getName()),"Child1").start();
		
		

	}

}
------------------------------------------------------------------
Drawback of Multithreading :
----------------------------
Multithreading is very good to complete our task as soon as possible but in some situation, It provides some wrong data or wrong result.

In Data Race or Race condition, all the threads try to access the resource at the same time so the result may be corrupted.

In multithreading if we want to perform read operation and data is not updatable then multithreading is good but if the data is updatable data (modifiable data) then multithreading may produce some wrong result or wrong data as shown in the diagram.(26-NOV)
------------------------------------------------------------------
package com.ravi.mt_drawback;

class Customer implements Runnable
{
	private int availableSeat = 1;
	private int wantedSeat;
	
	public  Customer(int wantedSeat)
	{
		this.wantedSeat = wantedSeat;
	}
	
	@Override
	public synchronized void run() 
	{
	  String name = null;
	  
	  if(availableSeat >= wantedSeat)
	  {
		  name = Thread.currentThread().getName();
		  System.out.println(wantedSeat+" seat is reserved for :"+name);
		  availableSeat = availableSeat - wantedSeat;
	  }
	  else
	  {
		  name = Thread.currentThread().getName();
		  System.err.println("Sorry!!"+name+" seat is not available");
	  }
	  
		
		
	}
	
}

public class RailwayReservation {

	public static void main(String[] args) throws InterruptedException 
	{
		Customer c1 = new Customer(1);
		
		Thread scott = new Thread(c1,"Scott");
		Thread smith = new Thread(c1,"Smith");
		
		scott.start();
		smith.start();

	}

}
Here both the Threads will get the ticket
--------------------------------------------------------------------
package com.ravi.mt_drawback_lambda;

class Customer
{
	private double availableBalance = 20000;
	
	
	public void withdraw(double amount)
	{
		String name = null;
		
		if(availableBalance >= amount)
		{
			name = Thread.currentThread().getName();
			System.out.println(name+" has withdraw :"+amount+" amount");
			availableBalance = availableBalance - amount;
			System.out.println("Available balance is :"+availableBalance);
		}
		else
		{
			name = Thread.currentThread().getName();
			System.err.println("Sorry "+name+" U have insufficient balance");
			
		}
		
   }	
}


public class BankingApplication 
{
	public static void main(String[] args) 
	{
		Customer c1 = new Customer();
		
		Runnable r1 = () -> c1.withdraw(20000);
		
		Thread t1 = new Thread(r1,"Scott");
		Thread t2 = new Thread(r1,"Smith");
		
		t1.start();
		t2.start();
		
		
	}

}

Here both the Customer will get the amount.
-------------------------------------------------------------
27-11-2024
------------
**Synchronization :
-------------------
In order to solve the problem of multithreading java software people has introduced synchronization concept.

In order to acheive sycnhronization in java we have a keyword called "synchronized".

It is a technique through which we can control multiple threads but accepting only one thread at all the time.

Synchronization allows only one thread to enter inside the synchronized area for a single object.

Synchronization can be divided into two categories :-

1) Method level synchronization

2) Block level synchronization

1) Method level synchronization :-
-----------------------------------
In method level synchronization, the entire method gets synchronized so all the thread will wait at method level and only one thread will enter inside the synchronized area as shown in the diagram.(27-NOV-24)


2) Block level synchronization
-------------------------------
In block level synchronization the entire method does not get synchronized, only the part of the method gets synchronized so all the thread will enter inside the method but only one thread will enter inside the synchronized block as shown in the diagram (27-NOV-24) 

Note :- In between method level synchronization and block level synchronization, block level synchronization is more preferable because all the threads can enter inside the method so only the PART OF THE METHOD GETS synchronized so only one thread will enter inside the synchronized block.

Note :  Synchronized area is a restricated area, with 
permission only a thread can enter inside synchronized area.
------------------------------------------------------------------
How synchronization logic controls multiple threads ?
------------------------------------------------------
Every Object has a lock(monitor) in java environment and this lock can be given to only one Thread at a time.

Actually this lock is available with each individual object provided by Object class. 

The thread who acquires the lock from the object will enter inside the synchronized area, it will complete its task without any disturbance because at a time there will be only one thread inside the synchronized area(for single Object). *This is known as Thread-safety in java.

The thread which is inside the synchronized area, after completion of its task while going back will release the lock so the other threads (which are waiting outside for the lock) will get a chance to enter inside the synchronized area by again taking the lock from the object and submitting it to the synchronization mechanism.
This is how synchronization mechanism controls multiple Threads.

Note :- Synchronization logic can be done by senior programmers in the real time industry because due to poor synchronization there may be chance of getting deadlock.


//Program on Method Level Synchronization :
package com.ravi.synchronization;

class Table
{
	public synchronized void printTable(int num) 
	{
		for(int i=1; i<=10; i++)
		{
			System.out.println(num+" X "+i+" = "+(num*i));
			try
			{
				Thread.sleep(1000);
			}
			catch(InterruptedException e)
			{
				e.printStackTrace();
			}
		}
		System.out.println("................");
	}
}

public class MethodLevelSynchronization {

	public static void main(String[] args) 
	{
		Table obj = new Table();  //one lock/monitor is available here
		
		Thread t1 = new Thread()
		{
		   @Override
		   public void run()
		   {
			   obj.printTable(5);
		   }
		};
		
		
		Thread t2 = new Thread()
		{
		   @Override
		   public void run()
		   {
			   obj.printTable(10);
		   }
		};
		
		t1.start();
		t2.start();

	}

}
------------------------------------------------------------------
//Program on Block Level Synchronization :
-------------------------------------------
package com.ravi.advanced;

//Block level synchronization

class ThreadName
{
	public void printThreadName()
	{		  		
	  String name = Thread.currentThread().getName();
	  System.out.println("Thread inside the method is :"+name);
			
		   synchronized(this)  //synchronized Block
		   {  			   
			for(int i=1; i<=9; i++)   
			{
				System.out.println("i value is :"+i+" by :"+name);
			}
			System.out.println(".............................");
		   }		
	}
}
public class BlockSynchronization 
{
	public static void main(String[] args)
	{
		ThreadName obj1 = new ThreadName(); //lock is created	
		
		Runnable r1 = () -> obj1.printThreadName();
		
		Thread t1 = new Thread(r1,"Child1"); 
		Thread t2 = new Thread(r1,"Child2"); 
		t1.start(); t2.start();				
	}
}
------------------------------------------------------------------
Limitation/Drawback of Object Level Synchronization :
------------------------------------------------------
From the given diagram it is clear that there is no interference between t1 and t2 thread because they are passing throgh Object1 where as on the other hand there is no interferenec even in between t3 and t4 threads because they are also passing through Object2 (another object).

But there may be chance that with t1 Thread, t3 or t4 thread can enter inside the synchronized area at the same time, simillarly it is also possible that with t2 thread, t3 or t4 thread can enter inside the synchronized area so the conclusion is, synchronization mechanism does not work with multiple Objects.(Diagram 27-NOV-24)

package com.ravi.advanced;
class PrintTable
{
	    public synchronized void printTable(int n)
	    {
	       for(int i=1; i<=10; i++)
	       {
	    	   System.out.println(n+" X "+i+" = "+(n*i));
	    	   try
	    	   {
	    		   Thread.sleep(500);
	    	   }
	    	   catch(Exception e)
	    	   {	    		   
	    	   }
	       }
	       System.out.println(".......................");
	    }	
}

public class ProblemWithObjectLevelSynchronization
{
	public static void main(String[] args) 
	{
		
		PrintTable pt1 = new PrintTable(); //lock1		
		PrintTable pt2 = new PrintTable(); //lock2	
				
		Thread t1 = new Thread()  //Anonymous inner class concept
				{
			       @Override
			       public void run()
			       {
			    	   pt1.printTable(2);	//lock1
			       }			   
				};
		       	        
		        Thread t2 = new Thread()
				{
			       @Override
			       public void run()
			       {
			    	   pt1.printTable(3);	//lock1
			       }			   
				};
		                
		        Thread t3 = new Thread()
				{
			       @Override
			       public void run()
			       {
			    	   pt2.printTable(8);	//lock2
			       }			   
				};
		               
		        Thread t4 = new Thread()
				{
			       @Override
			       public void run()
			       {
			    	   pt2.printTable(9); //lock2
			       }			   
				};
				 t1.start();	t2.start();	 t3.start();  t4.start(); 
	}
}
------------------------------------------------------------------
**Static Synchronization :
------------------------
If we make our synchronized method as a static method then it is called static synchronization.

Here, To call static synchronized method, object is not required.

The thread will take the lock from class but not object because we can call the static method with the help of class name.

Unlike Object, we cann't create multiple classes in the same package.

For synchronized block we can write the following code :

synchronized(ClassName.class)
{

}
------------------------------------------------------------
package com.ravi.advanced;
class MyTable     
{
	 public static synchronized void printTable(int n)  //static synchronization
	    {
	       for(int i=1; i<=10; i++)
	       {
	    	   try
	    	   {
	    		   Thread.sleep(100);
	    	   }
	    	   catch(InterruptedException e)
	    	   {
	    		  System.err.println("Thread is Interrupted...");
	    	   }
	    	   System.out.println(n+" X "+i+" = "+(n*i));
	       }
	       System.out.println("------------------------");
	    }
}
public class StaticSynchronization 
{
	public static void main(String[] args)
	{
			        Thread t1 = new Thread()
					{
				      @Override
				      public void run()
				      {
				    	 MyTable.printTable(5); 
				      }
					};		
					
					Thread t2 = new Thread()
					{
				      @Override
				      public void run()
				      {
				    	  MyTable.printTable(10);
				      }
					};										

					Runnable r3 = ()-> MyTable.printTable(15);
					Thread t3 = new Thread(r3);
					
					t1.start();
					t2.start();	t3.start();
					
		}
}
-----------------------------------------------------------
IQ :
---
In between extends Thread and implements Runnable which one is better and why?

In between extends Thread and implements Runnable, implements Runnable is more better approach due to the following reasons.

1) In extend Thread class approach, We can't extend any other class further
   (Multiple Inheritance not possible by using class) but we can implement multiple interfaces. On the other hand in implements Runnable approach we can extend a single class as well as implement multiple interfaces.
   
2) In extends Thread class all the Thread class properties are available to sub class so sub class is heavy weight, the same thing is not available  while implementing Runnable interface.

3) In extends Thread class approach we have same target for different  Threads but by using implements we can provide different target for  different Threads.

4) In extends Thread class approach we don't have Lambda expression support  but by using Runnable interface we can implement Lambda.

Conclusion :
Implements Runnable Advantage 
1) extend a single class
2) Light weight
3) Assigning different targets (Loose coupling)
3) Implemnting Lambda

-----------------------------------------------------------
Thread Priority :
-----------------
It is possible in java to assign priority to a Thread. Thread class has provided two predefined methods setPriority(int newPriority) and getPriority() to set and get the priority of the thread respectively.

In java we can set the priority of the Thread in numbers from 1- 10 only where 1 is the minimum priority and 10 is the maximum priority.

Whenever we create a thread in java by default its priority would be 5 that is normal priority.

The user-defined thread created as a part of main thread will acquire the same priority of main Thread.

Thread class has also provided 3 final static variables which are as follows :-

Thread.MIN_PRIORITY  :- 01

Thread.NORM_PRIORITY : 05

Thread.MAX_PRIORITY  :- 10

Note :- We can't set the priority of the Thread beyond the limit(1-10) so if we set the priority beyond the limit (1 to 10) then it will generate an exception java.lang.IllegalArgumentException.
------------------------------------------------------------------
package com.ravi.priority;

public class PriorityDemo1 {

	public static void main(String[] args) 
	{
		Thread t1 = new Thread();
		System.out.println(t1.getPriority());

	}

}

Note : default priority of a thread will be 5
------------------------------------------------------------------
Every thread created under main thread will acquire the priority of main thread.

package com.ravi.priority;

class Priority implements Runnable
{
	@Override
	public void run() 
	{
	   int priority = Thread.currentThread().getPriority();	
	   System.out.println("Child Thread priority is :"+priority);
	}
	
}

public class PriorityDemo2 {

	public static void main(String[] args) 
	{
		Thread t = Thread.currentThread();
        t.setPriority(Thread.MAX_PRIORITY);
        
        Thread thread = new Thread(new Priority());
        thread.start();
        
        System.out.println("Main Thread priority is :"+t.getPriority());

	}

}

---------------------------------------------------------------
package com.ravi.priority;

class PriorityCheck implements Runnable
{

	@Override
	public void run()   
	{
		int count = 0;
		for(int i=1; i<=1000000; i++)
		{
			count++;
		}
		
		int priority = Thread.currentThread().getPriority();
		String name = Thread.currentThread().getName();
		
		System.out.println("Thread priority is :"+priority);
		System.out.println("Thread name is :"+name);
		
	}	
}

public class PriorityDemo3 
{

	public static void main(String[] args) 
	{
		PriorityCheck p = new PriorityCheck();
		
		Thread t1 = new Thread(p, "Last");
		Thread t2 = new Thread(p, "First");
		
		t1.setPriority(Thread.MIN_PRIORITY);
		t2.setPriority(Thread.MAX_PRIORITY);
		
		t2.start(); t1.start(); 		

	}

}
Most of time the thread having highest priority will complete its task but we can't say that it will always complete its task first that means Thread schedular dominates Priority of the Thread.
------------------------------------------------------------------
Thread.yield() :
----------------
It is a static method of Thread class.

It will send a notification to thread schedular to stop the currently executing Thread (In Running state) and provide a chance to Threads which are in Runnable state to enter inside the running state having same priority or higher priority than currently executing Thread. 

Here The running Thread will directly move from Running state to Runnable state.

The Thread schedular may accept OR ignore this notification message given by currently executing Thread.

Here there is no guarantee that  after using yield() method the running Thread will move to Runnable state and from Runnable state the thread can move to Running state.[That is the reason yield() method is throwing InterruptedExecption]

If the thread which is in runnable state is having low priority than the current executing thread in Running state, will continue its execution.

*It is mainly used to avoid the over-utilisation a CPU by the current Thread.
------------------------------------------------------------------
package com.ravi.advanced;

public class ThreadYieldMethod 
{
	public static void main(String[] args) 
	{
		Runnable r1 = ()->
		{
			for(int i=1; i<=10; i++)
			{
				String name = Thread.currentThread().getName();

				System.out.println("i value is :"+i+" by thread :"+name);    
				
				
				 if(name.equals("Child1")) 
				  { 
					  Thread.yield(); //Give a chance to Child2 Thread
				  }
				 
			}
		};

		Thread t1 = new Thread(r1,"Child1");
		Thread t2 = new Thread(r1,"Child2");
		
		  
		t1.start();  t2.start();
	}
}
-------------------------------------------------------------
** Inter Thread Communication(ITC) :
------------------------------------
It is a mechanism to communicate or co-ordinate between two synchronized threads within the context to achieve a particular task.

In ITC we put a thread into wait mode by using wait() method and other thread will complete its corresponding task, after completion of the task it will call notify() method so the waiting thread will get a notification to complete its remaining task.

ITC can be implemented by the following method of Object class.

1) public  final void wait() throws InterruptedException

2) public native final void notify()

3) public native final void notifyAll()


public  final void wait() throws InterruptedException :-
-------------------------------------------------------------
It is a predefined non static method of Object class. We can use this method from synchronized area only otherwise we will get IllegalMonitorStateException.

It will put a thread into temporarly waiting state and it will release the Object lock, It will remain in the wait state till another thread provides a notification message on the same object, After getting the lock (not notification message), It will wake up and it will complete its remaining task.

public native final void notify() :-
-------------------------------------
It will wake up the single thread that is waiting on the same object.It will not release the lock , once synchronized area is completed then only lock will be released.

Once a waiting thread will get the notification from the another thraed using notify()/notifyAll() method then the waiting thread will move from Waiting state to Runnable state(Ready to run state)

public native final void notifyAll() :-
----------------------------------------
It will wake up all the threads which are waiting on the same object.It will not release the lock , once synchronized area is completed then only lock will be released.

*Note :- wait(), notify() and notifyAll() methods are defined in Object class but not in Thread class because these methods are related to lock(because we can use these methods from the synchronized area ONLY) and Object has a lock so, all these methods are defined inside Object class.

The following program explains we should use these methods from synchronized area only otherwise we will get java.lang.IllegalMonitorStateException.

package com.ravi.itc;

public class ITCDemo1 {

	public static void main(String[] args) throws InterruptedException 
	{
		Object obj = new Object();
		obj.wait();

	}

}
------------------------------------------------------------
The following program explains if we don't have proper communication between the threads then we will not get proper output.

package com.ravi.itc;

class Test extends Thread
{
	private int val = 0;
	
	@Override
	public void run()
	{
		for(int i=1; i<=10; i++)
		{
			val = val + i;     //1  3   6   10    15
			
			try
			{
				Thread.sleep(200);
			}
			catch(Exception e)
			{
				e.printStackTrace();
			}
		}
		
		
	}
	
	public int getValue()
	{
		return this.val;
	}
	
	
}

public class ITCDemo2 {

	public static void main(String[] args) throws InterruptedException 
	{
		System.out.println("Main Thread Started!!!");
		
		Test t1 = new Test();
		t1.start();
		
		Thread.sleep(200);			
		
		System.out.println(t1.getValue());
	}

}

Note : In the above program there is no communication between main thread and child thread so we can't predict the output
-------------------------------------------------------------
package com.ravi.itc;

class Demo extends Thread
{
	private int val = 0;
	
	@Override
	public void run()
	{
		synchronized(this)
		{
			for(int i=1; i<=10; i++)
			{
				val = val + i;
			}	
			System.out.println("Sending notification");
			notify();
		}
	}
	
	public int getValue()
	{
		return this.val;
	}
}


public class ITCDemo3 {

	public static void main(String[] args) throws InterruptedException 
	{		
		Demo d1 = new Demo();
		d1.start();
						
		synchronized(d1)
		{
			System.out.println("Main thread is waiting here,lock is released");
			d1.wait();
			System.out.println("Main thread wake up");
			System.out.println(d1.getValue());
		}

		
	}

}

Note : Here there is a communication between main thread and child thread so main thread will wake up and complete its remaining task after getting notification and lock.
-------------------------------------------------------------
package com.ravi.itc;

class Customer 
{
	private double balance = 15000;
	
	public synchronized void withdraw(double amount)
	{
		System.out.println("Withdraw is in process");
		
		if(amount > this.balance)
		{
			System.out.println("Balance is not sufficient so calling my parent");
			try
			{
				wait();
			}
			catch(InterruptedException e)
			{
				e.printStackTrace();
			}
		}
		
		this.balance = this.balance - amount;
		System.out.println("Remaining amount after withdraw is :"+this.balance);		
	}
	
	public synchronized void deposit(double amount)
	{
		System.out.println("Deposit is in process");
		this.balance = this.balance + amount;
		System.out.println("Amount after deposit is :"+this.balance);
		notify();
	}
}

public class ITCDemo4 {

	public static void main(String[] args) 
	{
		Customer cust = new Customer();
		
		Thread son = new Thread()
		{
			@Override
			public void run()
			{
				cust.withdraw(20000);
			}
		};
        son.start();
        
        Thread father = new Thread()
        {
        	@Override
			public void run()
			{
				cust.deposit(20000);
			}	
        };
		 
        father.start();
	}

}

Here there is a communication between father and son thread to complete the banking transaction.
-------------------------------------------------------------
30-11-2024
-----------
Program on ITC to book and cancel the ticket :
-----------------------------------------------
package com.ravi.itc;

class TicketSystem 
{
    private int availableTickets = 5;   //availableTickets = 3
    
    public synchronized void bookTicket(int numberOfTickets)  //numberOfTickets = 4
    {
        while (availableTickets < numberOfTickets) // 3 < 4
        {
           System.out.println("Not enough tickets available, Waiting for cancellation...");
            try 
            {
                wait(); 
            }
            catch (InterruptedException e) 
            {
                e.printStackTrace();
            }
        }
        availableTickets = availableTickets - numberOfTickets;  
        
        System.out.println("Booked " + numberOfTickets + " ticket(s). Remaining tickets: " + availableTickets);
        notify(); 
    }

    
    public synchronized void cancelTicket(int numberOfTickets) //numberOfTickets = 3
    {
        availableTickets = availableTickets + numberOfTickets;
        System.out.println("Canceled " + numberOfTickets + " ticket(s). Available tickets: " + availableTickets);
        notify(); 
    }
}


public class ITCDemo5 
{
    public static void main(String[] args) 
    {
        TicketSystem ticketSystem = new TicketSystem(); //lock is available

        Thread bookingThread = new Thread()
        {
        	@Override
            public void run() 
        	{
                int[] ticketsToBook = {2, 4, 1};  //take 4 in the place of 1 (wait())
                
                for (int ticket : ticketsToBook) //ticket = 4
                {
                    ticketSystem.bookTicket(ticket);
                    try 
                    {
                        Thread.sleep(1000); // give some time b/w booking
                    } 
                    catch (InterruptedException e)
                    {
                        e.printStackTrace();
                    }
                }
        	 }        	
        };
        bookingThread.start();
        
        Thread cancellationThread = new Thread()
       	{
        	@Override
            public void run() 
        	{
                int[] ticketsToCancel = {1, 3};
                for (int ticket : ticketsToCancel) //ticket = 3
                {
                    ticketSystem.cancelTicket(ticket);
                    try 
                    {
                        Thread.sleep(1500);  // give some time b/w cancellation
                    } 
                    catch (InterruptedException e) 
                    {
                        e.printStackTrace();
                    }
                }
            }
        };
        cancellationThread.start();      
        
        
    }
}
------------------------------------------------------------------
package com.ravi.itc;

class Resource 
{
    private boolean flag = false;

    public synchronized void waitMethod() 
	{
		System.out.println("Wait");
		
       	while (!flag)
		{
          try 
		  {
             System.out.println(Thread.currentThread().getName() + " is waiting...");
             wait(); 
          } 
		  catch (InterruptedException e) 
		  {
                e.printStackTrace();
          }
        }
        System.out.println(Thread.currentThread().getName() + " thread completed!!");
    }

    public synchronized void setMethod() 
	{
		System.out.println("notifyAll");
		this.flag = true;
        System.out.println(Thread.currentThread().getName() + " has make flag value as a true");
        notifyAll(); // Notify all waiting threads that the signal is set
    }
}

public class ITCDemo6
{
    public static void main(String[] args) 
		{
        Resource r1 = new Resource(); //lock is created

        Thread t1 = new Thread(() -> r1.waitMethod(), "Child1");
		Thread t2 = new Thread(() -> r1.waitMethod(), "Child2");
		Thread t3 = new Thread(() -> r1.waitMethod(), "Child3");

		t1.start();
        t2.start();
        t3.start();
       
		
		Thread setter = new Thread(() -> r1.setMethod(), "Setter_Thread");
      
		   try 
			{
	            Thread.sleep(2000);
	        } 
			catch (InterruptedException e) 
			{
	            e.printStackTrace();
	        }
		
	       setter.start();
    }
}
--------------------------------------------------------------
ThreadGroup :
------------
It is a predefined class available in java.lang Package.

By using ThreadGroup class we can put 'n' number of threads into a single group to perform some common/different operation.

By using ThreadGroup class constructor, we can assign the name of group under which all the thread will be executed.

ThreadGroup tg = new ThreadGroup(String groupName);

ThreadGroup class has provided the following methods :

public String getName() : To get the name of the Group

pubic int activeCount() : How many thread are running under that particular group.

Thread class has provided constructor to put the thread into particular group.

Thread t1 = new Thread(ThreadGroup tg, Runnable target, String name);

By using ThreadGroup class, multiple threads will be executed under single group.
---------------------------------------------------------------
package com.ravi.group;

class Foo implements Runnable
{
	@Override
	public void run() 
	{
		String name = Thread.currentThread().getName();
		for(int i =1; i<3; i++)
		{
			System.out.println(i+" by "+name+ " thread");
			
		}
	}	
}

public class ThreadGroupDemo1 
{
  public static void main(String[] args) throws InterruptedException 
  {
	 ThreadGroup tg = new ThreadGroup("NIT_Thread");
	 

	 Thread t1 = new Thread(tg, new Foo(), "Child1");
	 Thread t2 = new Thread(tg, new Foo(), "Child2");
	 Thread t3 = new Thread(tg, new Foo(), "Child3");
	 Thread t4 = new Thread(tg, new Foo(), "Child4");
	 
	 t1.start();  t2.start(); t3.start(); t4.start();
	 
	 //Thread.sleep(4000);
	 
	 System.out.println("Thread Group Name :"+tg.getName());
	 System.out.println("Active threads are :"+tg.activeCount());
	 
  }
}
------------------------------------------------------------------
package com.ravi.group;

public class ThreadGroupDemo2 {

	public static void main(String[] args) 
	{
		Thread t = Thread.currentThread();
		System.out.println(t.toString());

	}

}


Output : Thread[#1main, 5, main]

Here first main is the name of the Thread, 5 is the priority and last main represents group name.

Whenever we define a main method then internally, main group is created and under this main group main thread is executed.
------------------------------------------------------------------
package com.ravi.group;

class TatkalTicket implements Runnable
{
	@Override
	public void run() 
	{
		String name = Thread.currentThread().getName();
		System.out.println("Tatkal ticket booked by :"+name);
		
	}
	
}

class PremiumTatkal implements Runnable
{
	@Override
	public void run() 
	{
		String name = Thread.currentThread().getName();
		System.out.println("Premium Tatkal ticket booked by :"+name);
		
	}	
}

public class ThreadGroupDemo3 
{
	public static void main(String[] args) 
	{
		ThreadGroup tg1 = new ThreadGroup("Tatkal Ticket");		
		ThreadGroup tg2 = new ThreadGroup("Premium Tatkal");
		
		Thread t1 = new Thread(tg1,new TatkalTicket(), "Scott");		
		Thread t2 = new Thread(tg2,new PremiumTatkal(), "Smith");
		
		t1.start(); t2.start();
		

	}

}
------------------------------------------------------------------
Daemon Thread [Service Level Thread]
------------------------------------
Daemon thread is a low- priority thread which is used to provide background maintenance.  

The main purpose of of Daemon thread to provide services to the user thread.              

JVM can't terminate the program till any of the non-daemon (user) thread is active, once all the user thread will be completed then JVM will automatically terminate all Daemon threads, which are running in the background to support user threads.

The example of Daemon thread is Garbage Collection thread, which is running in the background for memory management.

In order to make a thread as a  Daemon thread , we should use setDaemon(true) which is a non static method Thread class.
-----------------------------------------------------------------
public class DaemonThreadDemo1 
{
  public static void main(String[] args) 
	{
	    System.out.println("Main Thread Started...");

        Thread daemonThread = new Thread(() -> 
		{
            while (true) 
			{
                System.out.println("Daemon Thread is running...");
                try 
				{
                    Thread.sleep(1000);
                } 
				catch (InterruptedException e) 
				{
                    e.printStackTrace();
                }
            }
        });

        daemonThread.setDaemon(true); 
        daemonThread.start();

        
        Thread userThread = new Thread(() -> 
		{
            for (int i=1; i<=19; i++) 
			{
                System.out.println("User Thread: " + i);
                try 
				{
                    Thread.sleep(2000);
                } 
				catch (InterruptedException e) 
				{
                    e.printStackTrace();
                }
            }
        });

        userThread.start();

        System.out.println("Main Thread Ended...");
    }
}
------------------------------------------------------------------
02-12-2024
----------
interrupt Method of Thread class :
----------------------------------
It is a predefined non static method of Thread class. The main purpose of this method to disturb the execution of the Thread, if the thread is in waiting or sleeping state.

Whenever a thread is interupted then it throws InterruptedException so the thread (if it is in sleeping or waiting mode) will get a chance to come out from a particular logic.

Points :-
---------
If we call interrupt method and if the thread is not in sleeping or waiting state then it will behave normally.

If we call interrupt method and if the thread is in sleeping or waiting state then we can stop the thread  gracefully.

*Overall interrupt method is mainly used to interrupt the
thread safely so we can manage the resources easily.

Methods :
---------
1) public void interrupt () :- Used to interrupt the Thread but the thread must be in sleeping or waiting mode.

2) public boolean isInterrupted() :- Used to verify whether thread is interrupted or not.

------------------------------------------------------------------
class Interrupt extends Thread
{
   @Override
   public void run()
	{
	   Thread t = Thread.currentThread();
	   System.out.println(t.isInterrupted()); 
       
	   for(int i=1; i<=5; i++)
		{
		   System.out.println(i);  
           try
		   {
			Thread.sleep(1000);
		   }
		   catch (Exception e)
		   {
			   System.err.println("Thread is Interrupted ");
			   e.printStackTrace();
		   }
		   
		}
	}
}
public class  InterruptThread
{
	public static void main(String[] args) 
	{
        Interrupt it = new Interrupt();
		System.out.println(it.getState());  //NEW
		it.start();
		it.interrupt();  //main thread is interrupting the child thread	
	}
}
-----------------------------------------------------------------
class Interrupt extends Thread
{
	@Override
   public void run()
	{
	   try
	   {
	    Thread.currentThread().interrupt();

	   for(int i=1; i<=10; i++)
		{
		   System.out.println("i value is :"+i);
		   Thread.sleep(1000);
		}

	   }
		catch (InterruptedException e)
		{
			System.err.println("Thread is Interrupted :"+e);
		}
		System.out.println("Child thread completed...");
	}
}
public class  InterruptThread1
{
	public static void main(String[] args) 
	{	
		Interrupt it = new Interrupt();
		it.start();	
	}
}

Note : Here child thread is interrupting itself.
------------------------------------------------------------------
public class InterruptThread2
{
    public static void main(String[] args) 
	{
        Thread thread = new Thread(new MyRunnable());
        thread.start();
     
        try 
		{
           Thread.sleep(3000);  //Main thread is waiting for 3 Sec
        } 
		catch (InterruptedException e) 
		{
            e.printStackTrace();
        }
        
       thread.interrupt();  
    }
}

class MyRunnable implements Runnable 
{
    @Override
    public void run() 
	{
        try 
		{
            while (!Thread.currentThread().isInterrupted())
			{
                System.out.println("Thread is running by locking the resource");
                Thread.sleep(500);
            }
        } 
		catch (Exception e) 
		{
            System.out.println("Thread interrupted gracefully.");
        } 
		finally 
		{
            System.out.println("Thread resource can be release here.");
        }
    }
}
-------------------------------------------------------------
Deadlock :
------------
It is a situation where two or more than two threads are in blocked state forever, here threads are waiting to acquire another thread resource without releasing it's own resource.

This situation happens when multiple threads demands same resource without releasing its own attached resource so as a result we get Deadlock situation and our execution of the program will go to an infinite state as shown in the diagram. (02-DEC-24)

public class DeadlockExample
	{
  public static void main(String[] args) 
	 {
     String resource1 = "Ameerpet";  
     String resource2 = "S R Nagar";  

    // t1 tries to lock resource1 then resource2

    Thread t1 = new Thread() 
		{
	  @Override
      public void run() 
		  {
			  synchronized (resource1) 
				  {
			   System.out.println("Thread 1: locked resource 1");
			      try 
				   { 
				   Thread.sleep(1000);
				   } 
				   catch (Exception e) 
				   {}				  
				  				  
			   synchronized (resource2) //Nested synchronized block
			   {
				System.out.println("Thread 1: locked resource 2");
			   }
             }
      }
    };


    // t2 tries to lock resource2 then resource1
    Thread t2 = new Thread() 
	{
      @Override
      public void run() 
	  {
        synchronized (resource2) 
			{
          System.out.println("Thread 2: locked resource 2");
              try 
			  { 
			  Thread.sleep(1000);
			  } 
			  catch (Exception e) 
			  {}

          synchronized (resource1) //Nested synchronized block
		  {
            System.out.println("Thread 2: locked resource 1");
          }
        }
      }
    };    
    t1.start();
    t2.start();
  }
}

Note : Here this situation is known as Deadlock situation because both the threads are waiting for infinite state.
------------------------------------------------------------------
Remaining methods of Object class :
-----------------------------------
protected native Object clone() throws CloneNotSupportedException
---------------------------------------------------------------
Object cloning in Java is the process of creating an exact copy of the original object. In other words, it is a way of creating a new object by copying all the data and attributes from the original object. 

The clone method of Object class creates an exact copy of an object.

In order to use clone() method , a class must implements Clonable interface because we can perform cloning operation on Cloneable objects only [JVM must have additional information].

We can say an object is a Cloneable object if the corresponding class implements Cloneable interface.

It throws a checked Exception i.e CloneNotSupportedException

Note :- clone() method is not the part of Clonable interface[marker interface], actually it is the method of Object class.

clone() method of Object class follow deep copy concept so hashcode will be different as well as if we modify one object content then another object content will not be modified.

clone() method of Object class has protected access modifier so we need to override clone() method in sub class.
------------------------------------------------------------------
package com.ravi.clone_demo;

class Customer implements Cloneable
{
	private Integer custId;
	private String customerName;
	
	public Customer(Integer custId, String customerName) 
	{
		super();
		this.custId = custId;
		this.customerName = customerName;
	}	

	public void setCustId(Integer custId) {
		this.custId = custId;
	}




	public void setCuatomerName(String customerName) {
		this.customerName = customerName;
	}




	@Override
	public String toString() {
		return "Customer [custId=" + custId + ", customerName=" + customerName + "]";
	}
	
	@Override
	public Object clone() throws CloneNotSupportedException
	{
		return super.clone();
	}
	
}

public class CloneDemo 
{
	public static void main(String[] args) throws CloneNotSupportedException 
	{
		Customer c1 = new Customer(111, "Scott");		
		Customer c2 = (Customer) c1.clone();    
		
		System.out.println(c1);
		System.out.println(c2);
		
		c2.setCustId(222);
		c2.setCuatomerName("Smith");
		
		System.out.println(c1);
		System.out.println(c2);
		
		System.out.println(c1.hashCode());
		System.out.println(c2.hashCode());
		

	}

}

Steps to follow for dveloping of above program :
-------------------------------------------------
1) class must implements from Cloneable
2) Override clone() method from Object class
3) Invoke clone() method in the protection of try-catch OR throws
4) Perform downcasting
-------------------------------------------------------------

protected void finalize() throws Throwable :
---------------------------------------------
It is a predefined method of Object class.

Garbage Collector automatically call this method just before an object is eligible for garbage collection to perform clean-up activity.

Here clean-up activity means closing the resources associated with that object like file connection, database connection, network connection and so on we can say resource de-allocation.

Note :- JVM calls finalize method only one per object.

         This method is deprecated from java 9V.
-------------------------------------------------------------
package com.ravi.finalize_demo;

class Product
{
	private Integer productId;
	private String productName;
	
	public Product(Integer productId, String productName)
	{
		super();
		this.productId = productId;
		this.productName = productName;
	}

	@Override
	public String toString() {
		return "Product [productId=" + productId + ", productName=" + productName + "]";
	}
	
	@Override
	public void finalize()
	{
		System.out.println("Product object is eligible for GC");
		//close all the resourses here
	}	
}


public class FinalizeDemo1 {

	public static void main(String[] args) throws InterruptedException 
	{
		Product p1 = new Product(111, "Laptop");
		System.out.println(p1);
		
		p1 = null;
		
		System.gc();
		
		Thread.sleep(3000);
		
		System.out.println(p1);

	}

}

Note : If Product object is eligible for GC then JVM will defnetly call finalize() method of Product class.
-------------------------------------------------------------

*What is the difference between final, finally and finalize

final :- It is a keyword which is used to provide some kind of          restriction like class is final, Method is
         final,variable is final.

finally :- if we open any resource as a part of try block then       that particular resource must be closed inside 
	   finally block otherwise program will be terminated ab-normally and the corresponding resource will not be closed (because the remaining lines of try block will not be executed)

finalize() :- It is a method which JVM is calling automatically just before object  destruction so if any resource (database, file and network) is associated with
	      that particular object then it will be closed
	      or de-allocated by JVM by calling finalize().
------------------------------------------------------------
Record class in java :
-----------------------
public abstract class Record extends Object.

record Student(){} //final class Student extends Record [Compiler generated code]

It is a new feature introduced from java 17.(In java 14 preview version)

As we know only objects are moving in the network from one place to another place so we need to write BLC class with nessacery requirements to make BLC class as a Data carrier class.

Records are immutable data carrier so, now with the help of record we can send our immutable data (final data) from one application to another application.

It is also known as DTO (Data transfer object) OR POJO (Plain Old Java Object) classes.

It is mainly used to concise our code as well as remove the boiler plate code.

In record, automatically constructor will be generated which is known as canonical constructor and the variables which are known as components are by default final.

In order to validate the outer world data, we can write our own constructor which is known as compact constructor.

Record will automatically generate the implemenation of toString(), equals(Object obj) and hashCode() method.

We can define static and non static method as well as static variable  and static block inside the record. We cannot define instance variable and instance block inside the record.

We cann't extend or inherit records because by default every record is implicilty final and It is extending from java.lang.Reocrd class, which is an abstract class.

We can implement an interface by using record.

We don't have setter facility in record because by default components are final.

------------------------------------------------------------
3 files :
----------
EmployeeClass.java
-------------------
package com.ravi.record;

import java.util.Objects;

public class EmployeeClass 
{
	private Integer employeeId;
	private String employeeName;

	public EmployeeClass(Integer employeeId, String employeeName)
	{
		super();
		this.employeeId = employeeId;
		this.employeeName = employeeName;
	}

	@Override
	public String toString() {
		return "EmployeeClass [employeeId=" + employeeId + ", employeeName=" + employeeName + "]";
	}

	public Integer getEmployeeId() {
		return employeeId;
	}

	public void setEmployeeId(Integer employeeId) {
		this.employeeId = employeeId;
	}

	public String getEmployeeName() {
		return employeeName;
	}

	public void setEmployeeName(String employeeName) {
		this.employeeName = employeeName;
	}

	@Override
	public int hashCode() {
		return Objects.hash(employeeId, employeeName);
	}

	@Override
	public boolean equals(Object obj) 
	{
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		EmployeeClass other = (EmployeeClass) obj;
		return Objects.equals(employeeId, other.employeeId) && Objects.equals(employeeName, other.employeeName);
	}
}

EmployeeRecord.java(R)
-----------------------
package com.ravi.record;

 //Canonical Constructor   +   Components
public record EmployeeRecord(int employeeId, String emloyeeName) 
{	
	
   //Compact Constructor
	public EmployeeRecord
	{
		if(employeeId <= 0)
		{
			System.err.println("Id is Invalid");
		}
		
	}
	
}

ClassAndRecordComparison.java
------------------------------
package com.ravi.record;

public class ClassAndRecordComparison {

	public static void main(String[] args)
	{
		EmployeeClass c1 = new EmployeeClass(111, "Scott");
		System.out.println(c1);
		EmployeeClass c2 = new EmployeeClass(111, "Scott");
		System.out.println(c1.equals(c2));
		System.out.println(c1.getEmployeeName());
		
		
		System.out.println("==========================");
		
		EmployeeRecord r1 = new EmployeeRecord(-222, "Smith");
		System.out.println(r1);
		EmployeeRecord r2 = new EmployeeRecord(222, "Smith");
		System.out.println(r1.equals(r2));
		System.out.println(r1.emloyeeName());

	}

}
=============================================================

Collection Frameworks in Java (40 - 45% IQ):
---------------------------------------------
 Collections framework is nothing but handling individual Objects(Collection Interface) and Group of objects(Map interface).

We know only object can move from one network to another network.  

A collections framework is a class library to handle group of Objects.

It is implemented by using java.util package.

It provides an architecture to store and manipulate group of objects.

All the operations that we can perform on data such as searching, sorting, insertion and deletion can be done by using collections framework because It is the data structure of Java.

The simple meaning of collections is single unit of Objects.
---------------------------------------------------------------

It provides the following sub interfaces :

1) List (Accept duplicate elements)
2) Set (Not accepting duplicate elements)
3) Queue (Storing and Fetching the elements based on some order i.e FIFO)

Note : Collection is a predefined interface available in java.util package where as Collections is a predefined class which is available from JDK 1.2V which contains only static methods (Constructor is private)
---------------------------------------------------------------
Methods of Collection interface :
----------------------------------
a) public boolean add(E element) :- It is used to add an item/element in the in the collection.

b) public boolean addAll(Collection c) :- It is used to insert the specified collection elements in the existing collection(For merging the Collection)

c) public boolean retainAll(Collection c) :- It is used to retain all the elements from existing element. (Common Element)

d) public boolean removeAll(Collection c) :- It is used to delete all the elements from the existing collection.

e) public boolean remove(Object element) :- It is used to delete an element from the collection based on the object.

f) public int size() :- It is used to find out the size of the Collection [Total number of elements available]

g) public void clear() :- It is used to clear all the elements at once from the Collection.

All the above methods of Collection interface will be applicable to all the sub interfaces like List, Set and Queue.
---------------------------------------------------------------
List interface :
----------------
List is the sub interface of Collection interface available from JDK 1.2V.

List interface accepts duplicate elements.

It stores the elements based on the order (index wise) hence It supports all the index related methods.

By using Collections.sort(List list) we can perform sorting operation on List interface.
---------------------------------------------------------------
List interface hierarchy [05-Dec]
---------------------------------------------------------------
Behaviour of List interface Specific classes :
-----------------------------------------------
* It stores the elements on the basis of index.
* It can accept duplicate, homogeneous and hetrogeneous elements.
* It stores everything in the form of Object.
* When we accept the collection classes without generic concept then  compiler generates a warning message because It is unsafe object.
* By using generic (<>) we can eliminate compilation warning and  still we can take homogeneous as well as hetrogeneous.(<Object>)
* In list interface few classes are dynamically Growable like Vector and ArrayList. [06-DEC]
--------------------------------------------------------------
Methods of List interface :
--------------------------
1) public boolean isEmpty() :- Verify whether List is empty or not

2) public void clear() :- Will clear all the elements, Basically List will become empty.

3) public int size() :- To get the size of the Collections(Total number of elements are available in the collection)

4) public void add(int index, Object o) :- Insert the element based on the index position.

5) public boolean addAll(int index, Collection c) :- Insert the Collection based on the index position

6) public Object get(int index) :- To retrieve the element based on the index position

7) public Object set(int index, Object o) :- To override or replace the existing element based on the index position

8) public Object remove(int index) :- remove the element based on the index position

9) public boolean remove(Object element) :-  remove the element based on the object element, It is the Collection interface method extended by List interface 

10) public int indexOf() :- index position of the element

11) public int lastIndex() :- last index position of the element

12) public Iterator iterator() :- To fetch or iterate or retrieve the elements from Collection in forward direction only.

13) public ListIterator listIterator() :- To fetch or iterate or retrieve the elements from Collection in forward and backward direction.
---------------------------------------------------------------
**How many ways we can fetch the Collection Object ?
----------------------------------------------------
There are 9 ways to fetch the Collection Object which are as follows :

1) By using toString() method of the respective class [JDK 1.0]
2) By using Ordinary for loop [JDK 1.0]
3) By using forEach loop [JDK 1.5]
4) By using Enumeration interface [JDK 1.0]
5) By using Iterator interface [JDK 1.2]
6) By using ListIterator interface [JDK 1.2]
7) By using SplIterator interface [JDK 1.8]
8) By using forEach(Consumer<T> cons) [JDK 1.8]
9) By using Method Reference [JDK 1.8]

Note : Among all these, Enumeration, Iterator, ListIterator and 
       SplIterator are the cursors so the control will move 
       from one direction to another direction.
-----------------------------------------------------------------
Enumeration :
----------------
It is a predefined interface available in java.util package from JDK 1.0 onwards(Legacy interface).

We can use Enumeration interface to fetch or retrieve the Objects one by one from the Collection because it is a cursor.

We can create Enumeration object by using elements() method of the legacy Collection class. Internally it uses anonymous inner class object.

public Enumeration elements();   

Enumeration interface contains two methods :
---------------------------------------------------
1) public boolean hasMoreElements() :- It will return true if the Collection is having more elements.

2) public Object nextElement() :- It will return collection object so return type is Object and move the cursor to the next line.

Note :- It will only work with legacy Collections classes.
---------------------------------------------------------------
Iterator interface :
----------------------
It is a predefined interface available in java.util package available from 1.2 version.

It is used to fetch/retrieve the elements from the Collection in forward direction only because it is also a cursor.

public Iterator iterator();

Example :
-----------
 Iterator itr = fruits.iterator();

Now, Iterator interface has provided two methods 


public boolean hasNext() :- 

It will verify, the element is available in the next position or not, if available it will return true otherwise it will return false.

public Object next() :- It will return the collection object and move the cursor to the element object.
---------------------------------------------------------------
ListIterator interface :
-------------------------
It is a predefined interface available in java.util package and it is the sub interface of Iterator available from JDK 1.2v.

It is used to retrieve the Collection object in both the direction i.e in forward direction as well as in backward direction.

public ListIterator listIterator();

Example :
-----------
ListIterator lit =   fruits.listIterator();

1) public boolean hasNext() :- 
It will verify the element is available in the next position or not, if available it will return true otherwise it will return false.

2) public Object next() :- It will return the next position collection object.

3) public boolean hasPrevious() :- 
It will verify the element is available in the previous position or not, if available it will return true otherwise it will return false.


4) public Object previous () :- It will return the previous position collection object.

Note :- Apart from these 4 methods we have add(), set() and remove() method in ListIterartor interface.
--------------------------------------------------------------
09-12-2024
-----------
Spliterator interface :
-----------------------
It is a predefined interface available in java.util package from java 1.8 version.

It is a cursor through which we can fetch the elements from the 
Collection [Collection, array, Stream]

It is the combination of hasNext() and next() method.

It is using forEachRemaining(Consumer <T>) method for fetching the elements.
--------------------------------------------------------------
By using forEach() method :
--------------------------------
From java 1.8 onwards every collection class provides a method forEach() method, this method takes Consumer functional interface as a  parameter.
This method is avilable in java.lang.Iterable interface.

How forEach(Consumer<T> cons) method works internally ?
-------------------------------------------------------
Case 1 :
---------
package com.ravi.collection;

import java.util.Vector;
import java.util.function.Consumer;

public class ForEachMethodInternal {

	public static void main(String[] args) 
	{
		Vector<String> fruits = new Vector<>();
		fruits.add("Orange");
		fruits.add("Apple");
		fruits.add("Mango");
		fruits.add("Banana");
		fruits.add("Gauva");
		fruits.add("KIWI");	
		
		//Anonymous inner class
		Consumer<String> cons = new Consumer<>() 
		{
			@Override
			public void accept(String str)
			{
				System.out.println(str);				
			}
		};
		
		fruits.forEach(cons);
		
		

	}

}

Case 2 :
----------
package com.ravi.collection;

import java.util.Vector;
import java.util.function.Consumer;

public class ForEachMethodInternal2 
{
   public static void main(String[] args) 
   {
	   Vector<String> fruits = new Vector<>();
		fruits.add("Orange");
		fruits.add("Apple");
		fruits.add("Mango");
		fruits.add("Banana");
		fruits.add("Gauva");
		fruits.add("KIWI");	
		
		Consumer<String> cons = str -> System.out.println(str);
		
		fruits.forEach(cons);
   }
}

Case 3 :
-------
package com.ravi.collection;

import java.util.Vector;

public class ForEachMethodInternalDemo3
{
	 public static void main(String[] args) 
	   {
		   Vector<String> fruits = new Vector<>();
			fruits.add("Orange");
			fruits.add("Apple");
			fruits.add("Mango");
			fruits.add("Banana");
			fruits.add("Gauva");
			fruits.add("KIWI");			
			
			fruits.forEach(str -> System.out.println(str));
	   }
}
--------------------------------------------------------------
==============================================================
//9 ways to fetch Collection Object.

package com.ravi.collection;

import java.util.Enumeration;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.Spliterator;
import java.util.Vector;

public class RetrieveCollectionObject {

	public static void main(String[] args) 
	{
		Vector<String> fruits = new Vector<>();
		fruits.add("Orange");
		fruits.add("Apple");
		fruits.add("Mango");
		fruits.add("Banana");
		fruits.add("Gauva");
		fruits.add("KIWI");	
		
		System.out.println("FETCHING THE DATA USING TOSTRING METHOD :");
		System.out.println(fruits.toString());
		
		System.out.println("FETCHING THE DATA USING ORDINARY FOR LOOP :");
		for(int i=0; i<fruits.size(); i++)
		{
			System.out.println(fruits.get(i));
		}
		
		System.out.println("FETCHING THE DATA USING FOR EACH LOOP :");
		
		for(String fruit : fruits)
		{
			System.out.println(fruit);
		}
		
		
		System.out.println("FETCHING THE DATA USING ENUMERATION INTERFACE :");
		
         Enumeration<String> ele = fruits.elements();
         
         while(ele.hasMoreElements())
         {
        	 System.out.println(ele.nextElement());
         }
		
         System.out.println("FETCHING THE DATA USING ITERATOR INTERFACE :");
 		
        Iterator<String> itr = fruits.iterator();
		
		while(itr.hasNext())
		{
			System.out.println(itr.next());
		}

		System.out.println("FETCHING THE DATA USING LISTITERATOR INTERFACE :");
		
	   ListIterator<String> lstItr = fruits.listIterator();
	   
	   System.out.println("IN FORWARD DIRECTION");
	   
	   while(lstItr.hasNext())
	   {
		   System.out.println(lstItr.next());
	   } 
	   
	   System.out.println("IN BACKWARD DIRECTION");
	   
	   while(lstItr.hasPrevious())
	   {
		   System.out.println(lstItr.previous());
	   }
		
	   System.out.println("FETCHING BY USING SPLITERATOR :");
	   
	   Spliterator<String> spliterator = fruits.spliterator();
	   spliterator.forEachRemaining(fruit -> System.out.println(fruit));
	   
	   System.out.println("FETCHING BY USING FOREACH METHOD:");
	   fruits.forEach(fruit -> System.out.println(fruit));
	   
	   
	   System.out.println("BY USING METHOD REFERENCE");
	   fruits.forEach(System.out::println);	   
	   
	
	}

}

==============================================================
Working with List interface implemented classes :
--------------------------------------------------
Vector<E> :
-----------
public class Vector<E> extends AbstractList<E>  implements List<E>, Serializable, Clonable, RandomAccess

Vector is a predefined class available in java.util package under List interface. 

Vector is always from java means it is available from jdk 1.0 version.

It can accept duplicate, null, homogeneous as well as hetrogeneous elements.

Vector and Hashtable, these two classes are available from jdk 1.0, remaining Collection classes were added from 1.2 version. That is the reason Vector and Hashtable are called legacy(old) classes.

The main difference between Vector and ArrayList is, ArrayList methods are not synchronized so multiple threads can access the method of ArrayList where as on the other hand most the methods are synchronized in Vector so performance wise Vector is slow.

*We should go with ArrayList when Threadsafety is not required on the other hand we should go with Vector when we need ThreadSafety for reterival operation.

It also stores the elements on index basis.It is dynamically growable with initial capacity 10. The next capacity will be 20 i.e double of the first capacity.

new capacity = current capacity * 2;

It implements List, Serializable, Clonable, RandomAccess interfaces.

Constructors in Vector :
-------------------------
We have 4 types of Constructor in Vector

1) Vector v1 = new Vector();        
     It will create the vector object with default capacity is 10        
    
2) Vector v2 = new Vector(int initialCapacity);     
     Will create the vector object with user specified capacity.

3) Vector v3 = new Vector(int initialCapacity, int capacityIncrement);     
     Eg :-     Vector v = new Vector(1000,5);

     Initially It will create the Vector Object with initial capacity 1000 and then when  the capacity will be full then increment by 5 so the next capacity would be 1005, 1010 and so on.

 4) Vector v4 = new Vector(Collection c);
    We can achieve loose coupling
---------------------------------------------------------------
package com.ravi.vector;

import java.util.Collections;
import java.util.Vector;

public class VectorDemo {

	public static void main(String[] args) 
	{
		Vector<String> listOfCity = new Vector<>();
		listOfCity.add("Hyderabad");
		listOfCity.add("Pune");
		listOfCity.add("Indore");
		listOfCity.add("Bhubneswar");
		listOfCity.add("Kolkata");
		
        Collections.sort(listOfCity);
		
		System.out.println(listOfCity);
		
        listOfCity.remove("Kolkata");  //removing based on the Object		
        
        System.out.println(listOfCity);
		
		listOfCity.remove(3); //removing based on the index
		
		 System.out.println(listOfCity);
		

	}

}
--------------------------------------------------------------
//Vector Program on capacity

package com.ravi.vector;

import java.util.*;

public class VectorDemo1 {
	public static void main(String[] args)
	{
		Vector<Integer> v = new Vector<>(100,10); 
		System.out.println("Initial capacity is :" + v.capacity());

		for (int i = 0; i < 100; i++) 
		{
			v.add(i);
		}

		System.out.println("After adding 100 elements  capacity is :" + v.capacity()); 
		
		v.add(101);
		System.out.println("After adding 101th elements  capacity is :" + v.capacity()); // 200

		v.forEach(System.out::println);

		
	}
}
---------------------------------------------------------------
package com.ravi.vector;

//Array To Collection
import java.util.*;
public class VectorDemo2
{
	public static void main(String args[])
	{
		Vector<Integer> v = new Vector<>();  
		
		int x[]={22,20,10,40,15,58};
 
      //Adding array values to Vector
		for(int i=0; i<x.length; i++)
		{
			v.add(x[i]);
		}		
		Collections.sort(v);
		System.out.println("Maximum element is :"+Collections.max(v));
		System.out.println("Minimum element is :"+Collections.min(v));
		System.out.println("Vector Elements :");
		v.forEach(y -> System.out.println(y));
		System.out.println(".....................");
		Collections.reverse(v);
		v.forEach(y -> System.out.println(y));
	}
}
---------------------------------------------------------------
package com.ravi.vector;

import java.util.Vector;

record Employee(Integer eid, String employeeName, double employeeSal)
{
	
}

public class VectorDemo3
{
  public static void main(String[] args) 
  {
	Vector<Employee> listOfEmployee = new Vector<>();
	listOfEmployee.add(new Employee(111, "Scott", 40000));
	listOfEmployee.add(new Employee(222, "Smith", 50000));
	listOfEmployee.add(new Employee(333, "Scott", 55000));
	listOfEmployee.add(new Employee(444, "Scott", 60000));
	
	
	listOfEmployee.forEach(emp -> System.out.println(emp));
	
  }
}
--------------------------------------------------------------
10-12-2024
-----------
Program that shows performance wise Vector is not good in comparison to ArrayList 

System is a predefined class available in java.lang package and it contains a predefined static method currentTimeMillis() , the return type of this method is long, actually it returns the current time of the system in ms.

   public static native long currentTimeMillis()

//Program to describe that ArrayList is better than Vector in performance

//Program to describe that ArrayList is better than Vector in performance

package com.ravi.vector;

import java.util.ArrayList;
import java.util.Vector;

public class VectorDemo4 
{
	public static void main(String[] args) 
	{
		ArrayList<Integer> al = new ArrayList<>();
		
		long startTime = System.currentTimeMillis();  //2ms
		
		for(int i=1; i<=1000000; i++)
		{
			al.add(i);
		}
		
		long endTime = System.currentTimeMillis();  
		
		System.out.println("Time Taken by ArrayList class :"+(endTime - startTime)+" ms");
		
		
        Vector<Integer> v1 = new Vector<>();
		
		startTime = System.currentTimeMillis();  
		
		for(int i=1; i<=1000000; i++)
		{
			v1.add(i);
		}
		
		endTime = System.currentTimeMillis();  
		
		System.out.println("Time Taken by Vector class :"+(endTime - startTime)+" ms");
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
}
--------------------------------------------------------------
public Object[] toArray() :
----------------------------
It will convert the Collection object into Array.

package com.ravi.vector;

import java.util.Collections;
import java.util.Vector;

public class VectorDemo5
{

	public static void main(String[] args) 
	{
		Vector<String> listOfCity = new Vector<>();
		listOfCity.add("Surat");
		listOfCity.add("Pune");
		listOfCity.add("Ahmadabad");
		listOfCity.add("Vanaras");
		
			
		Collections.sort(listOfCity);
		
		listOfCity.forEach(System.out::println);
		
		System.out.println(".............");
		
		Vector<Integer> listOfNumbers = new Vector<>();
		listOfNumbers.add(500);
		listOfNumbers.add(900);
		listOfNumbers.add(400);
		listOfNumbers.add(300);
		listOfNumbers.add(800);
		listOfNumbers.add(200);
		listOfNumbers.add(100);	
		
		Collections.sort(listOfNumbers, Collections.reverseOrder());
		
		listOfNumbers.forEach(System.out::println);
		
		System.out.println(".............");
		
		//Collection to array [toArray()]
		
		Object[] array = listOfNumbers.toArray();
		System.out.println("Using Array");
		for(Object value : array)
		{
			System.out.println(value);
		}
		
		
		
	}

}
-------------------------------------------------------------
package com.ravi.vector;

import java.util.Scanner;
import java.util.Vector;

public class VectorDemo6
{
    public static void main(String[] args) 
    {        
        Vector<String> toDoList = new Vector<>();

        Scanner scanner = new Scanner(System.in);

        int choice;
        do 
        {
            System.out.println("ToDo List Menu:");
            System.out.println("1. Add Task");
            System.out.println("2. View Tasks");
            System.out.println("3. Mark Task as Completed");
            System.out.println("4. Exit");
            System.out.print("Enter your choice: ");

            choice = scanner.nextInt(); 
            scanner.nextLine(); 

            switch (choice) 
            {
                case 1:
                    // Add Task
                    System.out.print("Enter task description: ");
                    String task = scanner.nextLine();
                    toDoList.add(task);
                    System.out.println("Task added successfully!\n");
                    break;
                case 2:
                    // View Tasks
                    System.out.println("To Do List:");
                    for (int i = 0; i < toDoList.size(); i++) 
                    {
                      System.out.println((i + 1) + ". " + toDoList.get(i));
                    }
                    System.out.println();
                    break;
                case 3:
                    // Mark Task as Completed
                    System.out.print("Enter task number to mark as completed: ");
                    int taskNumber = scanner.nextInt();  //1
                    if (taskNumber >= 1 && taskNumber <= toDoList.size()) 
                    {
                        String completedTask = toDoList.remove(taskNumber - 1);
                        System.out.println("Task marked as completed: " + completedTask + "\n");
                    } else {
                        System.out.println("Invalid task number!\n");
                    }
                    break;
                case 4:
                    System.out.println("Exiting ToDo List application. Goodbye!");
                    break;
                default:
                    System.out.println("Invalid choice. Please enter a valid option.\n");
            }

        } 
        while (choice != 4);

       
        scanner.close();
    }
}
--------------------------------------------------------------
Enumeration interface method :
------------------------------
From JDK 9v, Enumeration interface has provided a predefined default method asIterator(), the return type of this method is 
Iterator.

default Iterator asIterator();

package com.ravi.vector;

import java.util.Enumeration;
import java.util.Iterator;
import java.util.Vector;

record Product(int productId, String productName)
{
	
}

public class VectorDemo7 
{
	public static void main(String[] args) 
	{
		Vector<Product> listOfProduct = new Vector<>();
		listOfProduct.add(new Product(111, "Laptop"));
		listOfProduct.add(new Product(222, "Mobile"));
		listOfProduct.add(new Product(333, "Camera"));
		listOfProduct.add(new Product(444, "Bag"));
		listOfProduct.add(new Product(555, "Watch"));
		
		Enumeration<Product> elements = listOfProduct.elements();
		
		Iterator<Product> asIterator = elements.asIterator();
		asIterator.forEachRemaining(System.out::println);
		          
	}

}
---------------------------------------------------------------
Stack<E>
--------
public class Stack<E> extends Vector<E>

It is a predefined class available in java.util package. It is the sub class of Vector class introduced from JDK 1.0 so, It is also a legacy class. 

It is a linear data structure that is used to store the Objects in LIFO (Last In first out) order.

Inserting an element into a Stack is known as push operation  where as extracting an element from the top of the stack is known as pop operation.

It throws an exception called java.util.EmptyStackException, if Stack is empty and we want to fetch the element.

It has only one constructor as shown below

Stack s = new Stack(); 

Will create empty Stack Object.
------------------------------------------------------------------------------------
Methods :
----------
public E push(Object o) :- To insert an element in the bottom of the Stack.

public E pop() :- To remove and return the element from the top of the Stack.

public E peek() :- Will fetch the element from top of the Stack without removing.

public boolean empty() :- Verifies whether the stack is empty or not (return type is boolean)

public int search(Object o) :- It will search a particular element in the Stack and it returns OffSet position (int value). If the element is not present in the Stack it will return -1

--------------------------------------------------------------
//Program to insert and fetch the elements from stack
package com.ravi.stack;
import java.util.*;
public class Stack1
{
      public static void main(String args[])
      {
            Stack<Integer> s = new Stack<>();
              try
              {
                  s.push(12);
                  s.push(15);
				  s.push(22);
				  s.push(33);
				  s.push(49);				  
				  System.out.println("After insertion elements are :"+s); 

                  System.out.println("Fetching the elements using pop method");
                  System.out.println(s.pop());
                  System.out.println(s.pop()); 
                  System.out.println(s.pop());  
                  System.out.println(s.pop());  
                  System.out.println(s.pop());
                               
                 			  	
	 				 				  
				  System.out.println("After deletion elements are :"+s);
				  
				  System.out.println("Is the Stack empty ? :"+s.empty());  
              }
			catch(EmptyStackException e)
			{
			   e.printStackTrace();
			} 
      }
}
---------------------------------------------------------------
//add(Object obj) is the method of Collection
package com.ravi.stack;
import java.util.*;
public class Stack2
{
      public static void main(String args[])
      {
            Stack<Integer> st1 = new Stack<>();
            st1.add(10);
            st1.add(20);      
            st1.forEach(x -> System.out.println(x));

            Stack<String> st2 = new Stack<>();
            st2.add("Java");  
            st2.add("is");
            st2.add("programming");
            st2.add("language"); 
            st2.forEach(x -> System.out.println(x));

            Stack<Character> st3 = new Stack<>();
            st3.add('A');  
            st3.add('B');
            st3.forEach(x -> System.out.println(x));

            Stack<Double> st4 = new Stack<>();
            st4.add(10.5);
            st4.add(20.5);               
            st4.forEach(x -> System.out.println(x));          
      }  
}
---------------------------------------------------------------
package com.ravi.stack;
import java.util.Stack;  

public class Stack3
{  
	public static void main(String[] args)   
		{  
			Stack<String> stk= new Stack<>();  
			stk.push("Apple");  
			stk.push("Grapes");  
			stk.push("Mango");  
			stk.push("Orange");  
			System.out.println("Stack: " + stk);  
			
			String fruit = stk.peek(); 			
			System.out.println("Element at top: " + fruit);  
			System.out.println("Stack elements are : " + stk); 
		}  
}  

--------------------------------------------------------------
//Searching an element in the Stack
package com.ravi.stack;
import java.util.Stack;  
public class Stack4
{  
	public static void main(String[] args)   
		{  
			Stack<String> stk= new Stack<>();  
			stk.push("Apple");  
			stk.push("Grapes");  
			stk.push("Mango"); 			
			System.out.println("Offset Position is : " + stk.search("Mango")); //1			
			System.out.println("Offser Position is : " + stk.search("Banana")); //-1
		    System.out.println("Is stack empty ? "+stk.empty());	//false
			
			System.out.println("Index Position is : " + stk.indexOf("Mango")); //2
		}  
}  
---------------------------------------------------------------
ArrayList<E> :
------------
public class ArrayList<E>  extends AbstractList<E> implements List<E>, Serializable, Clonable, RandomAccess  

It is a predefined class available in java.util package under List interface from java 1.2v.

It accepts duplicate,null, homogeneous and hetrogeneous elements.

It is dynamically growable array.

It stores the elements on index basis so it is simillar to dynamic array.

Initial capacity of ArrayList is 10. The new capacity of Arraylist can be calculated by using the  formula
new capacity = (current capacity * 3)/2 + 1  [Almost 50% increment]

*All the methods declared inside an ArrayList is not synchronized so multiple thread can access the method of ArrayList. 

*It is highly suitable for fetching or retriving operation when duplicates are allowed and Thread-safety is not required.

Here Iterator is Fail Fast Iteartor.

It implements List,Serializable, Clonable, RandomAccess interfcaes

Constructor of ArrayList :
----------------------------
In ArrayList we have 3 types of Constructor:
Constructor of ArrayList :
----------------------------
We have 3 types of Constructor in ArrayList

1) ArrayList al1 = new ArrayList();
   Will create ArrayList object with default capacity 10.

2) ArrayList al2 = new ArrayList(int initialCapacity);
   Will create an ArrayList object with user specified Capacity

3) ArrayList al3 = new ArrayList(Collection c)
   We can copy any Collection interface implemented class data to the current object   reference (Coping one Collection data to another)
---------------------------------------------------------------
package com.ravi.arraylist;

import java.util.ArrayList;

public class ArrayListDemo
{
    public static void main(String[] args) 
    {
        
        ArrayList<Integer> numbers = new ArrayList<>();
                
        numbers.add(100);
        numbers.add(200);
        numbers.add(300);
        numbers.add(400);
        
        int sum = 0;
        for (int number : numbers) 
        {
            sum += number;
        }

        
        System.out.println("Sum of numbers: " + sum);
    }
}
--------------------------------------------------------------
package com.ravi.arraylist;

import java.util.ArrayList;

record Customer(Integer customerId, String customerName, Double custBill)
{
	
}


public class ArrayListDemo1
{
	public static void main(String[] args) 
	{
	   ArrayList<Customer> al = new ArrayList<>();
	   al.add(new Customer(333, "Rohan",  29789.90));
	   al.add(new Customer(111, "Satish", 23789.90));
	   al.add(new Customer(222, "Aryan",  25789.90));
	   al.add(new Customer(444, "Zuber",  27789.90));
	   
	   al.forEach(System.out::println);
	   
	  
	   
	}
}
---------------------------------------------------------------
package com.ravi.arraylist;

//Program to merge and retain of two collection 
import java.util.*;
public class ArrayListDemo2  
	{
		public static void main(String args[]) 
		{ 
		  ArrayList<String> al1=new ArrayList<>();
		  al1.add("Ravi");
		  al1.add("Rahul");
		  al1.add("Rohit");		  
		  
		  ArrayList<String> al2=new ArrayList<>();
		  al2.add("Pallavi");
		  al2.add("Sweta");
		  al2.add("Puja");		  

		  al1.addAll(al2);  

        al1.forEach(str -> System.out.println(str.toUpperCase()) );

        System.out.println(".................................");

		  ArrayList<String> al3=new ArrayList<>();
		  al3.add("Ravi");
		  al3.add("Rahul");
		  al3.add("Rohit");		  
		  
		  ArrayList<String> al4=new ArrayList<>();
		  al4.add("Pallavi");
		  al4.add("Rahul");
		  al4.add("Raj");
		  
		  al3.retainAll(al4);  

          al3.forEach(x -> System.out.println(x));		  
   }
}
--------------------------------------------------------------
How to create fixed length and Immutable object :
-------------------------------------------------
a) Creating a fixed length array by using asList():
---------------------------------------------------
Arrays class has provided a predefined static method called asList(T ...x), by using this asList() method we create a fixed length array. 

In this fixed lengh array we can't add any new element but we can replace the existing element using new element.

If we try to add a new element then we will get an Excption java.lang.UnsupportedOperationException.

List<E> list = Arrays.asList(T ...x);
----------------------------------------------------------------

package com.ravi.arraylist;

import java.util.Arrays;
import java.util.List;

public class FixedLengthArray {

	public static void main(String[] args) 
	{
		//Fixed length Array
		List<Integer> listOfNumbers = Arrays.asList(1,2,3,4,5,6,7,8);
		listOfNumbers.set(0, 100); //valid
		listOfNumbers.add(9); //Invalid
		System.out.println(listOfNumbers);

	}

}



b) Creating an immutable List by using List.of(E ...x)
-------------------------------------------------------
List interface has provided various static methods called of(E ...x) available from java 9 which creates an immutable List. 

We can't perform any add or replace operation otherwise we will get java.lang.UnsupportedOperationException.

List<E> list = List.of(E ...x)

package com.ravi.arraylist;

import java.util.List;

public class ImmutableList2 {

	public static void main(String[] args)
	{
		//Immutable list 
		List<Integer> listOfNumbers = List.of(1,2,3,4,5,6,7,8);
		listOfNumbers.set(0, 100); //Invalid
		listOfNumbers.add(9); //Invalid
		System.out.println(listOfNumbers);

	}

}
---------------------------------------------------------------
//Program to fetch the elements in forward and backward 
//direction using ListIterator interface

package com.ravi.arraylist;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.ListIterator;

public class ArrayListDemo3   
{                             
public static void main(String args[])
  {
	 List<String> listOfName = Arrays.asList("Rohit","Akshar","Pallavi","Sweta"); //Length is fixed
	 
	 Collections.sort(listOfName);
	 
	 //Fetching the data in both the direction
	 ListIterator<String> lst = listOfName.listIterator();
	 
	 System.out.println("In Forward Direction..");	 
	 while(lst.hasNext())
	 {
		System.out.println(lst.next()); 
	 }
	 System.out.println("In Backward Direction..");	 
	 while(lst.hasPrevious())
	 {
		System.out.println(lst.previous()); 
	 }
	 
  }
}
--------------------------------------------------------------
//Serialization and De-serialization on ArrayList Object
package com.ravi.arraylist;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.ArrayList;

record Product(Integer productId, String productName) implements Serializable
{
	
}


public class ArrayListDemo4
{ 
  public static void main(String[] args) throws IOException 
  {
	ArrayList<Product> listOfProduct = new ArrayList<>();
	listOfProduct.add(new Product(111, "Laptop"));
	listOfProduct.add(new Product(222, "Camera"));
	listOfProduct.add(new Product(333, "Mobile"));
	listOfProduct.add(new Product(444, "Watch"));
	
	//Serialization
	   var fos = new FileOutputStream("D:\\new\\Product.txt");
	   var oos = new ObjectOutputStream(fos);
	   
	   try(fos; oos)
	   {
		   oos.writeObject(listOfProduct);
		   System.out.println("Product Data stored in the file");
	   }
	   catch(Exception e)
	   {
		   e.printStackTrace();
	   }
	
	   //De-serialization
	    var fin = new FileInputStream("D:\\new\\Product.txt");
	    var ois = new ObjectInputStream(fin);
	    
	    try(fin;ois)
	    {
	    	@SuppressWarnings("unchecked")
			ArrayList<Product> list = (ArrayList<Product>) ois.readObject();
	    	System.out.println(list);
	    }
	    catch(Exception e)
	    {
	    	
	    }
	    
	                    
	   
		
  }       
}         
---------------------------------------------------------------
package com.ravi.arraylist;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.Collections;

public class ArrayListDemo5
{
    public static void main(String[] args)
    {        
        ArrayList<String> cities = new ArrayList<>();

        cities.add("Hyderabad");
        cities.add("Delhi");
        cities.add("Banglore");
        cities.add("Chennai");
        
        System.out.println("Before sorting: " + cities);

        Collections.sort(cities);
        System.out.println("After sorting (Ascending): " + cities);

        Collections.sort(cities, Collections.reverseOrder());
        System.out.println("After sorting (Descending): " + cities);
    }
}
---------------------------------------------------------------
package com.ravi.arraylist;

//Program on ArrayList that contains null values as well as we can pass 
//the element based on the index position
import java.util.ArrayList;
import java.util.LinkedList;
public class ArrayListDemo6
{
	public static void main(String[] args) 
	{
		ArrayList<Object> al = new ArrayList<>(); //Generic type
		al.add(12);
		al.add("Ravi");
		al.add(12);		
		al.add(3,"Hyderabad"); 
		al.add(1,"Naresh");
		al.add(null);
		al.add(11);
		System.out.println(al);  
	}
}
---------------------------------------------------------------
package com.ravi.arraylist;

import java.util.ArrayList;
import java.util.List;

record Professor(String name, String specialization)
{
}

class Department 
{
	private String departmentName;
	private List<Professor> professors;
	
	public Department(String departmentName) 
	{
		super();
		this.departmentName = departmentName;
		this.professors = new ArrayList<Professor>();  //Composition
	}
	
	public void addProferssor(Professor professor)
	{
		professors.add(professor);  
	}

	public String getDepartmentName() {
		return departmentName;
	}

	public List<Professor> getProfessors() {
		return professors;
	}

		
}

public class ArrayListDemo7
{
    public static void main(String[] args) 
    {
       Department department = new Department("Computer Science");
       
       department.addProferssor(new Professor("James", "Java"));
       department.addProferssor(new Professor("Martin", "Python"));
       department.addProferssor(new Professor("Scott", ".Net"));
       department.addProferssor(new Professor("Smith", "Adv. Java"));
       
       System.out.println("Department Name is :"+department.getDepartmentName());
       System.out.println("Professors in :"+department.getDepartmentName());
       
       List<Professor> ListOfProfessors = department.getProfessors();
       ListOfProfessors.forEach(System.out::println);
       
      
    }
}
--------------------------------------------------------------
package com.ravi.arraylist;

import java.util.ArrayList;

public class ArrayListDemo8
{
    public static void main(String[] args) 
    {
        ArrayList<String> original = new ArrayList<>();
        original.add("BCA");
        original.add("MCA");
        original.add("BBA");

        @SuppressWarnings("unchecked")
		ArrayList<String> cloneList = (ArrayList<String>) original.clone();
        System.out.println("Cloned List: " + cloneList);

       
        ArrayList<String> copiedList = new ArrayList<>(original);
        System.out.println("Copied List: " + copiedList);
        
        
        
       
    }
}
---------------------------------------------------------------
package com.ravi.arraylist;

import java.util.ArrayList;
import java.util.Vector;

public class LooseCoupling {

	public static void main(String[] args)
	{
		ArrayList<String> cityName = new ArrayList<>();
		cityName.add("Hyd");
		cityName.add("Bglr");
		cityName.add("Kolkata");
		
		
		Vector<String> v1 = new Vector<>(cityName);
		v1.forEach(System.out::println);
		
		

	}

}
--------------------------------------------------------------
package com.ravi.arraylist;

import java.util.ArrayList;
import java.util.List;

public class ArrayListDemo9 {

	public static void main(String[] args) 
	{
		ArrayList<Integer> list = new ArrayList<>();
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(4);
        list.add(5);
        list.add(6);
        list.add(7);
        list.add(8);
        list.add(9);
        list.add(10);
        
        //public List subList(int fromIndex, int toIndex)
        List<Integer> subList = list.subList(2, 5);   
        System.out.println(subList);
        
        System.out.println("........................");
         
        //public boolean contains(Object obj)
        boolean contains = list.contains(9);
        System.out.println(contains);
        
        System.out.println("........................");
        
        //public int indexOf(Object obj)
        System.out.println(list.indexOf(1));   
        
                
        //public boolean removeIf(Predicate<T> filter)
        list.removeIf(num -> num%2==1); 
        System.out.println(list);        
        
	}
}
---------------------------------------------------------------
13-12-2024
-----------
package com.ravi.arraylist;

import java.util.ArrayList;

public class ArrayListDemo10 {

	public static void main(String[] args) 
	{
		ArrayList<String> list = new ArrayList<>(100); 
        list.add("Java");
        list.add("World");
        
        //public void trimToSize()
        list.trimToSize();
        System.out.println("Trimmed List Size: " + list.size()); 
        
        System.out.println(".........................");
        
        
        ArrayList<Integer> listOfNumber = new ArrayList<>();

        // public void ensureCapacity(int minCapacity)
        //Increase the capacity of the ArrayList to avoid frequent resizing.
        listOfNumber.ensureCapacity(100);

        for (int i = 0; i < 50; i++) 
        {
        	listOfNumber.add(i);
        }

        System.out.println("List size: " + listOfNumber.size());
           
        

	}

}
---------------------------------------------------------------
Time Complexcity of ArrayList :
-------------------------------
The time complexcity of ArrayList to insert and delete an element from the middle would be O(n) [Big O of n] because 'n' number of elements will be re-located so, it is not a good choice to perform insertion and deletion operation in the middle of the List. 

On the other hand time complexcity of ArrayList to retrieve an element from the List would be O(1) because by using get(int index) method we can retrieve the element randomly from the list. ArrayList class implements RandomAccess marker interface which provides the facility to fetch the elements Randomly. [13-DEC]
--------------------------------------------------------------
LinkedList :
------------
public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, Serializable

It is a predefined class available in java.util package under List interface from JDK 1.2v.

It is ordered by index position like ArrayList except the elements (nodes) are doubly linked to one another. This linkage provide us new method for adding and removing the elements from the middle of LinkedList.

*The important thing is, LikedList may iterate more slowely than ArrayList but LinkedList is a good choice when we want to insert or delete the elements frequently in the list.

From jdk 1.6 onwards LinkedList class has been enhanced to support basic queue operation by implementing Deque<E> interface.

LinkedList methods are not synchronized.

It inserts the elements by using Doubly linked List so insertion and deleteion is very easy.


ArrayList is using Dynamic array data structure but LinkedList class is using LinkedList (Doubly LinkedList) data structure.

At the time of searching an element, It will start searching from first(Head) node or last node OR the closer one.

**Here Iterators are Fail Fast Iterator.

Constructor:
-------------
It has 2 constructors 

1) LinkedList list1 = new LinkedList();
    It will create a LinkedList object with 0 capacity.

2) LinkedList list2 = new LinkedList(Collection c);
    Interconversion between the collection

Methods of LinkedList class:
-------------------------------
1) void addFirst(Object o)
2) void addLast(Object o)

3) Object getFirst()
4) Object getLast()

5) Object removeFirst()
6) Object removeLast()

Note :- It stores the elements in non-contiguous memory location.           
	   
	   The time complexcity for insertion and deletion is  O(1) The time complexcity for seraching O(n) becuaee it serach the elemnts using node reference.
--------------------------------------------------------------
package com.ravi.linked_list;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
public class LinkedListDemo
{
 public static void main(String args[])
 { 
      LinkedList<Object> list=new LinkedList<>();
	  list.add("Ravi");
	  list.add("Vijay");
	  list.add("Ravi");
	  list.add(null);
	  list.add(42);
	  
	  
	  System.out.println("1st Position Element is :"+list.get(0));

	  //Iterator interface 
	  
	   Iterator<Object> itr = list.iterator();
	   itr.forEachRemaining(System.out::println); //JDK 1.8
	   
	  
	 
  }
}
--------------------------------------------------------------
package com.ravi.linked_list;

import java.util.*;
public class LinkedListDemo1
{
      public static void main(String args[])
      {
           LinkedList<String> list= new LinkedList<>(); //generic
           list.add("Item 2");//2
           list.add("Item 3");//3
           list.add("Item 4");//4
           list.add("Item 5");//5
           list.add("Item 6");//6
           list.add("Item 7");//7
           
           list.add("Item 9"); //10

           list.add(0,"Item 0");//0
           list.add(1,"Item 1"); //1

           list.add(8,"Item 8");//8
		   list.add(9,"Item 10");//9
            System.out.println(list);
			
			 list.remove("Item 5"); 
			  
			  System.out.println(list);
			 
			   list.removeLast(); 
			    System.out.println(list);
			    
			     list.removeFirst(); 
			    System.out.println(list);
			
			  list.set(0,"Ajay"); //set() will replace the existing value
			  list.set(1,"Vijay"); 
			  list.set(2,"Anand"); 
			  list.set(3,"Aman");
			  list.set(4,"Suresh"); 
			  list.set(5,"Ganesh");
			  list.set(6,"Ramesh");
			  list.forEach(x -> System.out.println(x)); 
					
			
      } 
}
---------------------------------------------------------------
package com.ravi.linked_list;

//Methods of LinkedList class
import java.util.LinkedList;
public class LinkedListDemo2
{
    public static void main(String[] argv) 
    {
          LinkedList<String> list = new LinkedList<>();
          
          list.addFirst("Ravi");  //  [  Rahul  ]   
          list.add("Rahul"); 
          list.addLast("Anand");	
          
          System.out.println(list.getFirst()); 
          System.out.println(list.getLast()); 
          
          list.removeFirst();
          list.removeLast(); 
          
          System.out.println(list); 
    }
}
--------------------------------------------------------------

package com.ravi.linked_list;
//ListIterator methods (add(), set(), remove())
import java.util.*;
public class LinkedListDemo3 
{
	public static void main(String[] args) 
	{
		LinkedList<String> city = new LinkedList<> ();
         city.add("Kolkata");
		 city.add("Bangalore");
		 city.add("Hyderabad");
		 city.add("Pune");
		 System.out.println(city);   

		ListIterator<String> lt = city.listIterator();

       while(lt.hasNext())
		  {
			String cityName =  lt.next();

			if(cityName.equals("Kolkata"))
			{
                 lt.remove();
			}
			else if(cityName.equals("Hyderabad"))
			{
                 lt.add("Ameerpet");
			}
			else if(cityName.equals("Pune"))
			{
                 lt.set("Mumbai");
			}
		}
		city.forEach(System.out::println);
	}
}

Here there is no ConcurrentModificationException because ListIterator is modifying the structure by it's own method hence there is no problem because it is internal structure modification.
--------------------------------------------------------------
14-12-2024
----------
package com.ravi.linked_list;

//Insertion, deletion, displaying and exit

import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

public class LinkedListDemo4
{
 public static void main(String[] args)
	{
      List<Integer> linkedList = new LinkedList<>();
      Scanner scanner = new Scanner(System.in);

        while (true) 
		{
          System.out.println("Linked List: " + linkedList); //[]
          System.out.println("1. Insert Element");
          System.out.println("2. Delete Element");
		  System.out.println("3. Display Element");
          System.out.println("4. Exit");
          System.out.print("Enter your choice: ");

          int choice = scanner.nextInt();
          switch (choice) 
			{
              case 1: 
                  System.out.print("Enter the element to insert: ");
                  int elementToAdd = scanner.nextInt();
                  linkedList.add(elementToAdd);
                  break;
              case 2:
                  if (linkedList.isEmpty()) 
					{
                      System.out.println("Linked list is empty. Nothing to delete.");
                  } 
					else 
					{
                      System.out.print("Enter the element to delete: ");
                      int elemenetToDelete = scanner.nextInt();
                      boolean remove = linkedList.remove(Integer.valueOf(elemenetToDelete));                     
                      
                       if(remove)
                       {
                    	   System.out.println("Element "+elemenetToDelete+ " is deleted Successfully" );
                       }
                       else
                       {
                    	   System.out.println(elemenetToDelete+" not available is the LinkedList");
                       }
                    
                  }
                  break;
				case 3:
					System.out.println("Elements in the linked list.");
                    linkedList.forEach(System.out::println);
				     break;
              case 4:
                  System.out.println("Exiting the program.");
                  scanner.close();
                  System.exit(0);
              default:
                  System.out.println("Invalid choice. Please try again.");
          }
      }
  }
}
---------------------------------------------------------------
package com.ravi.linked_list;

import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Stream;

public class LinkedListDemo5 {

	public static void main(String[] args) 
	{	
		
		List<String> listOfName = Arrays.asList("Ravi","Rahul","Ankit", "Rahul");
		
		LinkedList<String> list = new LinkedList<>(listOfName); 
		list.forEach(System.out::println);
		
		
		
		
		               
		
		
		
	}

}
---------------------------------------------------------------
import java.util.LinkedList;
import java.util.Iterator;
import java.util.List;

record Dog(String name)
{
}

public class LinkedListDemo5
{
       public static void main(String[] args)
       {
             List<Dog> list = new LinkedList<>();
             Dog dog = new Dog("Tiger");
             list.add(dog);
             list.add(new Dog("Tommy"));
             list.add(new Dog("Rocky"));

            Iterator<Dog> i3 = list.iterator();
		    i3.forEachRemaining(x -> System.out.println(x.name().toUpperCase())); //java 8      


             System.out.println("size " + list.size());
             System.out.println("Get 1st Position Object " + list.get(1).name());
             
            
        }
}
----------------------------------------------------------
import java.util.Deque;
import java.util.LinkedList;

public class LinkedListDemo6
{
    public static void main(String[] args) 
		{
        // Create a LinkedList and treat it as a Deque
        Deque<String> deque = new LinkedList<>();

        
        deque.addFirst("Ravi");  // Ravi Pallavi 
        deque.addFirst("Raj");   

        
        deque.addLast("Pallavi");   
        deque.addLast("Sweta");

        
        System.out.println("Deque: " + deque);   

       
        String first = deque.removeFirst();
        String last = deque.removeLast();

       
        System.out.println("Removed first element: " + first);
        System.out.println("Removed last element: " + last);
        System.out.println("Updated Deque: " + deque);
    }
}
-----------------------------------------------------------

Set interface :
---------------
Set interface is the sub interface of Collection interface available JDK 1.2v.

Set interface never accept duplicate elements, here internally it uses equals(Object obj) method to eliminte the duplicate element.

IT DOES NOT MAINTAIN ANY ORDER.(No Index)

It is unordered so ListIterator interface will not work with Set interface.

It supports all the methods of Collection interface, some methods are added from java 9v.
-----------------------------------------------------------
Set interface Hierarchy :
-------------------------
Hierarchy is available in the paint diagram [14-DEC-24]
-----------------------------------------------------------
What is hashing algorithm ?
-------------------------------
Hashing algorithm is a technique through which we can search, insert and delete an element in more efficient way in comparison to our classical indexing approach.

Hashing algorithm, internally uses Hashtable data structute, Hashtable data structure internally uses Bucket data structure.

Here elements are inserted by using hashing algorithm so the time complaxity to insert, delete and search an element would be O(1).
-----------------------------------------------------------
HashSet (UNSORTED, UNORDERED , NO DUPLICATES)
---------------------------------------------
public class HashSet<E> extends AbstractSet<E> implements Set<E>, Clonabale, Serializable

It is a predefined class available in java.util package under Set interface and introduced from JDK 1.2V.

It is an unsorted and unordered set.  

It accepts hetrogeneous and homogeneous both kind of data.

*It uses the hashcode of the object being inserted into the Collection. Using this hashcode it finds the bucket location.

It doesn't contain any duplicate elements as well as It does not maintain any order while iterating the elements from the collection.

It can accept one null value.

HashSet methods are not synchronized.

HashSet is used for fast searching operation.

It has constant performance in all the operations like insert, delete and search.

It contains 4 types of constructors :

1) HashSet hs1 = new HashSet();
    It will create the HashSet Object with default capacity is 16. The default load fator or Fill Ratio is 0.75   (75% of HashSet is filled up then new HashSet Object will be created having double capacity)

2) HashSet hs2 = new HashSet(int initialCapacity);
    will create the HashSet object with user specified capacity.


3) HashSet hs3 = new HashSet(int initialCapacity, float loadFactor);
    we can specify our own initialCapacity and loadFactor(by default load factor is 0.75)

4) HashSet hs = new HashSet(Collection c);
    Interconversion of Collection.
-----------------------------------------------------------
//Unsorted, Unordered and no duplicates
import java.util.*;
public class HashSetDemo 
{
 public static void main(String args[])
 { 
	    HashSet<Integer> hs = new HashSet<>();
		hs.add(67); 
		hs.add(89);		
		hs.add(33);
		hs.add(null);
		hs.add(45);
		hs.add(12);
		hs.add(35);			
		hs.forEach(num-> System.out.println(num));
	}
}

-----------------------------------------------------------
import java.util.*;
public class HashSetDemo1
{
      public static void main(String[] argv) 
      {
      HashSet<String> hs=new HashSet<>();	  
	  hs.add("Ravi");  
	  hs.add("Vijay");
	  hs.add("Ravi");
	  hs.add("Ajay");
	  hs.add("Palavi");
	  hs.add("Sweta");
	  hs.add(null);   
	  hs.add(null);
	  hs.forEach(str -> System.out.println(str));

      }
}
-----------------------------------------------------------
package com.ravi.collection_demo;

import java.util.Arrays;
import java.util.HashSet;

public class HashSetDemo2 {

	public static void main(String[] args) 
	{
		Boolean b1[] = new Boolean[6];
		
		HashSet<Object> hs = new HashSet<>();
		
		b1[0] = hs.add(65);  
		b1[1] = hs.add("P");
		b1[2] = hs.add("nit");
		b1[3] = hs.add(new String("nit"));
		b1[4] = hs.add(new StringBuffer("Hyd"));
		b1[5] = hs.add(new StringBuffer("Hyd")); //Unique Object
		
		System.out.println(Arrays.toString(b1));

		System.out.println(hs);
	}

}
-----------------------------------------------------------
//add, delete, display and exit
import java.util.HashSet;
import java.util.Scanner;

public class HashSetDemo3
{
    public static void main(String[] args) 
		{
        HashSet<String> hashSet = new HashSet<>();
        Scanner scanner = new Scanner(System.in);

        while (true) 
		{
            System.out.println("Options:");
            System.out.println("1. Add element");
            System.out.println("2. Delete element");
            System.out.println("3. Display HashSet");
            System.out.println("4. Exit");

            System.out.print("Enter your choice (1/2/3/4): ");
            int choice = scanner.nextInt();

            switch (choice) 
			{
                case 1:
                    System.out.print("Enter the element to add: ");
                    String elementToAdd = scanner.next();
                    if (hashSet.add(elementToAdd)) 
					{
                        System.out.println("Element added successfully.");
                    } 
					else
					{
                        System.out.println("Element already exists in the HashSet.");
                    }
                    break;
                    case 2:
                    System.out.print("Enter the element to delete: ");
                    String elementToDelete = scanner.next();
                    if (hashSet.remove(elementToDelete)) 
					{
                        System.out.println("Element deleted successfully.");
                    } 
					else 
					{
                        System.out.println("Element not found in the HashSet.");
                    }
                    break;
                    case 3:
                    System.out.println("Elements in the HashSet:");
                    hashSet.forEach(System.out::println);
                    break;
                    case 4:
                    System.out.println("Exiting the program.");
                    scanner.close();
                    System.exit(0);
                    default:
                    System.out.println("Invalid choice. Please try again.");
            }

            System.out.println(); 
        }
    }
}
-----------------------------------------------------------
LinkedHashSet<E> [It maintains order]
---------------------------------------
public class LinkedHashSet extends HashSet implements Set, Clonable, Serializable

It is a predefined class in java.util package under Set interface and introduced from java 1.4v. 

It is the sub class of HashSet class.

It is an orderd version of HashSet that maintains a doubly linked list across all the elements. 

It internally uses Hashtable and LinkedList data structures.

We should use LinkedHashSet class when we want to maintain an order.

When we iterate the elements through HashSet the order will be unpredictable, while when we iterate the elements through LinkedHashSet then the order will be same as they were inserted in the collection.

It accepts hetrogeneous and null value is allowed.

It has same constructor as HashSet class.
-----------------------------------------------------------
import java.util.*;
public class LinkedHashSetDemo
{
 public static void main(String args[])
	{ 
		  LinkedHashSet<String> lhs=new LinkedHashSet<>();
		  lhs.add("Ravi"); 
		  lhs.add("Vijay");
		  lhs.add("Ravi");
		  lhs.add("Ajay");
		  lhs.add("Pawan");
		  lhs.add("Shiva");
		  lhs.add(null);
		  lhs.add("Ganesh");          
		  lhs.forEach(str -> System.out.println(str));	   
	}
}
-----------------------------------------------------------
import java.util.*;

public class LinkedHashSetDemo1 
{
    public static void main(String[] args) 
	{
       LinkedHashSet<Integer> linkedHashSet = new LinkedHashSet<>();

        linkedHashSet.add(10);
        linkedHashSet.add(5);
        linkedHashSet.add(15);
        linkedHashSet.add(20);
        linkedHashSet.add(5);
		

        System.out.println("LinkedHashSet elements: " + linkedHashSet);

        System.out.println("LinkedHashSet size: " + linkedHashSet.size());

        int elementToCheck = 15;
        if (linkedHashSet.contains(elementToCheck)) 
		{
            System.out.println(elementToCheck + " is present in the LinkedHashSet.");
        } 
		else 
		{
            System.out.println(elementToCheck + " is not present in the LinkedHashSet.");
        }

        int elementToRemove = 10;
        linkedHashSet.remove(elementToRemove);
        System.out.println("After removing " + elementToRemove + ", LinkedHashSet elements: " + linkedHashSet);

              linkedHashSet.clear(); 
        System.out.println("After clearing, LinkedHashSet elements: " + linkedHashSet); //[]
    }
}
-----------------------------------------------------------
17-12-2024
-----------
SortedSet interface :
---------------------
 As we know Collections.sort(List list) method accept list as a parameter so, we can't perform sorting operation by using sort() method on HashSet and LinkedHashSet.

 In order to provide automatic sorting facility, Set interface has provided one more interface i.e SortedSet interface available from JDK 1.2.

 SortedSet interface provided default natural sorting order, default natural sorting order means, if it is number then ascending order but if it is String then alphabetical  OR dictionary order.

 In order to sort the element either in default natural sorting order or user-defined sorting order we are using Comparable or Comparator interfaces.

****Difference between Comparable and Comparator :
---------------------------------------------------
Difference is available in paint diagram (17-DEC) :
-------------------------------------------------
Program on Comparable interface :
---------------------------------
2 files :
---------
Employee.java(R)
-----------------
package com.ravi.comparable;

public record Employee(Integer empId, String empName, Double empSalary) implements Comparable<Employee>
{

	
	 /*Sorting Employee Object based on Employee ID
		@Override
		public int compareTo(Employee e2)
		{
			return this.empId().compareTo(e2.empId());
		}
	 */
	 
	  //Sorting based on the Employee Name 
	   @Override
	   public int compareTo(Employee e2) 
	   {
		return this.empName().compareTo(e2.empName());
	    }
}

EmployeeComparable.java
-----------------------
package com.ravi.comparable;

import java.util.ArrayList;
import java.util.Collections;

public class EmployeeComparable 
{
	public static void main(String[] args) 
	{
		ArrayList<Employee> listOfEmployee = new ArrayList<>();
		listOfEmployee.add(new Employee(444, "Aryan", 12890D));
		listOfEmployee.add(new Employee(111, "Zaheer", 17890D));
		listOfEmployee.add(new Employee(222, "Scott", 22906d));
		listOfEmployee.add(new Employee(333, "Smith", 18900D));
		
		System.out.println("Original Data");
		listOfEmployee.forEach(System.out::println);
		
		Collections.sort(listOfEmployee);
		
		System.out.println("Sorting the Employee Object based on the Name");
		listOfEmployee.forEach(System.out::println);

	}
}
-----------------------------------------------------------
Limitation of Comparable interface :
------------------------------------
1) We can write only one sorting logic using comparable (We can sort based on ID or based on name but not both)

2) If the BLC class is given by some 3rd party in .class format then we can't modify the source code hence Comparable will not work here.

To avoid the above said problems we introduced Comparator interface :

------------------------------------------------------------
//Program on Comparator interface :
-----------------------------------
2 files :
----------
Product.java(R)
----------------
package com.ravi.comparator;

public record Product(Integer productId, String productName, Double productPrice) 
{

}

ProductComparator.java
------------------------

package com.ravi.comparator;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class ProductComparator {

	public static void main(String[] args) 
	{
		ArrayList<Product> listOfProducts = new ArrayList<>();
		listOfProducts.add(new Product(222, "Camera", 52000D));
		listOfProducts.add(new Product(111, "Laptop", 82000D));
		listOfProducts.add(new Product(444, "Mobile", 65000D));
		listOfProducts.add(new Product(333, "Headphone", 2000D));
		
		System.out.println("Original Data");
		listOfProducts.forEach(System.out::println);
		
        //Sorting the product based on productId	
		
		Comparator<Product> sortId = new Comparator<Product>() 
		{
			@Override
			public int compare(Product p1, Product p2) 
			{
				return p1.productId().compareTo(p2.productId());
			}
		};
		
		Collections.sort(listOfProducts, sortId);		
		System.out.println("Sorting based on Product Id");
		listOfProducts.forEach(System.out::println);
		
		
		//Sort the Product data based on the Product Name
		
		/*Comparator<Product> sortName = (p1,p2)-> p1.productName().compareTo(p2.productName());
		Collections.sort(listOfProducts, sortName);		
		System.out.println("Sorting based on Product Name :");
		listOfProducts.forEach(System.out::println); */
		
				Collections.sort(listOfProducts, (p1,p2)-> p1.productName().compareTo(p2.productName()));		
		System.out.println("Sorting based on Product Name :");
		listOfProducts.forEach(System.out::println);
		

	}

}
============================================================
Comparable is a Functional interface but due to current object support(this keyword) we need to write the sorting logic in the BLC class only so BLC class must implements Comparable interface. 
[We can say Comparable as a Functional interafce because it contains exactly one abastract method but we can't use Lambda Expression by using Comparable]

We can't write the logic of compareTo(T x) method in another class because It accept only one parameter for second parameter we need to depend upon the Current Object.
------------------------------------------------------------
//How to sort Integer object in descending Order.

package com.ravi.comparator;

import java.util.ArrayList;
import java.util.Collections;

public class IntegerDesc {

	public static void main(String[] args) 
	{
		ArrayList<Integer> al = new ArrayList<>();
		al.add(34);
		al.add(12);
		al.add(23);
		al.add(9);
		al.add(4);
		
		Collections.sort(al,(i1,i2)-> i2.compareTo(i1));
		
		System.out.println(al);

	}

}
-----------------------------------------------------------
List intreface sort() method :
-------------------------------
List interface has provided sort(Comparator<t> cmp) method introduced from JDK 1.8 which accepts Comapartor as a parameter.

package com.ravi.comparator;

import java.util.ArrayList;
import java.util.Collections;

public class IntegerDesc {

	public static void main(String[] args) 
	{
		ArrayList<Integer> al = new ArrayList<>();
		al.add(34);
		al.add(12);
		al.add(23);
		al.add(9);
		al.add(4);
		
		System.out.println("Sorting in Ascending Order");
		al.sort(Integer::compareTo); //Method Reference		
		System.out.println(al);
		
		System.out.println("Sorting in Descending Order");
		al.sort((i1,i2)-> i2.compareTo(i1)); //Lambda
		System.out.println(al);
				

	}

}
------------------------------------------------------------
18-12-2024
-----------
TreeSet<E>
-----------
public class TreeSet<E> extends AbstractSet<E> implements NavigableSet<E>, Clonable, Serializable

It is a predefined class available in java.util package under Set interface available from JDK 1.2v.

TreeSet, TreeMap  and PriorityQueue are the three sorted collection in the entire Collection Framework so these classes never accepting non comparable objects.

It will sort the elements in natural sorting order i.e ascending order in case of number , and alphabetical order or Dictionary order in the case of String. In order to sort the elements according to user choice, It uses Comparable/Comparator  interface.

It does not accept duplicate and null value (java.lang.NullPointerException) 

It does not accept non comparable type of data if we try to insert it will throw a runtime exception i.e java.lang.ClassCastException

TreeSet implements NavigableSet.

NavigableSet extends SortedSet.

It contains 4 types of constructors :
----------------------------------------
1) TreeSet t1 = new TreeSet();
     create an empty TreeSet object, elements will be inserted in using Comparable.

2) TreeSet t2 = new TreeSet(Comparator c);
    Customized sorting order.

3)  TreeSet t3 = new TreeSet(Collection c);
    loose coupling.

4) TreeSet t4 = new TreeSet(SortedSet s);
   We can merge two TreeSet object to copy the data.   
--------------------------------------------------------------------   //program that describes by default TreeSet provides default natural sorting order
import java.util.*;
public class TreeSetDemo 
{
	public static void main(String[] args) 
	{
		SortedSet<Integer> t1 = new TreeSet<>();
		t1.add(4); 
		t1.add(7);  
		t1.add(2);
		t1.add(1);
		t1.add(9);	
		System.out.println(t1);

		NavigableSet<String> t2 = new TreeSet<>();
		t2.add("Orange");  
		t2.add("Mango");
		t2.add("Banana");
		t2.add("Grapes");
		t2.add("Apple");		
		System.out.println(t2);		
	}
}
-------------------------------------------------------------------
 package com.ravi.treeset_demo;

import java.util.TreeSet;

record Customer(Integer customerId)
{
	
}

public class TreeSetDemo1 
{
	public static void main(String[] args) 
	{
      TreeSet<Customer> ts1 = new TreeSet<Customer>();
      ts1.add(new Customer(999));
      ts1.add(new Customer(111));
      ts1.add(new Customer(555));
      ts1.add(new Customer(444));
      ts1.add(new Customer(222));
      
     ts1.forEach(System.out::println);

	}

}

In the above program Customer record does not implement from Comparable interface so at the time of calling add() method 
compareTo() method is not available so we are getting java.lang.ClassCastException.
--------------------------------------------------------------------
package com.ravi.treeset_demo;

import java.util.TreeSet;

record Customer(Integer customerId) implements Comparable<Customer>
{
	@Override
	public int compareTo(Customer c2) 
	{
		return  this.customerId().compareTo(c2.customerId());
	}
	
}

public class TreeSetDemo1 
{
	public static void main(String[] args) 
	{
      TreeSet<Customer> ts1 = new TreeSet<Customer>();
      ts1.add(new Customer(999));
      ts1.add(new Customer(111));
      ts1.add(new Customer(555));
      ts1.add(new Customer(444));
      ts1.add(new Customer(222));
      
     ts1.forEach(System.out::println);

	}

}

Now, compareTo() method is available from Comparable interface so we will get sorted data.
--------------------------------------------------------------------
import java.util.*;
public class TreeSetDemo1
{
	public static void main(String[] args) 
	{
		TreeSet<String> t1 = new TreeSet<>();
		t1.add("Orange"); 
		t1.add("Mango");
		t1.add("Pear");
		t1.add("Banana");
		t1.add("Apple");	
		System.out.println("In Ascending order");
		t1.forEach(i -> System.out.println(i));

		TreeSet<String> t2 = new TreeSet<>();
		t2.add("Orange");
		t2.add("Mango");
		t2.add("Pear");
		t2.add("Banana");
		t2.add("Apple");

        System.out.println("In Descending order");
		Iterator<String> itr2 = t2.descendingIterator();  //for descending order

         itr2.forEachRemaining(x -> System.out.println(x));		
	}
}

Note :- descendingIterator() is a predefined method of TreeSet class which will traverse in the descending order and return type of this method is Iterator interface.

public Iterator descendingIterator()
--------------------------------------------------------------------
package com.ravi.treeset_demo;

import java.util.Iterator;
import java.util.Set;
import java.util.TreeSet;

public class TreeSetDemo1 
{
	public static void main(String[] args) 
	{
		Set<String> t = new TreeSet<>((s1,s2)->s2.compareTo(s1));  
		t.add("6");   
		t.add("5");
		t.add("4");
		t.add("2");
		t.add("9");	
		Iterator<String> iterator = t.iterator();
		iterator.forEachRemaining(x -> System.out.println(x));
	}

}
-------------------------------------------------------------------
package com.ravi.treeset_demo;

import java.util.Iterator;
import java.util.Set;
import java.util.TreeSet;

public class TreeSetDemo1 
{
	public static void main(String[] args) 
	{
		Set<Character> t = new TreeSet<>((c1,c2)-> c2.compareTo(c1));  
		t.add('A'); 
		t.add('C');
		t.add('B');
		t.add('E');
		t.add('D');	
		Iterator<Character> iterator = t.iterator();
		iterator.forEachRemaining(x -> System.out.println(x)); 
	}

}
--------------------------------------------------------------------
//Provide custom Sorting where we can sort the data using Different criteria :

package com.ravi.treeset_demo;

import java.util.Set;
import java.util.TreeSet;

record Product(Integer productId, String productName)
{
	
}

public class CustomSorting 
{
   public static void main(String[] args) 
   {
	
	   Set<Product> products = new TreeSet<Product>((p1,p2)-> p1.productId().compareTo(p2.productId()));
	   products.add(new Product(111, "Mobile"));
	   products.add(new Product(444, "Camera"));
	   products.add(new Product(222, "Laptop"));
	   products.add(new Product(333, "Keyboard"));
	   
	   System.out.println("Sorting data in Ascending order based on Product Id ");
	   products.forEach(System.out::println);
	   
	   
	   Set<Product> products1 = new TreeSet<Product>((p1,p2)-> p2.productId().compareTo(p1.productId()));
	   products1.add(new Product(111, "Mobile"));
	   products1.add(new Product(444, "Camera"));
	   products1.add(new Product(222, "Laptop"));
	   products1.add(new Product(333, "Keyboard"));
	   
	   System.out.println("Sorting data in Descending order based on Product Id ");
	   products1.forEach(System.out::println);
	   
	   
	   Set<Product> products2 = new TreeSet<Product>((p1,p2)-> p1.productName().compareTo(p2.productName()));
	   products2.add(new Product(111, "Mobile"));
	   products2.add(new Product(444, "Camera"));
	   products2.add(new Product(222, "Laptop"));
	   products2.add(new Product(333, "Keyboard"));
	   
	   System.out.println("Sorting data in Ascending order based on Product Name ");
	   products2.forEach(System.out::println);
	   
	   
	   Set<Product> products3 = new TreeSet<Product>((p1,p2)-> p2.productName().compareTo(p1.productName()));
	   products3.add(new Product(111, "Mobile"));
	   products3.add(new Product(444, "Camera"));
	   products3.add(new Product(222, "Laptop"));
	   products3.add(new Product(333, "Keyboard"));
	   
	   System.out.println("Sorting data in Descending order based on Product Name ");
	   products3.forEach(System.out::println);
	   
	   
	   
	   
	   
   }
}
====================================================================
Methods of SortedSet interface :
--------------------------------------
public E first() :- Will fetch first element

public E last() :- Will fetch last element

public SortedSet headSet(int range) :- Will fetch the values which are less than specified range.

public SortedSet tailSet(int range) :- Will fetch the values which are equal and greater than the specified range.

public SortedSet subSet(int startRange, int endRange) :- Will fetch the range of values where startRange is inclusive and endRange is exclusive.

Note :- headSet(), tailSet() and subSet(), return type is SortedSet.

--------------------------------------------------------------------
import java.util.*;
public class SortedSetMethodDemo
{
       public static void main(String[] args) 
       {
            TreeSet<Integer> times = new TreeSet<>();
            times.add(1205);
            times.add(1505);
            times.add(1545);
			times.add(1600);
            times.add(1830);
            times.add(2010);
            times.add(2100);
            
            SortedSet<Integer> sub = new TreeSet<>();
            
			sub = times.subSet(1545,2100); 
            System.out.println("Using subSet() :-"+sub);//[1545, 1600,1830,2010]
            System.out.println(sub.first());
            System.out.println(sub.last());   
			
		    sub = times.headSet(1545); 
			System.out.println("Using headSet() :-"+sub); //[1205, 1505]
            
		     sub =  times.tailSet(1545); 
			 System.out.println("Using tailSet() :-"+sub); //[1545 to 2100] 
       }
}
--------------------------------------------------------------------
NavigableSet :
--------------
It is a predefined interface available in java.util package from JDK 1.6v

It is used to navigate among the elements, Unlike SortedSet which provides range of value. Here we can navigate among the values as shown below.

import java.util.*;

public class NavigableSetDemo 
{   
    public static void main(String[] args)
    {
        NavigableSet<Integer> ns = new TreeSet<>(); 
        ns.add(1);
        ns.add(2);
        ns.add(3);
        ns.add(4);
        ns.add(5);
        ns.add(6);

		System.out.println("lower(3): " + ns.lower(3));//Just below than the specified element or null
        
       System.out.println("floor(3): " + ns.floor(3)); //Equal  less or null
     
       System.out.println("higher(3): " + ns.higher(3));//Just greater than specified element or null
  
       System.out.println("ceiling(3): " + ns.ceiling(3));//Equal or greater or null 
	   
        	
    }
}
--------------------------------------------------------------------
19-12-2024
-----------
Map interface :
---------------
As we know Collection interface is used to hold single Or individual object but Map interface will hold group of objects in the form key and value pair. {key = value} 

Map interface is not the part the Collection.

Before Map interface We have Dictionary(abstract class) class and it is extended by Hashtable class in JDK 1.0V

Map interface works with key and value pair introduced from 1.2V.

Here key and value both are objects.

Here key must be unique and value may be duplicate.

Each key and value pair is creating one Entry.(Entry is nothing but the combination of key and value pair)

interface Map<K,V>
{   
     interface Entry<K,V>
      {
         //key and value
      }
}

How to represent this entry interface (Map.Entry in .java) [Map$Entry in .class]

In Map interface whenever we have a duplicate key then the old key value will be replaced by new key(duplicate key) value.

Map interface has defined forEach(BiConsumer cons) method to work with group of Objects.

Iterator and ListIterator we can't work directly using Map.

--------------------------------------------------------------------
Map interface Hierarchy :
--------------------------
Hierarchy is available in paint daigram [19-DEC-24]
----------------------------------------------------------
Methods of Map interface :
--------------------------
1) Object put(Object key, Object value) :- To insert one entry in the Map collection. It will return the old object key value if the key is already available(Duplicate key), If key is not available then it will return null.


2) putIfAbsent(Object key, Object value) :- It will insert an entry if and only if, key is not available , if the key is already available then it will not insert the Entry to the Map Collection


3) Object get(Object key) :- It will return  corresponding value of key, if the key is not present then it will return null.

4) Object getOrDefault(Object key, Object defaultValue) :- To avoid null value this method has been introduced from JDK 1.8V, here we can pass some defaultValue to avoid the null value.


5) boolean containsKey(Object key) :- To Search a particular key

6) boolean containsValue(Object value) :- To Search a particular value

7) int size() :- To count the number of Entries.

8) remove(Object key) :- One complete entry will be removed.

9) void clear() :- Used to clear the Map

10) boolean isEmpty() :- To verify Map is empty or not?

11) void putAll(Map m) :- Merging of two Map collection

----------------------------------------------------------
Methods of map interface to convert the map into Collection :
----------------------------------------------------------
We have map interafce methods through which we can convert map interface into collection interface which is known as collection views
method.

1) public Set<Object> keySet() : It will retrieve all the keys.

2) public Collection values() : It will retrieve all the values.

3) public Set<Map.Entry> entrySet() : It will retrieve key and value both in a single object.
              a) getKey()
	      b) getValue()
------------------------------------------------------------------
20-12-2024
-----------
**** How HashMap works internally ?
------------------------------------
a) While working with HashSet or HashMap every object must be compared because duplicate objects are not allowed.

b) Whenever we add any new key to verify whether key is unique or duplicate, HashMap internally uses hashCode(), == operator and equals method.

c) While adding the key object in the HashMap, first of all it will invoke the hashCode() method to retrieve the corresponding key hashcode value.
    Example :- hm.put(key,value);
               then internally key.hashCode();

d) If the newly added key and existing key hashCode value both are same (Hash collision), then only == operator is used for comparing those keys by using reference or memory address, if both keys references are same then existing key value will be replaced with new key value.

        If the reference of both keys are different then equals(Object obj) method is invoked to compare those keys by using state(data). [content comparison]

	If the equals(Object obj) method returns true (content wise both keys are same), this new key is duplicate then existing key value will be replaced by new key value.

	If equals(Object obj) method returns false, this new key is unique, new entry (key-value) will be inserted in the same Bucket by using Singly LinkedList

	Note :- equals(Object obj) method is invoked only when two keys are having same hashcode as well as their references are different.

e) Actually by calling hashcode method we are not comparing the objects, we are just storing the objects in a group so the currently adding key object will be compared with its SAME HASHCODE GROUP objects, but not with all the keys which are available in the Map.

f) The main purpose of storing objects into the corresponding group to decrease the number of comparison so the efficiency of the program will increase.

g) To insert an entry in the HashMap, HashMap internally uses Hashtable data structure.

h) Now, for storing same hashcode object into a single group, hash table data structure internally uses one more data structure called Bucket.

i) The Hashtable data structure internally uses Node class array object.

j) The bucket data structure internally uses LinkedList data structure, It is a single linked list again implemented by Node class only.

*k) A bucket is group of entries of same hash code keys.

l) Performance wise LinkedList is not good to serach, so from java 8 onwards LinkedList is changed to Binary tree to decrease the number of comparison within the same bucket hashcode if the number of entries are greater than 8.
------------------------------------------------------------------

** equals() and hashCode() method contract :
-----------------------------------------
Both the methods are working together to find out the duplicate objects in the Map.

*If equals() method invoked on two objects and it returns true then hashcode of both the objects must be same.

Note : IF TWO OBJECTS ARE HAVING SAME HASH CODE THEN IT MAY BE SAME OR DIFFERENT BUT IF EQUALS(OBJECT OBJ) METHOD RETURN TRUE THEN BOTH OBJECTS MUST RETURN SAME HASHCODE.
----------------------------------------------------------------
package com.ravi.map;

import java.util.HashMap;

public class HashMapInternal {

	public static void main(String[] args) 
	{
		
			HashMap<String,Integer> hm1 = new HashMap<>();
			hm1.put("A", 1);
			hm1.put("A", 2);
			hm1.put(new String("A"), 3);
			System.out.println("Size is :"+hm1.size());
			System.out.println(hm1);
			
			System.out.println("....................");
			
			HashMap<Integer,Integer> hm2 = new HashMap<>();
			hm2.put(128, 1);
			hm2.put(128, 2);
			System.out.println("Size is :"+hm2.size());
			System.out.println(hm2);
			System.out.println("....................");
			
			
			
			HashMap<Object,Object> hm3 = new HashMap<>();
			hm3.put("A", 1);
			hm3.put("A", 2);
			hm3.put(new String("A"), 3);
			hm3.put(65, 4);
			System.out.println("Size is :"+hm3.size());
			System.out.println(hm3);
			
		
	}

}
-----------------------------------------------------------------
What will happen if we don't follow the contract ?
Case 1 :
--------
If we override only equals(Object obj)
---------------------------------------
If we override only equals(Object obj) method for content comparison
then same object (duplicate object) will have different hashcode (due to new keyword) hence same object (content wise) will move into two different buckets [Duplication].

Case 2 :
--------
If we override only hashCode() method 
--------------------------------------
If we overrdie only hashCode() method then two objects which are having same hashcode (due to overriding) will go to same bucket but == operator and equals(Object obj) method of Object class, both will return false hence duplicate object will be inserted into same bucket.

So, the conclusion is, compulsory we need to override both the methods for removing duplicate elements.

package com.ravi.map;

import java.util.HashMap;
import java.util.Objects;

class Customer
{
	private int customerId;
	private String customerName;
	
	public Customer(int customerId, String customerName) 
	{
		super();
		this.customerId = customerId;
		this.customerName = customerName;
	}

	@Override
	public int hashCode() {
		return Objects.hash(customerId, customerName);
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Customer other = (Customer) obj;
		return customerId == other.customerId && Objects.equals(customerName, other.customerName);
	}

	
}
public class HashMapInternalDemo1 
{

	public static void main(String[] args) 
	{
	   Customer c1 = new Customer(111, "Scott");	
	   Customer c2 = new Customer(111, "Scott");	
	   	   
	   System.out.println(c1.hashCode()+" : "+c2.hashCode());
	    
	   HashMap<Customer,String> map = new HashMap<>();
	   map.put(c1, "A");  //c1   B
	   map.put(c2, "B");
	   
	   System.out.println(map.size());
	}

}


Customer class we are using as a HashMap key so it must override 
hashCode() and equals(Object obj) as well as at advanced level, It must be immutable class.

All the Wrapper classes and String class are immutable as well as 
hashCode() and equals(Object obj) methods are overridden in these classes so perfectly suitable to becoming HashMap key.
------------------------------------------------------------------------
package com.ravi.map;

import java.util.HashMap;

record Customer(Integer id, String name)
{
	
}

public class HashMapInternalDemo 
{

	public static void main(String[] args) 
	{
	   Customer c1 = new Customer(111, "Scott");	
	   Customer c2 = new Customer(111, "Scott");	
	   	   
	   //System.out.println(c1.hashCode()+" : "+c2.hashCode());
	    
	   HashMap<Customer,String> map = new HashMap<>();
	   map.put(c1, "A");
	   map.put(c2, "B");
	   
	   System.out.println(map.size());
	}

}

so final conclusion is, In our user-defined class which we want to use as a HashMap key must be immutable and hashCode() and equals(Object obj) method must be overridden. Instead of BLC class we can also use simply record because record is implicitly final and hashCode() and equals(Object obj) methods are overridden.
==================================================================
21-12-2024
----------
How to generate Custom HashCode for String value.
-------------------------------------------------
public class CustomStringHashCode 
{
    public static int customHashCode(String str)
    {
        if (str == null) 
        {
            return 0; // defualt hashCode value for null is 0
        }

        int hashCode = 0;

        for (int i = 0; i < str.length(); i++)  //NIT
        {
            char charValue = str.charAt(i);
            hashCode = 31 * hashCode + charValue;
        }

        return hashCode;
    }

    public static void main(String[] args) 
    {
    	Scanner sc = new Scanner(System.in);
    	System.out.print("Enter your String :");
    	String str = sc.next();
    	
    	System.out.println(str+" hashcode from String class :"+str.hashCode());
        
    	System.out.println("..................");
    	
    	System.out.println(str+" hashcode for my class :"+CustomStringHashCode.customHashCode(str));
    	sc.close();
    }
}

Note : Both methods are producing same hashcode value. 
       Hashcode may also be -ve value so use shift operator to 
       make it positive.
----------------------------------------------------------------
HashMap<K,V> :-  [Unsorted, Unordered, No Duplicate keys]
------------
public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Serializable, Clonable 

It is a predefined class available in java.util package under Map interface available from JDK 1.2v.

It gives us unsorted and Unordered map. when we need a map and we don't care about the order while iterating the elements through it then we should use HashMap.

It inserts the element based on the hashCode of the Object key using hashing technique [hasing alogorithhm]

It does not accept duplicate keys but value may be duplicate.

It accepts only one null key(because duplicate keys are not allowed) but multiple null values are allowed.

HashMap is not synchronized.  

Time complexcity of search, insert and delete will be O(1)

We should use HashMap to perform fast searching opeartion.

For eliminating duplicate keys in hashMap object we should compulsory follow the contract between hashcode and equals(Object obj)

It contains 4 types of constructor 

1) HashMap hm1 = new HashMap();
    It will create the HashMap Object with default capacity is 16. The default load fator or Fill Ratio is 0.75   (75% of HashMap is filled up then new HashMap Object will be created having double capacity)

2) HashMap hm2 = new HashMap(int initialCapacity);
    will create the HashMap object with user specified capacity


3) HashMap hm3 = new HashMap(int initialCapacity, float loadFactor);
    we can specify our own initialCapacity and loadFactor(by default load factor is 0.75)

4)HashMap hm4 = new HashMap(Map m);
    Interconversion of Map Collection
---------------------------------------------------------
//Program on HashMap

package com.ravi.map;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map.Entry;

public class HashMapDemo1 
{
	public static void main(String[] args) 
	{      
        HashMap<Integer, String> map = new HashMap<>();

        map.put(1, "Vanilla");
        map.put(2, "Butterscotch");
        map.put(3, "Chocolate");
        map.put(4, "Cotton Candy");

        System.out.println("HashMap: " + map);

        String value = map.get(2);
        System.out.println("Value for key 2: " + value);
        
        value = map.getOrDefault(8, "Key is not available");
        System.out.println("Value for key 3: " + value);
        
        boolean hasKey = map.containsKey(3);
        System.out.println("HashMap contains key 3: " + hasKey);

        boolean hasValue = map.containsValue("Vanilla");
        System.out.println("HashMap contains value 'Vanilla': " + hasValue);

        
        
        map.remove(1);
        System.out.println("HashMap after removing key 1: " + map);

        
        System.out.println("Iterating through HashMap:");
        for (HashMap.Entry<Integer, String> entry : map.entrySet()) 
        {
            System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
        }

        System.out.println("Iterating through Iterator");
        
      Iterator<Entry<Integer, String>> itr = map.entrySet().iterator();
      itr.forEachRemaining(System.out::println);
        
        
        
       
        int size = map.size();
        System.out.println("Size of HashMap: " + size);

       
        map.clear();
        System.out.println("HashMap after clearing: " + map); 
    }
}
----------------------------------------------------------
package com.ravi.map;

import java.util.HashMap;

public class HashMapDemo2
{
    public static void main(String[] args) 
    {
       HashMap<Integer, String> studentRecords = new HashMap<>();

        studentRecords.put(101, "Scott");
        studentRecords.put(102, "Smith");
        studentRecords.put(103, "Martin");
        studentRecords.put(104, "Aryan");

        System.out.println("Student Records: " + studentRecords);

        int searchId = 102;
        String studentName = studentRecords.get(searchId);
        if (studentName != null)
        {
            System.out.println("Student with ID " + searchId + " is " + studentName);
        } 
        else
        {
            System.out.println("Student with ID " + searchId + " not found.");
        }

        
        System.out.println(studentRecords.put(103, "Rahul"));
        System.out.println("Updated Records: " + studentRecords);

        
        studentRecords.remove(104);
        System.out.println("Records after removal: " + studentRecords);

        
        int idToCheck = 101;
        System.out.println("Does ID " + idToCheck + " exist? " + studentRecords.containsKey(idToCheck));

        
        String nameToCheck = "Aryan";
        System.out.println("Does name '" + nameToCheck + "' exist? " + studentRecords.containsValue(nameToCheck));

        
        System.out.println("Iterating through records:");
        for (HashMap.Entry<Integer, String> entry : studentRecords.entrySet()) 
        {
            System.out.println("ID: " + entry.getKey() + ", Name: " + entry.getValue());
        }

        studentRecords.clear();
        System.out.println("All records cleared: " + studentRecords);
    
    }
}
---------------------------------------------------------
package com.ravi.map;

import java.util.Collection;
import java.util.HashMap;
import java.util.Set;

public class HashMapDemo3 
{
  public static void main(String[] args) 
  {
	    HashMap<Integer,String> newmap1 = new HashMap<>();

		HashMap<Integer,String> newmap2 = new HashMap<>();	  

		newmap1.put(1, "OCPJP");
		newmap1.put(2, "is");
		newmap1.put(3, "best");
			  
		System.out.println("Values in newmap1: "+ newmap1);

		newmap2.put(4, "Exam");

		newmap2.putAll(newmap1);

		newmap2.forEach((k,v)->System.out.println(k+" : "+v));
		
		Set<Integer> setOfKeys = newmap2.keySet();
		System.out.println(setOfKeys);
		
		Collection<String> values = newmap2.values();
		System.out.println(values);		
		
		System.out.println("..............................");
		
		HashMap<Integer, String> hm1 = new HashMap<>();

		hm1.put(1, "Ravi");
		hm1.put(2, "Rahul");
		hm1.put(3, "Rajen");

		HashMap<Integer, String> hm2	= new HashMap<>(hm1);

		System.out.println("Mapping of HashMap hm1 are : "	+ hm1);
	
		System.out.println("Mapping of HashMap hm2 are : " + hm2);
		
		
  }
}
--------------------------------------------------------
package com.ravi.map;

import java.util.HashMap;

record Employee(Integer empId, String empName)
{
	
}

public class HashMapDemo4 
{
	public static void main(String[] args) 
	{
		Employee e1 = new Employee(101,"Aryan");
		Employee e2 = new Employee(102,"Pooja");
		Employee e3 = new Employee(101,"Aryan");
		Employee e4 = e2;  
		
		HashMap<Employee,String> hm = new HashMap<>();
		hm.put(e1,"Ameerpet");
		hm.put(e2,"S.R Nagar");
		hm.put(e3,"Begumpet");
		hm.put(e4,"Panjagutta");

		hm.forEach((k,v)-> System.out.println(k+" : "+v));
	}
}
---------------------------------------------------------
package com.ravi.map;

import java.util.HashMap;

public class HashMapDemo5
{
    public static void main(String[] args) 
    {
        // Create a HashMap to store book titles and their availability (true = available, false = borrowed)
        HashMap<String, Boolean> library = new HashMap<>();

        library.put("Core Java", true);
        library.put("Advanced Java", true);
        library.put("HTML", false);
        library.put("JavaScript", true);

        // Display the initial library status
        System.out.println("Initial Library Status: " + library);

        // Borrow a book
        String bookToBorrow = "Advanced Java";
        if (library.containsKey(bookToBorrow) && library.get(bookToBorrow)) 
        {
            library.put(bookToBorrow, false); 
            System.out.println(bookToBorrow + " has been borrowed.");
        } 
        else
        {
            System.out.println(bookToBorrow + " is not available for borrowing.");
        }

        
        String bookToReturn = "HTML";
        
        if (library.containsKey(bookToReturn) && !library.get(bookToReturn))
        {
            library.put(bookToReturn, true); // Mark the book as available
            System.out.println(bookToReturn + "Book has been returned.");
        } 
        else 
        {
            System.out.println(bookToReturn + "Book is not borrowed.");
        }
   
        // Check the availability of a book
        String bookToCheck = "JavaScript";
        if (library.containsKey(bookToCheck))
        {
          String availability = library.get(bookToCheck) ? "available" : "borrowed";
            System.out.println(bookToCheck + " Book is " + availability + ".");
        } 
        else
        {
            System.out.println(bookToCheck + " is not in the library.");
        }

        //Display the final library status
        
        System.out.println("Final Library Status:");
        for (HashMap.Entry<String, Boolean> entry : library.entrySet()) 
        {
            String status = entry.getValue() ? "Available" : "Borrowed";
            System.out.println("Book: " + entry.getKey() + ", Status: " + status);
        }
        
      
    }
}
--------------------------------------------------------
23-12-2024
-----------
LinkedHashMap<K,V>
-------------------
public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V>

It is a predefined class available in java.util package under Map interface available from 1.4.

It is the sub class of HashMap class.

It maintains insertion order. It contains a doubly linked with the elements or nodes so It will iterate more slowly in comparison to HashMap.

It uses Hashtable and LinkedList data structure.

If We want to fetch the elements in the same order as they were inserted then we should go with LinkedHashMap.

It accepts one null key and multiple null values.

It is not synchronized.

It has also 4 constructors same as HashMap

1) LinkedHashMap hm1 = new LinkedHashMap();
    will create a  LinkedHashMap with default capacity 16 and load factor 0.75

2) LinkedHashMap hm1 = new LinkedHashMap(iny initialCapacity);

3) LinkedHashMap hm1 = new LinkedHashMap(int initialCapacity, float loadFactor);


4) LinkedHashMap hm1 = new LinkedHashMap(Map m);

-----------------------------------------------------------------
import java.util.*;
public class LinkedHashMapDemo 
{
	public static void main(String[] args) 
	{
		LinkedHashMap<Integer,String> l = new LinkedHashMap<>();
		l.put(1,"abc");
		l.put(3,"xyz");
		l.put(2,"pqr");
		l.put(4,"def");
		l.put(null,"ghi");
		System.out.println(l);
	}
}
-----------------------------------------------------------------
import java.util.*;

public class LinkedHashMapDemo1 
{
      public static void main(String[] a) 
      {
           Map<String,String> map = new LinkedHashMap<>();
           map.put("Ravi", "1234");
		   map.put("Rahul", "1234");
		   map.put("Aswin", null);
		   map.put("Samir", null);
           
		   map.forEach((k,v)->System.out.println(k+" : "+v));
      }
}
-----------------------------------------------------------------
Hashtable<K,V>
---------------
public class Hashtable<K,V> extends Dictionary<K,V> implements Map<K,V>, Clonable, Serializable

It is predefined class available in java.util package under Map interface from JDK 1.0.

Like Vector, Hashtable is also form the birth of java so called legacy class.

It is the sub class of Dictionary class which is an abstract class.

*The major difference between HashMap and Hashtable is, HashMap methods are not synchronized where as Hastable methods are synchronized. 

HashMap can accept one null key and multiple null values where as Hashtable does not contain anything as a null(key and value both). if we try to add null then JVM will throw an exception i.e NullPointerException.

The initial default capacity of Hashtable class is 11 where as loadFactor is 0.75.


It has also same constructor as we have in HashMap.(4 constructors)

1) Hashtable hs1 = new Hashtable();
    It will create the Hashtable Object with default capacity as 11 as well as load factor is 0.75

2) Hashtable hs2 = new Hashtable(int initialCapacity);
    will create the Hashtable  object with specified capacity


3) Hashtable hs3 = new Hashtable(int initialCapacity, float loadFactor);
    we can specify our own initialCapacity and loadFactor

4) Hashtable hs = new Hashtable(Map c);
    Interconversion of Map Collection
    
-----------------------------------------------------------------
import java.util.*;  
public class HashtableDemo
	{  
	 public static void main(String args[])
		{  
		  Hashtable<Integer,String> map=new Hashtable<>(); 
		  map.put(1, "Java");
		  map.put(2, "is");
		  map.put(3, "best");		
		  map.put(4,"language");
		  
		  //map.put(5,null);  

		  System.out.println(map);

		  System.out.println(".......................");

		    for(Map.Entry m : map.entrySet())
			 {  
				 System.out.println(m.getKey()+" = "+m.getValue());  
			} 
        }  
}  
----------------------------------------------------------------
import java.util.*;  
public class HashtableDemo1
{  
   public static void main(String args[])
	{  
    Hashtable<Integer,String> map=new Hashtable<>();          
     map.put(1,"Priyanka");    
     map.put(2,"Ruby");   
     map.put(3,"Vibha");    
     map.put(4,"Kanchan");
	
	 map.putIfAbsent(5,"Bina");  
	 map.putIfAbsent(24,"Pooja");
	 map.putIfAbsent(26,"Ankita");     
    
     map.putIfAbsent(1,"Sneha");  
     System.out.println("Updated Map: "+map); 
 }  
}  
------------------------------------------------------------------
WeakHashMap<K,V> :
------------------
public class WeakHashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>

It is a predefined class in java.util package under Map interface.It was introduced from JDK 1.2v onwards.

While working with HashMap, keys of HashMap are of strong reference type. This means the entry of  map will not be deleted by the garbage collector even though the key is set to be null as well as Object is also not eligible for Garbage Collector.

On the other hand while working with WeakHashMap, keys of WeakHashMap are of weak reference type. This means the entry and corresponding object of a map is deleted by the garbage collector if the key value is set to be null because it is of weak type.

So, HashMap dominates over Garbage Collector where as Garbage Collector dominates over WeakHashMap.

It contains 4 types of Constructor :
---------------------------------------
1) WeakHashMap wm1 = new WeakHashMap();
   
    Creates an empty WeakHashMap object with default capacity is 16 and load fator 0.75


2) WeakHashMap wm2 = new WeakHashMap(int initialCapacity);

3) WeakHashMap wm3 = new WeakHashMap(int initialCapacity, float loadFactor);

    Eg:- WeakHashMap wm = new WeakHashMap(10,0.9);

    capacity - The capacity of this map is 10. Meaning, it can store 10 entries.

    loadFactor - The load factor of this map is 0.9. This means whenever our hashtable is filled up by 90%, the entries are moved to a new hashtable of double the size of the original hashtable.

4) WeakHashMap wm4 = new WeakHashMap(Map m);

package com.ravi.wakhashmap;

import java.util.WeakHashMap;

record Product(Integer productId, String productName)
{
	@Override
	public void finalize()
	{
		System.out.println("Product Object is eligible for GC");
	}	
}

public class WeakHashMapDemo1 
{
	public static void main(String[] args) throws InterruptedException 
	{
		Product p1 = new Product(111, "Camera");
		
		WeakHashMap<Product,String> hm = new WeakHashMap<Product,String>();
		hm.put(p1, "Hyderabad");
		
		System.out.println(hm);
		
		p1 = null;
		
		System.gc();
		
		Thread.sleep(3000);
		
		System.out.println(hm);  //{}

	}

}


Note : Here Product object and WeakHashMap entry both will be 
       deleted because keys are weak type.
       It is suitable for database inventory where we want frequently delete the Product Object.
-----------------------------------------------------------------
How to generate System hashcode :
---------------------------------
As we know Object class has provided hashCode() method but if we want to generate System hashcode (system generated hashcode) then System class has provided a predefined static method identityHashCode(Object obj).

public native static int identityHashCode(Object obj)

package com.ravi.identity_hash_map;

public class SystemIdentity {

	public static void main(String[] args) 
	{
		String str = "india";		
		System.out.println(str.hashCode());
		
		System.out.println(System.identityHashCode(str));

	}

}
----------------------------------------------------------------
IdentityHashMap<K,V> [Comparing keys based on the Memory reference]
---------------------
public class IdentityHashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Clonable, Serializable.

It was introduced from JDK 1.4 onwards.

The IdentityHashMap uses == operator to compare keys.

As we know HashMap uses equals() and hashCode() method for comparing the keys based on the hashcode of the object it will serach the bucket location and insert the entry their only.

So We should use IdentityHashMap where we need to check the reference or memory address instead of logical equality.

HashMap uses hashCode of the "Object key" to find out the bucket loaction in Hashtable, on the other hand IdentityHashMap does not use hashCode() method actually It uses System.identityHashCode(Object o)

IdentityHashMap is more faster than HashMap in case of key Comparison.

The default capacity is 32.

It has three constrcutors, It does not contain loadFactor specific constructor.

----------------------------------------------------------------
package com.ravi.identity_hash_map;

import java.util.HashMap;
import java.util.IdentityHashMap;

public class IdentityHashMapDemo {

	public static void main(String[] args) {
		
		HashMap<String,Integer> hm = new HashMap<>();

		IdentityHashMap<String,Integer> ihm = new IdentityHashMap<>();
		
		hm.put("Ravi",23);
		hm.put(new String("Ravi"), 24);
		
		ihm.put("Ravi",23);
		ihm.put(new String("Ravi"), 27); //compares based on == operator
		
		System.out.println("HashMap size :"+hm.size());  
		System.out.println(hm);
		System.out.println("........................");
		System.out.println("IdentityHashMap size :"+ihm.size()); 
		System.out.println(ihm);



	}

}

Note : Here HashMap size is 1, IdentityHashMap size is 2 because, It uses == Operator.
------------------------------------------------------------------
SortedMap<K,V>
--------------
It is a predefined interface available in java.util package under Map interface.

We should use SortedMap interface when we want to insert the key element based on some sorting order i.e the default natural sorting order.

Internally It uses Comparable and Comaprator interfaces.
-------------------------------------------------------------
TreeMap<K,V>
------------
public class TreeMap<K,V> extends AbstractMap<K,V> implements NavigableMap<K,V> , Clonable, Serializable

It is a predefined class avaialble in java.util package under Map interface available for 1.2V.

It is a sorted map that means it will sort the elements by natural sorting order based on the key or by using Comparator interface as a constructor parameter.

It does not allow non comparable keys.

It does not accept null key but null value allowed.

TreeMap implements NavigableMap and NavigableMap extends SortedMap. SortedMap extends Map interface.

TreeMap contains 4 types of Constructors :

1) TreeMap tm1 = new TreeMap(); //creates an empty TreeMap

2)  TreeMap tm2 = new TreeMap(Comparator cmp); //user defined soting logic

3)  TreeMap tm3 = new TreeMap(Map m); //loose Coupling

4)  TreeMap tm4 = new TreeMap(SortedMap m);
-------------------------------------------------------------
import java.util.*;
public class TreeMapDemo 
{
	public static void main(String[] args) 
	{
		TreeMap<Object,String> t = new TreeMap<>(); 
		t.put(4,"Ravi");
		t.put(7,"Aswin");
		t.put(2,"Ananya");
		t.put(1,"Dinesh");
		t.put(9,"Ravi");	
		t.put(3,"Ankita");
		t.put(5,null);		
							
		System.out.println(t);
	}
}
-------------------------------------------------------------
import java.util.*;                        
public class TreeMapDemo1 
{
      public static void main(String args[]) 
      {
            TreeMap map = new TreeMap();
            map.put("one","1");
            map.put("two",null);
            map.put("three","3");
			map.put("four",4);

            displayMap(map);  

	map.forEach((k, v) -> System.out.println("Key = " + k + ", Value = " + v));
	 	       
      }
      static void displayMap(TreeMap map) 
      {
           Collection c = map.entrySet();   //Set<Map.Entry>

           Iterator i = c.iterator();
           i.forEachRemaining(x -> System.out.println(x));
      }
}
------------------------------------------------------------
//firstKey()  lastKey()  headMap()  tailMap()  subMap()      SortedMap
// first()     last()     headSet()  tailSet()  subSet()     SortedSet

import java.util.*;
public class TreeMapDemo2
{
    public static void main(String[] argv) 
    {
        Map map = new TreeMap();  
        map.put("key2", "value2");
        map.put("key3", "value3");
        map.put("key1", "value1");

        System.out.println(map); //

        SortedMap x = (SortedMap) map;
        System.out.println("First key is :"+x.firstKey());
        System.out.println("Last Key is :"+x.lastKey()); 
     }
}
-------------------------------------------------------------
//Soring TreeMap keys by using Comparable inetraface :
------------------------------------------------------
package com.ravi.sorted_map;

import java.util.TreeMap;

record Product(Integer id, String productName) implements Comparable<Product>
{
	@Override
	public int compareTo(Product p2) 
	{
		return this.id.compareTo(p2.id);
	}


}

public class TreeMapDemo {

	public static void main(String[] args) 
	{
		TreeMap<Product,String> tm1 = new TreeMap<>();
		tm1.put(new Product(333, "Camera"), "Hyd");  //compareTo()
		tm1.put(new Product(111, "Laptop"), "Pune");
		tm1.put(new Product(222, "Mobile"), "Chennai");
		
		System.out.println(tm1);

	}

}
-------------------------------------------------------------

package com.ravi.sorted_map;

import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;

public class TreeMapAndTreeSetDemo {

	public static void main(String[] args)
	{
		SortedSet<String> ts1 = new TreeSet<>();
		ts1.add("Hyd");
		ts1.add("Pune");
		ts1.add("Indore");
		
		TreeSet<String> ts2 = new TreeSet<>(ts1);
		System.out.println(ts2);
		
		TreeMap<String,String> tm1 = new TreeMap<>();
		tm1.put("ravi@gmail.com", "ravi1234");
		tm1.put("scott@gmail.com", "scott1234");
		tm1.put("smith@gmail.com", "smith1234");
		
		TreeMap<String,String> tm2 = new TreeMap<String,String>(tm1);
		System.out.println(tm2);
		
		
				
				
	}

}

Note : SortedSet/SortedMap as a parameter to the Constructor.
-------------------------------------------------------------
Program to convert HashMap to TreeMap :
----------------------------------------
package com.ravi.sorted_map;

import java.util.HashMap;
import java.util.TreeMap;

public class HashMapToTreeMap
{

	public static void main(String[] args)
	{
		
		
		HashMap<String,String> tm1 = new HashMap<>();
		tm1.put("ravi@gmail.com", "ravi1234");
		tm1.put("scott@gmail.com", "scott1234");
		tm1.put("smith@gmail.com", "smith1234");
		
		TreeMap<String,String> tm2 = new TreeMap<>(tm1);
		System.out.println(tm2);
		
				
				
	}

}
-------------------------------------------------------------
//Provide custom sorting by using Comaparator :
-----------------------------------------------
package com.ravi.sorted_map;

import java.util.TreeMap;

record Employee(Integer empId, String employeeName)
{
	
}


public class TreeMapCustomSorting {

	public static void main(String[] args) 
	{
		TreeMap<Employee,String> tm1 = new TreeMap<>((e1,e2)-> e1.empId().compareTo(e2.empId()));
		tm1.put(new Employee(333, "Scott"), "London");
		tm1.put(new Employee(222, "Smith"), "Australia");
		tm1.put(new Employee(111, "Martin"), "England");

		System.out.println("Sorting By using ID :");
		System.out.println(tm1);
		
		TreeMap<Employee,String> tm2 = new TreeMap<>((e1,e2)-> e1.employeeName().compareTo(e2.employeeName()));
		tm2.put(new Employee(333, "Scott"), "London");
		tm2.put(new Employee(222, "Smith"), "Australia");
		tm2.put(new Employee(111, "Martin"), "England");

		System.out.println("Sorting By using Name :");
		System.out.println(tm2);
	}

}
-------------------------------------------------------------
Methods of SortedMap interface :
--------------------------------
1) firstKey()  //first key

2) lastKey()  //last key

3) headMap(int keyRange) //less than the specified range

4) tailMap(int keyRange)  //equal or greater than the specified range

5) subMap(int startKeyRange, int endKeyRange) //the range of key where startKey will be inclusive and endKey will be exclusive.

return type of headMap(), tailMap() and subMap() return type would be SortedMap(I)
-------------------------------------------------------------
import java.util.*;  
public class SortedMapMethodDemo
	{  
 public static void main(String args[])
	 {  
		SortedMap<Integer,String> map=new TreeMap<>();    
		  map.put(100,"Amit");    
		  map.put(101,"Ravi");    

		  map.put(102,"Vijay");    
		  map.put(103,"Rahul");   

		  System.out.println("First Key: "+map.firstKey());  //100
		   System.out.println("Last Key "+map.lastKey());   //103
		   System.out.println("headMap: "+map.headMap(102));  //100 101
		   System.out.println("tailMap: "+map.tailMap(102));  //102 103
		   System.out.println("subMap: "+map.subMap(100, 102)); //100 101 

	 }
 }  
-------------------------------------------------------------
Assignment for NavigableMap Methods :
-------------------------------------
1) ceilingEntry(K key)
2) ceilingKey(K key)
3) floorEntry(K key)
4) floorKey(K key)
5) higherEntry(K key)
6) higherKey(K key)
5) lowerEntry(K key)
6) lowerKey(K key)
-------------------------------------------------------------
Properties :
------------
public class Properties extends Hashtable<K,V>

It is a legacy class and It represents a persistent set of properties.

It is subclass of Hashtable available in java.util package. 

It is used to maintain the persistent data in the key-value form. It takes both key and value as a string. 

Properties class is a subclass of Hashtable. 

It is used to load properties file in our java application directly at runtime without compilation/deploymnet.

Constructors :
--------------
Commonly we are using this constructor  :

   Properties p1 = new Properties();
   Creates an empty property list.

Methods :
----------
1) public void load(InputStream stream): Reads a property list (key    and value pair) from the input byte stream.

2) public void load(Reader reader):Reads a property list (key and       value pair) from the Character Oriented stream.

3) Object setProperty(String key, String value) : It Calls the Hashtable method put internally.

4) public String getProperty(String key) :Searches for the property     with the specified key in this property list.

5) public void	store(OutputStream out, String comments) : It
   Writes this property list (key and element pairs) in this Properties table to the output stream.

6) public void	store(Writer writer, String comments) : It
   Writes this property list (key and element pairs) in this Properties table to the character stream.

------------------------------------------------------------
package com.ravi.properties;

import java.io.FileReader;
import java.io.IOException;
import java.util.Properties;

public class PropertiesDemo1 {

	public static void main(String[] args) throws IOException 
	{
		FileReader reader = new FileReader("D:\\new\\db.properties");
		
		Properties p1 = new Properties();
		p1.load(reader);
		
		String driverName = p1.getProperty("driverName");
		String userName = p1.getProperty("userName");
		String password = p1.getProperty("password");
		
		
		System.out.println("Driver name is :"+driverName);
		System.out.println("User name is :"+userName);
		System.out.println("Password name is :"+password);
		
		

	}

}


If we make changes in the properties file then directly (without compilation) we can take the the value in our java file so after any modification in the properties file we need not to re-compile/re-deploy our java program.
-------------------------------------------------------------
package com.ravi.properties;

import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Properties;

public class PropertiesDemo2 
{
	public static void main(String[] args) throws IOException 
	{
		String filePath = "D:\\new\\data.properties";
		
		var properties = new Properties();
		
		var writer = new FileWriter(filePath);
		try(writer)
		{
			properties.setProperty("book", "Java");
			properties.setProperty("author", "James");
			properties.setProperty("price", "1200");
			
			properties.store(writer, "Book Properties set");
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
		
		//Reading the data from Properties file 
		
		var reader = new FileReader(filePath);
		
		try(reader)
		{
			properties.load(reader);
			System.out.println("Book Name is "+properties.getProperty("book"));
			System.out.println("Author Name is "+properties.getProperty("author"));
			System.out.println("Price Name is "+properties.getProperty("price"));
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
		
		

	}
}
-------------------------------------------------------------
26-12-2024
------------
Queue interface :-
-------------------
1) It is sub interface of Collection(I) available from JDK 1.5V hence it support all the methods of Collection interface.

2) It works in FIFO(First In first out) 

3) It is an ordered collection.

4) In a queue, insertion is possible from last is called REAR where as deletion is possible from the starting is called FRONT of the queue.

5)In order to support Basis Queue operation, LinkedList class   implements Deque and Deque interface exetnds Queue  
  interface.
  

PriorityQueue :
----------------
public class PriorityQueue extends AbstractQueue implements Serializable 

It is a predefined class in java.util package, available from Jdk 1.5 onwards.

It stores the elements using balanced binary heap tree, meaning the smallest element is at the head of the queue.

The elements of the priority queue are ordered according to their natural ordering (binary heap tree), or by using Comparator provided at queue construction time, depending on which constructor is used.

A priority queue does not permit null elements.

It provides natural sorting order so we can't take non-comparable objects(hetrogeneous types of Object)

The initial capacity of PriorityQueue is 11.

Constructor :
--------------
1) PriorityQueue pq1 = new PriorityQueue();
   Will create PriorityQueue object with default capacity is 11, Elements will be inserted based on binary heap tree.

2) PriorityQueue pq2 = new PriorityQueue(int initialCapacity);
Will create PriorityQueue with user specified capacity

3) PriorityQueue pq3 = new PriorityQueue(int initialCapacity, Comparator cmp);
Will create PriorityQueue with user specified capacity and own userdefined order.

4) PriorityQueue pq3 = new PriorityQueue(Comparator cmp);
   Will create PriorityQueue with user defined sorting order

5) PriorityQueue pq4 = new PriorityQueue(Collection c);
   Loose coupling

---------------------------------------------------------------------
Methods :-
----------
public boolean offer(E e) /public boolean add(E e) :- Used to add an element in the Queue

public E poll()  :- It is used to fetch the elements from head of the queue, after fetching it will delete the element.


public E peek()  :- It is also used to fetch the elements from head of the queue, Unlike poll it will only fetch but not delete the element.

public boolean remove(Object element) :- It is used to remove an element. The return  type is boolean. 
-------------------------------------------------------------
//Programs on PriorityQueue

import java.util.PriorityQueue;

public class PriorityQueueDemo 
{
      public static void main(String[] argv)
      {
            PriorityQueue<Object> pq = new PriorityQueue<>();
            pq.add("Orange");
			pq.add("Apple");
			pq.add("Mango");
			pq.add("Guava");
			pq.add("Grapes");
			//pq.add(null);  Inavlid
			//pq.add(23);    Invalid
			
			System.out.println(pq);            

      }
}
------------------------------------------------------------
import java.util.PriorityQueue;
public class PriorityQueueDemo1
{
      public static void main(String[] argv)
      {
            PriorityQueue<Integer> pq = new PriorityQueue<>();
			pq.add(11);
            pq.add(2);
            pq.add(4);          
			pq.add(6);
           System.out.println(pq);
	  }
}
-------------------------------------------------------------
import java.util.PriorityQueue;
public class PriorityQueueDemo2
{
      public static void main(String[] argv)
      {
            PriorityQueue<String> pq = new PriorityQueue<>();
            pq.add("2");
            pq.add("4");          
			pq.add("6");  
            System.out.print(pq.peek() + " "); 
            pq.offer("1");
			pq.offer("9");
            pq.add("3");   //         
			
            pq.remove("1");
            System.out.print(pq.poll() + " "); 
            if (pq.remove("2"))
                System.out.print(pq.poll() + " ");
            System.out.println(pq.poll() + " " + pq.peek()+"  "+pq.poll());
	  }
}
-------------------------------------------------------------
package com.ravi.comparator;

import java.util.Comparator;
import java.util.PriorityQueue;

record Task(String name, int priority)
{
}


public class PriorityQueueDemo3 {
    public static void main(String[] args) 
    {                                               
        PriorityQueue<Task> taskQueue = new PriorityQueue<>(new Comparator<Task>() 
		{
            @Override
            public int compare(Task t1, Task t2) 
            {
                return Integer.compare(t1.priority(), t2.priority());
            }
        });

        taskQueue.add(new Task("Submit report", 4));
        taskQueue.add(new Task("Find Bug", 2));
        taskQueue.add(new Task("Write Program", 1));
        taskQueue.add(new Task("Execute Program", 3));

        while (!taskQueue.isEmpty()) 
        {
            System.out.println("Executing: " + taskQueue.poll());
        }
    }
}
Note : For Custom object we are using Comparator interface.
-------------------------------------------------------------
27-12-2024
-----------
Why generic came into picture : 
------------------------------------
As we know our compiler is known for Strict type checking because java is a statically typed checked language.  

The basic problem with collection is, It can hold any kind of Object.

ArrayList al = new ArrayList();
al.add("Ravi");
al.add("Aswin");
al.add("Rahul");
al.add("Raj");
al.add("Samir");

for(int i =0; i<al.size(); i++)
{ 
   String s = (String) al.get(i);
   System.out.println(s);
}

By looking the above code it is clear that Collection stores everything in the form of Object so here even after adding String type only we need to provide casting as shown below.

------------------------------------------------------------
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
        ArrayList al = new ArrayList();
		al.add(12);
		al.add(15);
		al.add(18);
		al.add(22);
		al.add(24);

		for (int i=0; i<al.size(); i++)
		{
             Integer x = (Integer) al.get(i);
			 System.out.println(x);
		}

    }

}
-------------------------------------------------------------
import java.util.*;
class Test2
{
	public static void main(String[] args) 
	{
		ArrayList t = new ArrayList(); //raw type
		t.add("alpha");
		t.add("beta");
		for (int i = 0; i < t.size(); i++) 
		{
		  String str =(String) t.get(i);
		  System.out.println(str);
		}

		 t.add(1234);
		 t.add(1256);
		  for (int i = 0; i < t.size(); ++i)
	       {	 
			 String obj= (String)t.get(i); //we can't perform type casting here
			 System.out.println(obj);
		  }
	}
}

Even after type casting there is no guarantee that the things which are coming from ArrayList Object is String only because we can add anything in the Collection as a result java.lang.ClassCastException 
-------------------------------------------------------------
To avoid all the above said problem Generics came into picture from JDK 1.5 onwards
 
 -> It deals with type safe Object so there is a guarantee of both the end i.e putting inside and getting outside.
 
 Example:-
 ArrayList<String > al = new ArrayList<>();

 Now here we have a guarantee that only String can be inserted as well as only String will come out from the Collection so we can perform String related operation.

Advantages of Generics :
------------------------
 1) Type Safe Object (No Compilation warning)
 2) No need of type casting
 3) Strict compile time checking. (*Type Erasure)
-------------------------------------------------------------
import java.util.*;
public class Test3
{
public static void main(String[] args) 
{
		ArrayList<String> al = new ArrayList<>();  //Generic type
		al.add("Ravi");
		al.add("Ajay");
		al.add("Vijay");		
		
        for(int i=0; i<al.size(); i++)
		{
		String name = al.get(i); //no type casting is required
		System.out.println(name.toUpperCase());
		}
   }
}
-----------------------------------------------------------
//Program that describes the return type of any method can be type safe 
//[We can apply generics on method return type]

import java.util.*;
public class Test4
{
	public static void main(String [] args)
	{
		Dog d1 = new Dog();
		Dog d2 = d1.getDogList().get(0);
		System.out.println(d2);
	}
}
class Dog
{
	public List<Dog> getDogList()
	{
		ArrayList<Dog> d = new ArrayList<>();
        d.add(new Dog());
		d.add(new Dog());
		d.add(new Dog());
		return d;
	}
}

Note :- In the above program the compiler will stop us from returning anything which is not compaitable List<Dog> and there is a guarantee that only "type safe list of Dog object" will be returned so we need not to provide type casting as shown below
Dog d2 = (Dog) d1.getDogList().get(0);  //before generic.
-------------------------------------------------------------
//Mixing generic with non-generic
----------------------------------
//Mixing generic with non-generic
import java.util.*;

class Car
{
}
public class Test5
{
	public static void main(String [] args) 
	{
	ArrayList<Car> a = new ArrayList<>();
	a.add(new Car());
	a.add(new Car());
    a.add(new Car());

	ArrayList b = a;  //assigning Generic to raw type
    System.out.println(b);   
	}
}
-------------------------------------------------------------
//Mixing generic to non-generic
import java.util.*; 
public class Test6 
{
	public static void main(String[] args) 
	{ 
		List<Integer> myList = new ArrayList<>(); 
		myList.add(4); 
		myList.add(6); 
		myList.add(5);
        
		UnknownClass u = new UnknownClass(); 
		int total = u.addValues(myList); 
		System.out.println("The sum of Integer Object is :"+total); 
	} 
}  
class UnknownClass 
{ 
	public int addValues(List list)  //generic to raw type  
	{ 
	Iterator it = list.iterator();    
	int total = 0; 
	while (it.hasNext()) 
	{
		int i = ((Integer)it.next());
		total += i;                           //total =  15
	} 
	return total; 
	} 
} 

Note :-
In the above program the compiler will not generate any warning message because even though we are assigning type safe Integer Object to unsafe or raw type List Object but this List Object is not inserting anything new in the collection so there is no risk to the caller.
-------------------------------------------------------------
//Mixing generic to non-generic
import java.util.*; 
public class Test7 
{
	public static void main(String[] args) 
	{ 
		List<Integer> myList = new ArrayList<>();	

		myList.add(4); 
		myList.add(6); 
		UnknownClass u = new UnknownClass(); 
		int total = u.addValues(myList); 
		System.out.println(total); 
	} 
}  
class UnknownClass 
{ 
    public int addValues(List list)  
	{ 
		list.add(5);	//adding object to raw type
		Iterator it = list.iterator(); 
		int total = 0; 
		while (it.hasNext()) 
		{
		int i = ((Integer)it.next()); 
		total += i; 
		} 
		return total; 
	} 
} 


Here Compiler will generate warning message because the unsafe object is inserting the value 5 to safe object.
------------------------------------------------------------

*Type Erasure
------------
In the above program the compiler will  generate  warning message because the unsafe List Object is inserting the Integer object 5 so the type safe Integer object is getting value 5 from unsafe type so there is a problem to the caller method.

By writing ArrayList<Integer> actually JVM does not have any idea that our ArrayList was suppose to hold only Integers. 

All the type safe generics information does not exist at runtime. All our generic code is Strictly for compiler. 

There is a process done by java compiler called "Type erasure" in which the java compiler converts generic version to non-generic type.

List<Integer> myList = new ArrayList<Integer>();

At the compilation time it is fine but at runtime for JVM the code becomes

List myList = new ArrayList();

Note :- GENERIC IS STRICTLY COMPILE TIME PROTECTION.
------------------------------------------------------------
//Polymorphism with array :
--------------------------
//Polymorphism with array

import java.util.*;
abstract class Animal
{
	public abstract void checkup();
}

class Dog extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Dog checkup");
	}
}

class Cat extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Cat checkup");
	}
}

class Bird extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Bird checkup");
	}
}

public class  Test8
{
	public void checkAnimals(Animal animals[]) 
	{
		for(Animal animal : animals)
		{
			animal.checkup();
		}
	}

	public static void main(String[] args) 
	{
		Dog []dogs={new Dog(), new Dog()};

		Cat []cats={new Cat(), new Cat(), new Cat()};

		Bird []birds = {new Bird(), new Bird()};

		Test8 t = new Test8();

		t.checkAnimals(dogs);
		t.checkAnimals(cats);
		t.checkAnimals(birds);
	}
}

Note :-From the above program it is clear that polymorphism(Upcasting) concept works with array.
-------------------------------------------------------------
import java.util.*;
abstract class Animal
{
	public abstract void checkup();
}

class Dog extends Animal
{
    @Override
	public void checkup()
	{
		System.out.println("Dog checkup");
	}
}

class Cat extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Cat checkup");
	}
}
class Bird extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Bird checkup");
	}
}
public class Test9
{
	public void checkAnimals(List<Animal> animals)  
	{
		for(Animal animal : animals)
		{
             animal.checkup();
		}
	}
	public static void main(String[] args) 
	{
		List<Dog> dogs = new ArrayList<>();
		dogs.add(new Dog());
		dogs.add(new Dog());

		List<Cat> cats = new ArrayList<>();
		cats.add(new Cat());
		cats.add(new Cat());

		List<Bird> birds = new ArrayList<>();
		birds.add(new Bird());
		
		Test9 t = new Test9();
		t.checkAnimals(dogs);
		t.checkAnimals(cats);
		t.checkAnimals(birds);

	}
}


Note :- The above program will generate compilation error.

So from the above program it is clear that polymorphism does not work in the same way for generics as it does with arrays.

Example :

Parent [] arr = new Child[5]; //valid
Object [] arr = new String[5]; //valid

But in generics the same type is not valid

List<Object> list = new ArrayList<Integer>(); //Invalid
List<Parent> mylist = new ArrayList<Child>(); //Invalid
-------------------------------------------------------------
Concurrent Collections (3 class  CHM)

Stream API
  11 Methods on intermediate operation
     Optional class
     Method Reference
     New Date and Time API
  11 Method on terminal Operation
  84 IQ Stream API
  Executors Framework
-------------------------------------------------------------
import java.util.*;
public class Test10
{
public static void main(String [] args)
	{	
	 /*
	   ArrayList<Object> al = new ArrayList<String>(); [Compile time]
	   ArrayList al = new ArrayList();  [Runtime, Type Erasure]
	   al.add("Ravi");
	   */
	     

		Object []obj = new String[3]; //valid with Array
		obj[0] = "Ravi";
		obj[1] = "hyd";
		obj[2] =  90; //java.lang.ArrayStoreException
		System.out.println(Arrays.toString(obj));
	}
}


Note :- Program will generate java.lang.ArrayStoreException because we are trying to insert 90 (integer value) into String array.

In Array we have an Exception called ArrayStoreException (Which protect us to assign some illegal value in the array) but the same Exception or such type of exception, is not available with Generics (due to Type Erasure) that is the reason in generics, compiler does not allow upcasting concept.
(It is a strict compile time protection)
-------------------------------------------------------------
Wild card character(?) :
------------------------
<?>	-: Many possibilities because It is unknown type.

<Animal> -: Only <Animal> can assign, but not Dog or sub type of animal

<? super Dog>-: Dog, Animal, Object can assign (Compiler has                      surity) It is also called lower bound.

<? extends Animal> -: Below of Animal(Child of Animal) means, sub classes of Animal.It is also called Upper bound. Here in future, It is possible that Animal class may have more sub classes.
------------------------------------------------------------
import java.util.*;
class Parent
{
}
class Child extends Parent
{
}

public class Test11
{
public static void main(String [] args)
	{	
		ArrayList<Parent> lp = new ArrayList<Child>(); //error

		ArrayList<Parent> lp1 = new ArrayList<Parent>(); 

		ArrayList<Child> lp2 = new ArrayList<>(); 

		System.out.println("Success");
	}
}
------------------------------------------------------------
//program on wild-card chracter
import java.util.*;
class Parent
{

}
class Child extends Parent
{
}
public class Test12
{
public static void main(String [] args)
	{	
		List<?> lp = new ArrayList<Parent>(); 
		System.out.println("Wild card....");
	}
}
------------------------------------------------------------
import java.util.*;
public class Test13 
{
	public static void main(String[] args) 
	{
		List<? extends Number> list1 = new ArrayList<Long>();

		List<? super String> list2 = new ArrayList<Object>();

		List<? super Gamma> list3 = new ArrayList<Beta>();

		List list4 = new ArrayList();
		
		System.out.println("yes");
	}
}

class Alpha
{
}
class Beta extends Alpha
{
}
class Gamma extends Beta
{
}
------------------------------------------------------------
28-12-2024
---------
WAP to design our own functional interface :
--------------------------------------------
package com.ravi.generics;

interface TriFunction<T,U,V,R>
{
	public abstract R apply(T a, U b, V c);
}

public class MyTypeParameter 
{
	public static void main(String[] args) 
	{
		TriFunction<Integer,Integer,Integer,String> t1 = (a,b,c)-> 
		a+b+c+"";
		
		System.out.println(t1.apply(100, 200, 300));

	}

}
---------------------------------------------------------------
package com.ravi.generics;

class Box<T>  
{
	private T data;

	public Box(T data) 
	{
		super();
		this.data = data;
	}

	public T getData() 
	{
		return data;
	}
	
}

public class Test14 {

	public static void main(String[] args) 
	{
		Box<Integer> intType = new Box<>(12);
		System.out.println("Integer type is :"+intType.getData());
		
		Box<Double>  doubleType = new Box<>(23.89);
		System.out.println("Double type is :"+doubleType.getData());
		
		Box<Employee>  empType = new Box<>(new Employee(111, "Scott"));
		System.out.println(empType.getData());

	}

}

record Employee(Integer id, String name)
{
	
}
---------------------------------------------------------------
package com.ravi.generics;

class Fruit
{
	
}
class Apple extends Fruit
{

	@Override
	public String toString() 
	{
		return "Apple";
	}
	
}
class Mango extends Fruit
{
	@Override
	public String toString() 
	{
		return "Mango";
	}
}

class Basket<E>  //E is Fruit Type
{
	private E element;

	public Basket(E element) // Fruit element = new Mango();
	{
		super();
		this.element = element;
	}

	public E getData() 
	{
		return element;
	}	
	
}

public class Test15 
{
   public static void main(String[] args) 
   {
	  Basket<Fruit> basket = new Basket<>(new Apple());
	  Apple apple = (Apple) basket.getData();
	  System.out.println(apple);
	  
	  basket = new Basket<>(new Mango());
	  Mango mango = (Mango)basket.getData();
	  System.out.println(mango);
	  
	  
   }
}
--------------------------------------------------------------
package com.ravi.generics;
interface Printable
{
	void print();
}
class MyNumber extends Number implements Printable 
{
	private int value;  //90
	
	
	public MyNumber(int value) 
	{
		super();
		this.value = value;
	}

	@Override
	public void print() 
	{
		System.out.println(value);	//90	
	}

	@Override
	public int intValue() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public long longValue() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public float floatValue() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public double doubleValue() {
		// TODO Auto-generated method stub
		return 0;
	}
	
}

class Accept<T extends Number & Printable> //Upper bound
{
	private T item;

	public Accept(T item) //MyNumber item = new MyNumber(90);
	{
		super();
		this.item = item;
	}
	
	public void show()
	{
		item.print();
		
	}
}


public class Test16 
{
  public static void main(String[] args) 
  {
	Accept<MyNumber> accept = new Accept<>(new MyNumber(90));
	accept.show();
  }
}
--------------------------------------------------------------
Method Overloading is not possible by using Generic concept because all generic type information will not be available at runtime(Type Erasure)

package com.ravi.generics;

import java.util.List;

public class MyTypeParameter 
{
	public static void main(String[] args) 
	{
	}
	
	public static void accept(List<String> list1)
	{
		
	}
	public static void accept(List<Integer> list2) //error
	{
		
	}

}
--------------------------------------------------------------
package com.ravi.generics;

//Generic Constructor

class MyAccept
{
	
	public <T> MyAccept(T value)  //Constructor is Generic Type
	{
		System.out.println(value);
	}
}
public class Test17 
{
	public static void main(String[] args) 
	{
		MyAccept myAccept1 = new MyAccept(12);
		MyAccept myAccept2 = new MyAccept("Ravi");
		MyAccept myAccept3 = new MyAccept(new String("NIT"));

	}

}
-------------------------------------------------------------
package com.ravi.generics;
//Generic Method

public class Test18 
{
	public static void main(String[] args) 
	{
		Integer []intArr = {10,20,30,40,50};
		printArray(intArr);
		
		System.out.println(".............");
		
		String []cities = {"Hyderabad", "Banglore", "Mumbai", "Kolkata"};
		printArray(cities);
		
	}
	
	public static <T> void printArray(T[] array)
	{
		for(T element : array )
		{
			System.out.println(element);
		}
	}

}
--------------------------------------------------------------


public class Test19
{
	public static void main(String[] args) 
	{
		show(12);
		show("Ravi");
	}
	
	public static <T> void show(T element)
	{
		System.out.println("Generic :"+element);
	}
	
	public static <T> void show(String element)
	{
		System.out.println("String "+element);
	}

}
--------------------------------------------------------------
package com.ravi.generics;



import java.util.Arrays;
import java.util.List;

public class Test20 {

	 public static void main(String[] args) 
	 {
		/* 
	   ArrayList<?> list1 = new ArrayList<Integer>();
	   list1.add(12); 
		 	 */
		 
		 /*var<?> list = new ArrayList<Integer>();
		 list.add(12);
		 list.add(13);
		 list.add(14);
		 list.add(15);
		 System.out.println(list);	*/	 
		 
		 
		/*
		 List<? extends Number> numbers = Arrays.asList(1,2,3,4,5);
		 numbers.set(0, 12); */
		
		
		
		 List<? super Integer> myNumbers = Arrays.asList(1,2,3,4,5);
		 myNumbers.set(0,12);
		 System.out.println(myNumbers);
		

   }
}
---------------------------------------------------------------
Concurrent collections in java
-------------------------------
Concurrent Collections are introduced from JDK 1.5 onwards to enhance the performance of multithreaded application.

These are threadsafe collection and available in java.util.concurrent sub package.

Limitation of Traditional Collection :
---------------------------------------
1) In the Collection framework most of the Collection classes are not thread-safe because those are non-synchronized like ArrayList, LinkedList, HashSet, HashMap is non-synchronized in nature, So If multiple threads will perform any operation on the collection object simultaneously then we will get some wrong data this is known as Data race or Race condition.

2) Some Collection classes are synchronized like Vector, Hashtable but performance wise these classes are slow in nature.

Collections class has provided static methods to make our List, Set and Map interface classes as a synchronized.
			
	a) public static List synchronizedList(List list)
	b) public static Set synchronizedSet(Set set)
	c) public static Map synchronizedMap(Map map)

3) Traditional Collection works with fail fast iterator that means while iterating the element, if there is a change in structure then we will get java.util.ConcurrentModificationException,
     On the other hand concurrent collection works with fail safe iterator where even though there is a change in structure but we will not get ConcurrentModificationException.
---------------------------------------------------------------
//Programs :
-------------
import java.util.*;
public class Collection1
{
     public static void main(String args[])
     {
          ArrayList al = new ArrayList();
          al.add(10);
          al.add(20);
          al.add(30);
          al.add(40);
          al.add(50);
		  al.add(50);
          System.out.println("Arraylist Elements : "+al);
          Set s = new HashSet(al);         
          System.out.println("Set Elements are: "+s);
     } 
}
--------------------------------------------------------------
//Collections.synchronizedList(List list);
import java.util.*;
public class Collection2 
{
	public static void main(String[] args) 
	{
		ArrayList<String> arl = new ArrayList<>();   
		arl.add("Apple");   
		arl.add("Orange");
		arl.add("Grapes");
		arl.add("Mango");
		arl.add("Guava");
		arl.add("Mango");

		List<String> syncCollection = Collections.synchronizedList(arl);

		List<String> upperList = new ArrayList<>(); //New List
    
		Runnable listOperations = () -> 
		{
			synchronized (syncCollection) 
			{
               syncCollection.forEach(str -> upperList.add(str.toUpperCase()));           
           }
       };

	   Thread t1 = new Thread(listOperations);
	   t1.start();

      upperList.forEach(x -> System.out.println(x));
	}
}
---------------------------------------------------------------
//Collections.synchronizedSet(Set set);
import java.util.*;  
public class Collection3
{  
    public static void main(String[] args) 
		{  
        Set<String> set = Collections.synchronizedSet(new HashSet<>());  
        set.add("Apple");   
		set.add("Orange");
		set.add("Grapes");
		set.add("Mango");
		set.add("Guava");
		set.add("Mango");           
        System.out.println("Set after Synchronization :");  
        synchronized (set) 
		{  
           Spliterator<String> itr = set.spliterator();
		   itr.forEachRemaining(str -> System.out.println(str));  
         }       
     }  
}  
-------------------------------------------------------------
//Collections.synchronizedMap(Map map);
import java.util.*;  
public class Collection4
{  
    public static void main(String[] args) 
	{  
        Map<String, String> map = new HashMap<String, String>();  
        map.put("1", "Ravi");  
        map.put("4", "Elina");  
        map.put("3", "Aryan");  
        Map<String, String> synmap = Collections.synchronizedMap(map);  
        System.out.println("Synchronized map is :" + synmap);                 
     }  
}  
--------------------------------------------------------------
package com.ravi.concurrent_collection;

import java.util.ArrayList;
import java.util.Iterator;

class Concurrent extends Thread
{
	private ArrayList<String> languages = null;	
	
	public Concurrent(ArrayList<String> languages) 
	{
		super();
		this.languages = languages;
	}

	@Override
	public void run()
	{
		try
		{
			Thread.sleep(2000);
		}
		catch(InterruptedException e)
		{
			e.printStackTrace();
		}
		
		languages.add("Pascal");
	}
}

public class ConcurrentModificationExceptionDemo 
{
	public static void main(String[] args) throws InterruptedException 
	{
		ArrayList<String> listOfLanguage = new ArrayList<>();
		listOfLanguage.add("Java");
		listOfLanguage.add("C++");
		listOfLanguage.add("C");
		listOfLanguage.add("Spring");
		listOfLanguage.add("Adv Java");
		
		Concurrent concurrent = new Concurrent(listOfLanguage);
		concurrent.start();
		
		Iterator<String> iterator = listOfLanguage.iterator();
		
		while(iterator.hasNext())
		{
			Thread.sleep(500);
			System.out.println(iterator.next());
		}
		
	}

}


Note :- In the above program we will get java.util.ConcurrentModificationException because Iterator is fail fast iterator.
---------------------------------------------------------------
package com.ravi.concurrent_collection;

import java.util.Iterator;
import java.util.Vector;

class Concurrent extends Thread
{
	private Vector<String> languages = null;	
	
	public Concurrent(Vector<String> languages) 
	{
		super();
		this.languages = languages;
	}

	@Override
	public void run()
	{
		try
		{
			Thread.sleep(2500);
		}
		catch(InterruptedException e)
		{
			e.printStackTrace();
		}
		
		languages.add("Pascal");
	}
}

public class ConcurrentModificationExceptionDemo 
{
	public static void main(String[] args) throws InterruptedException 
	{
		Vector<String> listOfLanguage = new Vector<>();
		listOfLanguage.add("Java");
		listOfLanguage.add("C++");
		listOfLanguage.add("C");
		listOfLanguage.add("Spring");
		listOfLanguage.add("Adv Java");
		
		Concurrent concurrent = new Concurrent(listOfLanguage);
		concurrent.start();
		
		Iterator<String> iterator = listOfLanguage.iterator();
		
		while(iterator.hasNext())
		{
			Thread.sleep(500);
			System.out.println(iterator.next());
		}
		
	}

}

Here Vector class is thread-safe but still we will get java.util.ConcurrentModificationException because Iterator is Fail Fast Iterator.
--------------------------------------------------------------
Working with java.util.concurrent classes :
-------------------------------------------

CopyOnWriteArrayList in java :
---------------------------------
public class CopyOnWriteArrayList implements List, Cloneable, Serializable, RanomAccess

A CopyOnWriteArrayList is similar to an ArrayList but it has some additional features like thread-safe. This class is existing in java.util.concurrent sub package.

ArrayList is not thread-safe. We can’t use ArrayList in the multi-threaded environment because it creates a problem in ArrayList values  (Data inconsistency).

*The CopyOnWriteArrayList is an enhanced version of ArrayList. If we are making any modifications(add, remove, etc.)  on  CopyOnWriteArrayList object then internally JVM creates a new copy of Object by use of clone() method.

The CopyOnWriteArrayList is costly, if we want to perform update operations  so it is immutable object , because whenever we make any changes the JVM creates a cloned copy of the  array and add/update element to new object.

It is a thread-safe version of ArrayList as well as here Iterator is fail safe iterator.

*CopyOnWriteArrayList is the best choice if we want to perform read operation frequently in multithreaded environment.

The CopyOnWriteArrayList is a replacement of a synchronized List, because it offers better concurrency.

Constructors of CopyOnWriteArrayList in java :
----------------------------------------------------
We have 3 constructors :

1) CopyOnWriteArrayList c = new CopyOnWriteArrayList(); 
It creates an empty list in memory. This constructor is useful when we want to create a list without any value.

2) CopyOnWriteArrayList c = new CopyOnWriteArrayList(Collection c);
Interconversion of collections.

3) CopyOnWriteArrayList c = new CopyOnWriteArrayList(Object[] obj) ;
It Creates a list that containing all the elements that is specified Array. This constructor is useful when we want to create a CopyOnWriteArrayList from Array.


Note : All the immutable objects are thread-safe because, On immutable objects if we perform any operation then another object will be created in a new memory location so at a time multiple threads can work together.

All String Object, Wrapper classes object, Concurrent collection classes are Thread-safe.
---------------------------------------------------------------
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

public class CopyOnWriteArrayListExample1
{
    public static void main(String[] args) 
    {
        List<String> list = Arrays.asList("Apple", "Orange", "Mango","Kiwi", "Grapes");

		
        CopyOnWriteArrayList<String> copyOnWriteList = new CopyOnWriteArrayList<String>(list);
         
        System.out.println("Without modification = "+copyOnWriteList); 
        
		 //Iterator1
        Iterator<String> iterator1 = copyOnWriteList.iterator();
         
        //Add one element and verify list is updated
        copyOnWriteList.add("Guava");
         
        System.out.println("After modification = "+copyOnWriteList);   
         
        //Iterator2
        Iterator<String> iterator2 = copyOnWriteList.iterator();
         
        System.out.println("Element from first Iterator:");
        iterator1.forEachRemaining(System.out::println);

        System.out.println("Element from Second Iterator:");
        iterator2.forEachRemaining(System.out::println);   
    }
}
---------------------------------------------------------------
import java.util.*;
import java.util.concurrent.*;
class ConcurrentModification extends Thread
{
	CopyOnWriteArrayList<String> al = null;
	public ConcurrentModification(CopyOnWriteArrayList<String> al)
	{
		this.al = al;
	}
	@Override
	public void run()
	{			
		try
		{
			Thread.sleep(1000);
		}
		catch (InterruptedException e)
		{
		}
	    al.add("KIWI");
	}
}
public class CopyOnWriteArrayListExample2  
{
	public static void main(String[] args) throws InterruptedException
	{
		CopyOnWriteArrayList<String> arl = new CopyOnWriteArrayList<>();
		arl.add("Apple");   
		arl.add("Orange");
		arl.add("Grapes");
		arl.add("Mango");
		arl.add("Guava");
		ConcurrentModification cm = new ConcurrentModification(arl);
		cm.start();
			
		Iterator<String> itr = arl.iterator();
        while(itr.hasNext())
		{
			String str = itr.next();
			System.out.println(str);
		   Thread.sleep(500);
		}

	    System.out.println("............");

		Spliterator<String> spl =  arl.spliterator();
		spl.forEachRemaining(x -> System.out.println(x));
	}
}
--------------------------------------------------------------
CopyOnWriteArraySet :
--------------------------
public class CopyOnWriteArraySet<E> extends AbstractSet<E> implements Serializable

A CopyOnWriteArraySet is a thread-safe version of HashSet in Java and it works like CopyOnWriteArrayList in java. 

The CopyOnWriteArraySet internally used CopyOnWriteArrayList to perform all type of operation.It means the CopyOnWriteArraySet internally creates an object of CopyOnWriteArrayList and perform operation on it. 

Whenever we perform add, set, and remove operation on CopyOnWriteArraySet, it internally creates a new object of CopyOnWriteArrayList and copies all the data to the new object by eliminating duplicates so, when it is used in by multiple threads, it doesn’t create a problem, but it is well suited if we have small size collection and want to perform only read operation by multiple threads.

 The CopyOnWriteArraySet is the replacement of synchronizedSet and offers better concurrency.

It creates a new copy of the array every time iterator is created, so performance is slower than HashSet.

Constructors :
----------------
It has two constructors 

1) CopyOnWriteArraySet set1 = new CopyOnWriteArraySet();
    It will create an empty Set


2) CopyOnWriteArraySet set1 = new CopyOnWriteArraySet(Collection c); Interconversion of collection.
--------------------------------------------------------------
import java.util.*;
import java.util.concurrent.CopyOnWriteArraySet;


public class CopyOnWriteArraySetExample1
{
  public static void main(String[] args) 
   {
        CopyOnWriteArraySet<String> set = new CopyOnWriteArraySet<>();

        set.add("Java");
        set.add("Python");
        set.add("C++");
		set.add("Java");

        Iterator itr = set.iterator();
		

        // Adding a new element
        set.add("JavaScript");
       
        for (String language : set) 
		{
            System.out.println(language);
        }
		
		System.out.println("............");
		while(itr.hasNext())
	    {
			System.out.println(itr.next());
	    }
    }
}
--------------------------------------------------------------
import java.util.concurrent.CopyOnWriteArraySet;

public class CopyOnWriteArraySetExample2
{
    public static void main(String[] args) 
    {
        CopyOnWriteArraySet<Integer> set = new CopyOnWriteArraySet<Integer>();
        set.add(1);
        set.add(2);
        set.add(3);
        set.add(4);
        set.add(5);
        
        System.out.println("Is element contains: "+set.contains(1));
        
        System.out.println("Is set empty: "+set.isEmpty());
        
        System.out.println("remove element from set: "+set.remove(3));
        
        System.out.println("Element from Set: "+ set);
    }
}
------------------------------------------------------------
*** ConcurrentHashMap<K,V>
--------------------------
public class ConcurrentHashMap<K,V> extends AbstractMap<K,V> implements java.util.concurrent.ConcurrentMap<K,V>, Serializable

Like HashMap, ConcurrentHashMap provides similar functionality except that it has internally maintained concurrency. 

It is the concurrent version of the HashMap. It internally maintains a Hashtable that is divided into segments(Buckets). 

The number of segments depends upon the level of concurrency required the Concurrent HashMap. By default, it divides into 16 segments and each Segment behaves independently. It doesn’t lock the whole HashMap as done in Hashtables/synchronizedMap, it only locks the particular segment(Bucket) of HashMap. [Bucket level locking]

ConcurrentHashMap allows multiple threads can perform read/write operation without locking the ConcurrentHashMap object.

It does not allow null as a key or evan null as a value.

[Note :- TreeSet, TreeMap, Hashtable, PriroityQueue, ConcurrentHashMap , These 5 classes never containing null key or null element)

It contains 5 types of constructor :
----------------------------------------
1) ConcurrentHashMap chm1 = new ConcurrentHashMap();
   Will create ConcurrentHashMap object with default capacity is 16 with 16 locks.

2) ConcurrentHashMap chm2 = new ConcurrentHashMap(int initialCapacity);

3) ConcurrentHashMap chm3 = new ConcurrentHashMap(int initialCapacity, float loadFactor);

4) ConcurrentHashMap chm4 = new ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);

5) ConcurrentHashMap chm5 = new ConcurrentHashMap(Map m);
----------------------------------------------------------------
Internal Working of ConcurrentHashMap :
-----------------------------------------------
Like HashMap and Hashtable, the ConcurrentHashMap is also used Hashtable data structure. But it is using the segment locking strategy to handle the multiple threads. 

A segment(bucket) is a portion of ConcurrentHashMap and ConcurrentHashMap uses a separate lock for each thread. Unlike Hashtable or synchronized HashMap,  it doesn’t synchronize the whole HashMap or Hashtable for one thread.

As we have seen in the internal implementation of the HashMap, the default size of HashMap is 16 and it means there are 16 buckets. The ConcurrentHashMap uses the same concept is used in ConcurrentHashMap. It uses the 16 separate locks for 16 buckets by default because the default concurrency level is 16. It means a ConcurrentHashMap can be used by 16 threads at same time. If one thread is reading from one bucket(Segment), then the second bucket doesn’t affect it.  

Why we need ConcurrentHashMap in java?
-------------------------------------------------
As we know Hashtable and HashMap works based on key-value pairs. But why we are introducing another Map? As we know HashMap is not thread safe, but we can make it thread-safe by using Collections.synchronizedMap() method and Hashtable is thread-safe by default.  

But a synchronized HashMap or Hashtable is accessible only by one thread at a time because the object get the lock for the whole HashMap or Hashtable (Diagram). Even multiple threads can’t perform read operations at the same time. It is the main disadvantage of Synchronized HashMap or Hashtable, which creates performance issues. So ConcurrentHashMap provides better performance than Synchronized HashMap or Hashtable.

------------------------------------------------------------------
//Converting HashMap to ConcurrentHashMap
import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;

public class ConcurrentHashMapExample1
{
   public static void main(String args[])
   {
       
       HashMap<Integer, String> hashMap = new HashMap<Integer, String>();
       hashMap.put(1, "Ravi");
       hashMap.put(2, "Ankit");
       hashMap.put(3, "Prashant");
	   hashMap.put(4, "Pallavi");
       
       ConcurrentHashMap<Integer, String> concurrentHashMap = new ConcurrentHashMap<>(hashMap);
       System.out.println("Object from ConcurrentHashMap: "+ concurrentHashMap);

   }
 
}
--------------------------------------------------------
import java.util.Iterator;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class ConcurrentHashMapExample2
{
   public static void main(String args[])
   { 
       // Creating ConcurrentHashMap
       Map<String, String> cityTemperatureMap = new ConcurrentHashMap<>();
        
        cityTemperatureMap.put("Delhi", "30");
        cityTemperatureMap.put("Mumbai", "32");
        cityTemperatureMap.put("Chennai", "35");
        cityTemperatureMap.put("Bangalore", "22" );
        
        Iterator<String> iterator = cityTemperatureMap.keySet().iterator();  

        while (iterator.hasNext())
        {
        System.out.println(cityTemperatureMap.get(iterator.next()));
          // adding new value, it won't throw error
          cityTemperatureMap.put("Hyderabad", "28");   
        }
   }
}

Here we are modifying the concurrenthashmap structure during the iteartion but the entry will be inserted in the original concurrenthashmap and we will not get any runtime exception because it provides bucket level locking.
--------------------------------------------------------------
Stream API in Java :
--------------------
It is introduced from Java 8 onwards, the Stream API is used to process the collection objects.

It contains classes for processing sequence of elements over Collection object and array.

Stream is a predefined interface available in java.util.stream sub package.

Package Information :
---------------------
java.util -> Base package
java.util.function -> Functional interfaces
java.util.concurrent -> Multithreaded support
java.util.stream -> Processing of Collection Object

Interfaces which contains forEach() method in java :
-----------------------------------------------------
The Java forEach() method is a  technique to iterate over a collection such as (list, set or map) and stream. It  is used to perform a given action on each of the element of the collection.

The forEach() method has been added in following places:

Iterable interface – This makes Iterable.forEach() method available to all collection classes. Iterable interface is the super interface of Collection interface

Map interface – This makes forEach() operation available to all map classes.

Stream interface – This makes forEach() operations available to all types of stream.

Creation of Streams to process the data :
-----------------------------------------------
We can create Stream from  collection or array with the help of stream() and Stream.of(T ...values) methods:

A stream()  method is added to the Collection interface and allows creating a Stream<T> using any collection object as a source

public java.util.stream.Stream<E> stream();

The return type of this method is Stream interafce available in java.util.stream sub package.

Eg:-
List<String> items = new ArrayList<String>();
		items.add("Apple");
		items.add("Orange");
		items.add("Mango");
		//Collection to stream
		Stream<String> stream = items.stream();
-----------------------------------------------------------------
package com.ravi.basic;
import java.util.*;  //Base package
import java.util.stream.*; //Sub package
public class StreamDemo1 
{
	public static void main(String[] args) 
	{
		List<String> items = new ArrayList<>();
		items.add("Apple");
		items.add("Orange");
		items.add("Mango");

        //Collections Object to Stream
		Stream<String> strm = items.stream();
		strm.forEach(p -> System.out.println(p));
	}
}

public static java.util.stream.Stream  of(T ...x)
-----------------------------------------------------
It is a static method of Stream interface through which we can create Stream of arrays and Stream of Collection. The return type of this method is Stream interface.
------------------------------------------------------------------
//Stream.of()
package com.ravi.basic;
import java.util.stream.*;
public class StreamDemo2 
{
	public static void main(String[] args) 
	{
		//Stream of numbers
		Stream<Integer> stream = Stream.of(1,2,3,4,5,6,7,8,9);
		stream.forEach(p -> System.out.println(p));

		System.out.println("...............................");

         //Anonymous Array Object (Stream of Arrays)
		
		Stream<Integer> strm = Stream.of( new Integer[]{15,29,45,8,16} );
		strm.forEach(p -> System.out.println(p));
	}
}
--------------------------------------------------------------
01-01-2025
----------
Intermediate Operation :
----------------------------
Intermediate Operation will always produce another Stream, Here Streams are not in a closed position that means further we can apply any intermediate operation method.

In intermediate operation the method return type will always Stream because it is producing another Stream.

The following methods are available to perform intermediate operation.

filter(Predicate<T> predicate): Returns a new stream which contains filtered elements based on the boolean expression using Predicate.

map(Function<T, R> mapper): Transforms elements in the stream using the provided mapping function.  

flatMap(Function<T, Stream<R>> mapper): Flattens a stream of streams into a single stream. 

distinct(): Returns a stream with distinct elements (based on their equals method).

sorted(): Returns a stream with elements sorted in their natural order.

sorted(Comparator<T> comparator): Returns a stream with elements sorted using the specified comparator.

peek(Consumer<T> action): Allows us to perform an action on each element in the stream without modifying the stream.

limit(long maxSize): Limits the number of elements in the stream to a specified maximum size.

skip(long n): Skips the first n elements in the stream.

takeWhile(Predicate<T> predicate): Returns a stream of elements from the beginning until the first element that does not satisfy the predicate.

dropWhile(Predicate<T> predicate): Returns a stream of elements after skipping elements at the beginning that satisfy the predicate.

Note : All these methods return type is Stream.
--------------------------------------------------------------
java.lang.IllegalStateException :
---------------------------------
Once our Stream is closed or consumed then further we can't reuse the Stream as shown in the program.

package com.ravi.stream_demo;

import java.util.stream.Stream;

public class StreamOperation {

	public static void main(String[] args) 
	{
	  Stream<Integer> of = Stream.of(1,2,3,4,5,6);
	  of.filter(num -> num%2==0).forEach(System.out::println);//Stream is closed
	  of.forEach(System.out::println); //IllegalStateException	  

	}

}
-------------------------------------------------------------
public abstract Stream<T> filter(Predicate<T> p) : 
----------------------------------------------------
It is a predfined method of Stream interface. It is used to select/filter elements as per the Predicate passed as an argument. It is basically used to filter the elements based on boolean condition.

public abstract <T>  collect(java.util.stream.Collectors c)
----------------------------------------------------------------
It is a predfined method of Stream interface. It is used to return the result of the intermediate operations performed on the stream.

It is a terminal operation. It is used to collect the data after filteration and convert the data to the Collection(List/Set/Map).

Collectors is a predfined final singleton class available in java.util.stream sub package which conatins  static method toList(),toSet(), toMap() to convert the data as a List/Set/Map i.e Collection object. The return type of these method is List/Set/Map interface.
-------------------------------------------------------------
//Filter all the even numbers from Collection 
package com.ravi.basic;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class StreamDemo3 
{
	public static void main(String[] args) 
	{
	  List<Integer> listOfNumber = Arrays.asList(1,2,3,4,5,6,7,8,9,10,11,12);
	  
	  //Retrieving all the even numbers without Stream
	  System.out.println("Printing even number without Stream ");
	  List<Integer> evenList = new ArrayList<>();
	    
	    for(Integer number : listOfNumber)
	    {
	    	if(number % 2==0)
	    	{
	    		evenList.add(number);
	    	}
	    }
	    evenList.forEach(System.out::println);
	  
	    
	    //Retrieving all the even numbers with Stream
	    System.out.println("Printing even number with Stream ");
	    listOfNumber.stream().filter(num -> num%2==0).forEach(System.out::println);
	}
}
--------------------------------------------------------------
package com.ravi.basic;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class FilterDemo {

	public static void main(String[] args) 
	{
		List<String> listOfName = List.of("Aryan","Ankit","Raj","Rohit","Aniket","Raj","Aryan");
		
		//Retrieve all the names which starts from A and it should not 
		//contain duplicate
		
		 Set<String> collect = listOfName.stream().filter(str -> str.startsWith("A")).collect(Collectors.toSet());
		System.out.println(collect);
		
	}

}
-------------------------------------------------------------
package com.ravi.basic;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class FilterDemo1 {

	public static void main(String[] args) 
	{
		 //Retrieve all the names which starts from R and duplicates are allowed
        List<String> collect = Stream.of("Aryan","Ankit","Raj","Rohit","Aniket","Raj","Aryan").filter(str-> str.startsWith("R")).collect(Collectors.toList());
		
      System.out.println(collect);
		
		

	}

}
--------------------------------------------------------------
//Filtering the name which starts with 'R' character with Stream API where duplicate are not allowed and in Alphabetical order
package com.ravi.basic;

import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collector;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class StreamDemo4 
{
	public static void main(String[] args) 
	{
		List<String> listOfName = Arrays.asList("Raj","Rahul","Ankit","Roshan","Raj","Scott","Rohit","Ratan","Ravi");
		
		listOfName.stream().filter(str -> str.startsWith("R")).distinct().sorted().forEach(System.out::println);
		
		
	}
}
-------------------------------------------------------------
public Stream sorted() :
------------------------
It is a predefined method of Stream interface.
It provides default natural sorting order.
The return type of this method is Stream because It is an intermediate operation.
It has an overloaded method which accept Comparator<T> as a parameter through which we can provide user-defined sorting logic

//Sorting the data
package com.ravi.basic;
import java.util.*;
import java.util.stream.*;
public class StreamDemo5 
{
	public static void main(String[] args) 
	{
	List<String> names = Arrays.asList("Zaheer","Rahul","Aryan","Sailesh","Zaheer");

		List<String> collect = names.stream().distinct().sorted().collect(Collectors.toList());
		
		System.out.println(collect);
	}
}
-------------------------------------------------------------
How to work with filter() method for custom Object :
----------------------------------------------------
package com.ravi.basic;

import java.util.stream.Stream;

//Fetch all the Employees name whose salary is greater then 50k 

record Employee(Integer empId, String empName, Double empSalary)
{
	
}

public class StreamDemo6
{
	public static void main(String[] args) 
	{
	   Employee e1 = new Employee(111, "Juber", 90000D); 
	   Employee e2 = new Employee(222, "Aryan", 40000D); 
	   Employee e3 = new Employee(333, "Scott", 60000D); 
	   Employee e4 = new Employee(444, "Rahul", 70000D); 
	   Employee e5 = new Employee(555, "Aakash",85000D); 
	   Employee e6 = new Employee(666, "Manav", 92000D); 
	   Employee e7 = new Employee(666, "Manav", 92000D); 
   	
	   Stream<Employee> streamOfEmployees = Stream.of(e1,e2,e3,e4,e5,e6,e7);
	   
	   streamOfEmployees.filter(emp -> emp.empSalary()>50000).distinct().forEach(employee -> System.out.println(employee.empName()));
	   
	   
	}
}
--------------------------------------------------------------
02-01-2025
-----------
public Stream map(Function<? super T,? extends R> mapper) :
-----------------------------------------------------------
It is a predefined method of Stream interface.

It takes Function (Predefined functional interafce ) as a parameter.

It performs intermediate operation and consumes single element from input Stream and produces single element to output Stream. (1:1 transformation)

Here mapper function is functional interface which takes one input and provides one output.
-------------------------------------------------------------

package com.ravi.basic;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;
 
public class StreamDemo7 
{
    public static void main(String[] args) 
    {
      //add value 10 to each and every number
      List<Integer> listOfNumbers =  Arrays.asList(11,12,13,14,15,16,17,18,19,20);	
      
      listOfNumbers.stream().map(num -> num + 10).forEach(System.out::println);
     
      System.out.println("..................");
    	
    //Find even numbers in stream and collect the cubes
     List<Integer> numbers = List.of(1,2,3,4,5,6,7,8,9,10,11,12);
    
     numbers.stream().filter(n -> n%2==0).map(num -> num*num*num).forEach(System.out::println);
            	    	
        
    }
}
-------------------------------------------------------------
//Find the length of the name

package com.ravi.stream_demo;

import java.util.Arrays;
import java.util.List;

public class FindLegthOfName {

	public static void main(String[] args) 
	{
		List<String> listOfName = Arrays.asList("Rahul","Scott","Raj","Elina","Aaarti","Puja");
		
		listOfName.stream().map(str -> str.length()).forEach(System.out::println);

	}

}
-------------------------------------------------------------
//Retrieve first character of all the given name

package com.ravi.stream_demo;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class RetrieveFirstCharacter {

	public static void main(String[] args) 
	{
	  List<String> listOfName = Arrays.asList("Jaya","Arnav","Virat","Aryan");
	  
	  List<Character> collect = listOfName.stream().map(str -> str.charAt(0)).collect(Collectors.toList());
	  System.out.println(collect);

	}

}
-------------------------------------------------------------
//Retrieve the employee salary from employee object

package com.ravi.stream_demo;

import java.util.ArrayList;

record Employee(Integer empId, String empName, Double empSalary, Integer age)
{
	
}

public class RetrieveSalary {

	public static void main(String[] args) 
	{
		ArrayList<Employee> listOfEmployees = new ArrayList<>();
		listOfEmployees.add(new Employee(111, "A", 70000D,24));
		listOfEmployees.add(new Employee(222, "B", 60000D,26));
		listOfEmployees.add(new Employee(333, "C", 45000D,23));
		listOfEmployees.add(new Employee(444, "D", 65000D,28));
		listOfEmployees.add(new Employee(555, "E", 55000D,29));
		
		System.out.println("Salary of all the employees :");
		listOfEmployees.stream().map(emp -> emp.empSalary()).forEach(System.out::println);
		
		//Taking Employee object and converting into double
		double sum = listOfEmployees.stream().mapToDouble(emp -> emp.empSalary()).sum();
		System.out.println("The total cost of the company for all the Employees :"+sum);

		int sumOfAge = listOfEmployees.stream().mapToInt(e -> e.age()).sum();
		System.out.println("Sum of all employee Age :"+sumOfAge);
	}

}
-------------------------------------------------------------
//Retrieve the name whose length is > 3 and convert those 
//names in uppercase

package com.ravi.stream_demo;

import java.util.Arrays;
import java.util.List;

public class FilterNameAndUpperCase {

	public static void main(String[] args) 
	{
		List<String> listOfName = Arrays.asList("Rahul","Scott","Raj","Elina","Ram","Puja");
		
		listOfName.stream().filter(str -> str.length()>3).map(name -> name.toUpperCase()).forEach(System.out::println);
		
		

	}

}
--------------------------------------------------------------
//Program on map(Function<T,R> mapped)
package com.ravi.basic;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class StreamDemo8
{ 
	public static void main(String args[])
	{
		//Get the name of the Player from Player Object
		Set<String> playersName = createPlayerList().stream().map(player -> player.playerName()).collect(Collectors.toSet());
		System.out.println(playersName);
		
		
	}	
	
	public static List<Player> createPlayerList()
	{
		List<Player> al = new ArrayList<>();
		al.add(new Player(18, "Virat"));
		al.add(new Player(45, "Rohit"));
		al.add(new Player(7, "Dhoni"));
		al.add(new Player(18, "Virat"));
		al.add(new Player(90, "Bumrah"));
		al.add(new Player(67, "Hardik"));
		
		return al;
	}
}
 
record Player(Integer playerId, String playerName) 
{
	
}
-------------------------------------------------------------
public Stream flatMap(Function<? super T,? extends Stream<? extends R>> mapper)

It is a predefined method of Stream interface.

The map() method produces one output value for each input value in the stream So if there are n elements in the stream, map() operation will produce a stream of n output elements.

flatMap() is two step process i.e. map() + Flattening. It helps in converting Collection<Collection<T>> into Collection<T> [to make flat i.e converting Collections of collection into single collection or merging of all the collection]

//flatMap()
//map + Flattening [Converting Collections of collection into single collection]
package com.ravi.basic;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collector;
import java.util.stream.Collectors;

public class StreamDemo9  
{
	public static void main(String[] args) 
	{
		List<String> list1 = Arrays.asList("A","B","C");
		List<String> list2 = Arrays.asList("D","E","F");
		List<String> list3 = Arrays.asList("G","H","I");
		
		List<List<String>> nestedColl = Arrays.asList(list1, list2, list3);
		System.out.println("Original Nested Collection :"+nestedColl);
		
		List<String> flatColl = nestedColl.stream().flatMap(list -> list.stream()).collect(Collectors.toList());
		System.out.println(flatColl);
		
	}
}
--------------------------------------------------------------
//Flattening of prime, even and odd number
package com.ravi.basic.flat_map;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class FlatMapDemo1 
{
	public static void main(String[] args)
	{
      List<Integer> primeNumbers = Arrays.asList(5,7,11);
      List<Integer> evenNumbers = Arrays.asList(2,4,6);
      List<Integer> oddNumbers = Arrays.asList(1,3,5);
      
      List<List<Integer>> nestedColl = List.of(primeNumbers,evenNumbers,oddNumbers);
      System.out.println(nestedColl); 
      
     List<Integer> flatList = nestedColl.stream().flatMap(num -> num.stream()).collect(Collectors.toList());
     
     System.out.println(flatList);
      
	
	}

}
--------------------------------------------------------------
//Fetching first character using flatMap()
package com.ravi.basic.flat_map;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class FlatMapDemo2 
{
	public static void main(String[] args)
	{
	    List<String> listOfNames = Arrays.asList("Jaya","Aryan","Virat","Aakash");
	    List<Character> collect = listOfNames.stream().flatMap(str -> Stream.of(str.charAt(0))).collect(Collectors.toList());
	    System.out.println(collect);
		
	}

}
-------------------------------------------------------------
package com.ravi.basic.flat_map;

import java.util.Arrays;
import java.util.List;
import java.util.function.UnaryOperator;
import java.util.stream.Collectors;

class Product 
{
	private Integer productId;
	private List<String> listOfProducts;

	public Product(Integer productId, List<String> listOfProducts)       
	{
		super();
		this.productId = productId;
		this.listOfProducts = listOfProducts;

	}

	public Integer getProductId() {
		return productId;
	}

	public List<String> getListOfProducts() {
		return listOfProducts;
	}
}

public class FlatMapDemo3 
{
	public static void main(String[] args) 
	{
		List<Product> listOfProduct = Arrays.asList(
	new Product(1, Arrays.asList("Camera", "Mobile", "Laptop")),
	new Product(2, Arrays.asList("Bat", "Ball", "Wicket")),
	new Product(3, Arrays.asList("Chair", "Table", "Lamp")),
	new Product(4, Arrays.asList("Cycle", "Bike", "Car"))

		);

		List<String> productList = listOfProduct.stream().flatMap(list ->list.getListOfProducts().stream()).collect(Collectors.toList());
		
		System.out.println(productList);
		
	}

}
-------------------------------------------------------------
06-01-2025
-----------
Working with Primitive Streams :
----------------------------------
Streams works with collections of objects and not primitive types.

Now, to provide a way to work with the three most used primitive types – int, long and double, Java provides three primitive specialized implementations of Stream.

IntStream (represents sequence of primitive int elements)
LongStream (represents sequence of primitive long elements)
DoubleStream (represents sequence of primitive double elements)


Method of IntStream, LongStream and DoubleStream :
---------------------------------------------------
IntStream, LongStream and DoubleStream are the predefined interfaces available in java.util.stream sub package.

These interfaces contain static method of(T ...values) through which we can create corresponding type of element.

Arrays which is a predefined class in java.util package provides a predefined method called stream() which will also convert corresonding array object into Stream type 

public static IntStream stream(int [] array);
public static LongStream  stream(long [] array);
public static DoubleStream stream(double [] array);


Note : By using above methods we can convert the array into corresponding Stream Type.

package com.ravi.basic.flat_map;

import java.util.Arrays;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;

public class PrimitiveToStreamDemo1
{
public static void main(String[] args)
{
	IntStream intStream = IntStream.of(1,2,3,4,5,6,7,8);
	LongStream longStream = LongStream.of(1L,2L,3L,4L,5L);
	DoubleStream doubleStream = DoubleStream.of(1.1,1.2,1.3,1.4,1.5);
	intStream.forEach(System.out::print );
	System.out.println();
	longStream.forEach(System.out::print);
	System.out.println();
	doubleStream.forEach(System.out::print);
	
	System.out.println();
	System.out.println("..........................");
	
	
	int a[] = {1,2,3,4,5};
	IntStream intStream2 = Arrays.stream(a);
	
	long l[] = {1L, 2L, 3L, 4L};
	LongStream longStream2 = Arrays.stream(l);
	
	double d[] = {1.2, 2.6, 3.9, 8.9};
	DoubleStream doubleStream2 = Arrays.stream(d);
	
	intStream2.forEach(System.out::print );
	System.out.println();
	longStream2.forEach(System.out::print);
	System.out.println();
	doubleStream2.forEach(System.out::print);
	
	
 }	

}
--------------------------------------------------------------
IntStream flatMapToInt(Function<? super T, ? extends IntStream> mapper)
IntStream flatMapToInt(Function<? super T, ? extends IntStream> mapper)

It is a predefined method of Stream interface which comes under flattening.

It allows us to transform each element of the stream into an IntStream (a stream of primitive int values) and then flattens these resulting streams into a single IntStream.

Note : IntStream is a specialized stream for working with int values avilable in java.util.stream sub package.

-------------------------------------------------------------
package com.ravi.basic.flat_map;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class FlatMapToIntDemo1 {

	public static void main(String[] args) 
	{
		int []a1 = new int[] {1,2,3};
		int []a2 = new int[] {4,5,6};
		int []a3 = new int[] {7,8,9};
		
	   List<int[]> nestedArray = Arrays.asList(a1,a2,a3);
	   
		IntStream intStream = nestedArray.stream().flatMapToInt(array-> IntStream.of(array));
		intStream.forEach(System.out::print);
		
		
		
		
	}

}
--------------------------------------------------------------

LongStream flatMapToLong(Function<? super T, ? extends LongStream> mapper) :

It is a predefined method of Stream interface which comes under flattening.

It allows us to transform each element of the stream into a LongStream (a stream of primitive long values) and then flattens these resulting streams into a single LongStream.

Note : LongStream is a specialized stream for working with long values avilable in java.util.stream sub package.
--------------------------------------------------------------
package com.ravi.basic.flat_map;

import java.util.Arrays;
import java.util.List;
import java.util.stream.LongStream;

public class FlatMapToLongDemo1 {

	public static void main(String[] args) 
	{
		long []arr1 = new long[] {23,33,43};
		long []arr2 = new long[] {53,63,73};
		long []arr3 = new long[] {83,93,103};
		
		List<long[]> longArray = Arrays.asList(arr1, arr2,arr3);
		LongStream flatMapToLong = longArray.stream().flatMapToLong(array -> Arrays.stream(array));
		
		flatMapToLong.forEach(System.out::println);
	}

}
-------------------------------------------------------------
DoubleStream flatMapToDouble(Function<? super T, ? extends DoubleStream> mapper)

It is a predefined method of Stream interface which comes under flattening.

It allows us to transform each element of the stream into an DoubleStream (a stream of primitive double values) and then flattens these resulting streams into a single DoubleStream.

Note : DoubleStream is a specialized stream for working with double values avilable in java.util.stream sub package.

package com.ravi.basic.flat_map;

import java.util.Arrays;
import java.util.List;
import java.util.stream.DoubleStream;

public class FlatMapToDoubleDemo1
{
    public static void main(String[] args)
    {
    	double d1[] = new double[]{1.1, 1.2, 1.3};
    	double d2[] = new double[]{2.1, 2.2, 2.3};
    	double d3[] = new double[]{3.1, 3.2, 3.3};
        
    	List<double[]> listOfDoubleArrays = Arrays.asList(d1,d2,d3);
          
            DoubleStream doubleStream = listOfDoubleArrays.stream()
                .flatMapToDouble(array -> Arrays.stream(array));

            // Print each double value in the flattened stream
            doubleStream.forEach(System.out::println);
        }
}
--------------------------------------------------------------
**Difference between map() and flatMap()
--------------------------------------
map() method transforms each element into another single element.

flatMap() transforms each element into a stream of elements and then flattens those streams into a single stream.

We should use map() when you want a one-to-one transformation, and  we should use flatMap() when dealing with nested structures or when you need to produce multiple output elements for each input element.
--------------------------------------------------------------

public Stream sorted() :
------------------------
It is a predefined method of Stream interface.
It provides default natural sorting order.
The return type of this method is Stream.
It has an overloaded method which accept Comparator<T> as a parameter 
through which we can provide user-defined sorting logic

public Stream distinct() :
--------------------------
It is a predefined method of Stream interface.

If we want to return stream from another stream by removing all the duplicates then we should use distinct() method.

-------------------------------------------------------------
package com.ravi.basic;

import java.util.List;
import java.util.stream.Stream;

public class StreamDemo10
{
	public static void main(String[] args)
	{
		 //Print the numbers in ascending order
		 List<Integer> listOfNum = List.of(89,67,56,45,23,15); 
		 listOfNum.stream().sorted((i1,i2)-> i1.compareTo(i2)).forEach(System.out::println);
		 System.out.println("===============================");
		 
		 //Print the numbers in descending order
		 List<Integer> listOfNumber = List.of(89,67,56,45,23,15); 
		 listOfNumber.stream().sorted((i1,i2)-> i2.compareTo(i1)).forEach(System.out::println);
		 System.out.println("===============================");
		 
		 //Print the names in Ascending order
		 Stream<String> strOfName = Stream.of("Ankit","Scott","Smith","James");
		 strOfName.sorted((s1,s2)-> s1.compareTo(s2)).forEach(System.out::println);
		 
		 System.out.println("===============================");
		 
		 //Print the names in Descending order
		 Stream<String> strmOfName = Stream.of("Ankit","Scott","Smith","James");
		 strmOfName.sorted((s1,s2)-> s2.compareTo(s1)).forEach(System.out::println);
		 
		 System.out.println("......................");
		 Stream<String> s = Stream.of("Virat", "Rohit", "Dhoni", "Virat", "Rohit","Aswin","Bumrah");
			s.distinct().sorted((s1,s2)-> s2.compareTo(s1)).forEach(System.out::println);
		
	}

}
-------------------------------------------------------------
package com.ravi.basic;
import java.util.stream.Stream; 
public class StreamDemo11 
{
	public static void main(String[] args) 
	{
		Stream<Integer> numbers = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 3, 4, 5);

		numbers.distinct().forEach(System.out::println);

		
	}
}
--------------------------------------------------------------
public Stream<T> limit(long maxSize) :
----------------------------------------
It is a predefined method of Stream interface to work with sequence of elements.

The limit() method is used to limit the number of elements in a stream by providing maximum size.

It creates a new Stream by taking the data from original Stream.

Elements which are not in the range or beyond the range of specified limit will be ignored.

-------------------------------------------------------------
public Stream<T> skip(long n) :
-------------------------------
It is a predefined method of Stream interface which is used to skip the elements from begning of the Stream.

It returns a new stream that contains the remaining elements after skipping the specified number of elements which is passed as a parameter.


package com.ravi.basic;
import java.util.stream.Stream; 
public class StreamDemo12 
{
	public static void main(String[] args) 
	{
		Stream<String> s = Stream.of("Virat", "Rohit", "Dhoni", "Zaheer", "Raina","Sahwag","Sachin","Bumrah");
		s.limit(6).forEach(System.out::println);
		
		System.out.println("..................");
		//Working with infinite Stream
		 Stream<Double> limit = Stream.generate(()-> Math.random()).limit(15);
		 limit.forEach(System.out::println);
		 
		 System.out.println("...............");
		 //Working with infinite Stream
		 Stream<Integer> iterate = Stream.iterate(11, n -> n + 1).limit(10); 
		 iterate.forEach(System.out::println);
		 
		 
		 Stream<String> of = Stream.of("Virat", "Rohit", "Rahul","Gill", "Pant","Bumrah","Nitish");
		 of.skip(2).forEach(System.out::println);
		 
	}
}
--------------------------------------------------------------
public Stream<T> peek(Consumer<? super T> action) :
--------------------------------------------
It is a predefined method of Stream interface which is used to perform a side-effect operation on each element in the stream while the stream remains unchanged.

It is an intermediate operation that allows us to perform operation on each element of Stream without modifying original.

The peek() method takes a Consumer as an argument, and this function is applied to each element in the stream. The method returns a new stream with the same elements as the original stream.
-------------------------------------------------------------
package com.ravi.basic;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class StreamDemo13 
{
	public static void main(String[] args) 
	{
		Stream<String> streamOfFruits = Stream.of("Apple","Mango","Grapes","Kiwi","pomogranate");

		List<Integer> fruitLength = streamOfFruits
		    .peek(str -> System.out.println("Peeking from Original: " + str.toUpperCase()))
		    .map(fruit -> fruit.length())
		    .collect(Collectors.toList());
		System.out.println("-----------------");
		System.out.println(fruitLength);
		
	}

}

Note :- peek(Consumer<T> cons) will not modify the Original Source.
--------------------------------------------------------------
public Stream<T> takeWhile(Predicate<T> predicate) : 
-----------------------------------------------------
It is a predefined method of Stream interface introduced from java 9 which is used to perform a side-effect operation on each element in the stream while the stream remains unchanged.

*It is used to create a new stream that includes elements from the original stream only as long as they satisfy a given predicate.

package com.ravi.basic;

import java.util.stream.Stream;

public class StreamDemo14 
{
 public static void main(String[] args) 
 {
	 Stream<Integer> numbers = Stream.of(10,11,9,13,2,1,100);

     numbers.takeWhile(n -> n > 9).forEach(System.out::println);     

     System.out.println(".......................");
     
    
     numbers = Stream.of(12,2,10,3,4,5,6,7,8,9);
     
     numbers.takeWhile(n -> n%2==0).forEach(System.out::println);
     
    
     System.out.println(".......................");
     
     numbers = Stream.of(1,2,3,4,5,6,7,8,9);
     
     numbers.takeWhile(n -> n < 9).forEach(System.out::println);
     
     System.out.println(".......................");
     
     
     numbers = Stream.of(11,2,3,4,5,6,7,8,9); 
     
     numbers.takeWhile(n -> n > 9).forEach(System.out::println);
     
     System.out.println(".............................");
     
     Stream<String> stream = Stream.of("Ravi", "Ankit", "Rohan", "Aman", "Ravish"); 

     stream.takeWhile(str -> str.charAt(0)=='R').forEach(System.out::println); 
     
    
   
	 
 }
}
-------------------------------------------------------------
public Stream<T> dropWhile(Predicate<T> predicate) :
----------------------------------------------------
It is a predefined method of Stream interface introduced from java 9 which is used to create a new stream by excluding elements from the original stream as long as they satisfy a given predicate.

package com.ravi.basic;

import java.util.stream.Stream;

public class StreamDemo15 {

	public static void main(String[] args) 
	{
		Stream<Integer> numbers = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

		numbers.dropWhile(num -> num < 7).forEach(System.out::println);
		
		System.out.println("..................................");
		
		numbers = Stream.of(15, 8, 7, 9, 5, 6, 7, 8, 9, 10);

		numbers.dropWhile(num -> num > 5).forEach(System.out::println); 
		      
		
	}

}
--------------------------------------------------------------
Method Reference :
-------------------
























































































  



























































































































































































 





































































































    
 
    


























































   





















































































































































































	      
	      
	      





































































































































































































































































































